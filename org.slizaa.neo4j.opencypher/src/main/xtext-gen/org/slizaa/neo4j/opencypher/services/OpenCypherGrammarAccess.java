/*
 * generated by Xtext 2.13.0
 */
package org.slizaa.neo4j.opencypher.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class OpenCypherGrammarAccess extends AbstractGrammarElementFinder {
	
	public class CypherElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Cypher");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCypherAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cQueryOptionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cQueryOptionsQueryOptionsParserRuleCall_1_0 = (RuleCall)cQueryOptionsAssignment_1.eContents().get(0);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Cypher:
		//	{Cypher} queryOptions=QueryOptions statement=Statement ';'?;
		@Override public ParserRule getRule() { return rule; }
		
		//{Cypher} queryOptions=QueryOptions statement=Statement ';'?
		public Group getGroup() { return cGroup; }
		
		//{Cypher}
		public Action getCypherAction_0() { return cCypherAction_0; }
		
		//queryOptions=QueryOptions
		public Assignment getQueryOptionsAssignment_1() { return cQueryOptionsAssignment_1; }
		
		//QueryOptions
		public RuleCall getQueryOptionsQueryOptionsParserRuleCall_1_0() { return cQueryOptionsQueryOptionsParserRuleCall_1_0; }
		
		//statement=Statement
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }
		
		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_0() { return cStatementStatementParserRuleCall_2_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class QueryOptionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.QueryOptions");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAllOptionsAction_0 = (Action)cGroup.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_1 = (UnorderedGroup)cGroup.eContents().get(1);
		private final Assignment cExplainAssignment_1_0 = (Assignment)cUnorderedGroup_1.eContents().get(0);
		private final Keyword cExplainEXPLAINKeyword_1_0_0 = (Keyword)cExplainAssignment_1_0.eContents().get(0);
		private final Assignment cProfileAssignment_1_1 = (Assignment)cUnorderedGroup_1.eContents().get(1);
		private final Keyword cProfilePROFILEKeyword_1_1_0 = (Keyword)cProfileAssignment_1_1.eContents().get(0);
		private final Assignment cCypherOptionAssignment_1_2 = (Assignment)cUnorderedGroup_1.eContents().get(2);
		private final RuleCall cCypherOptionCypherOptionParserRuleCall_1_2_0 = (RuleCall)cCypherOptionAssignment_1_2.eContents().get(0);
		
		//QueryOptions:
		//	{AllOptions} (explain?='EXPLAIN'? & profile?='PROFILE'? & cypherOption+=CypherOption*);
		@Override public ParserRule getRule() { return rule; }
		
		//{AllOptions} (explain?='EXPLAIN'? & profile?='PROFILE'? & cypherOption+=CypherOption*)
		public Group getGroup() { return cGroup; }
		
		//{AllOptions}
		public Action getAllOptionsAction_0() { return cAllOptionsAction_0; }
		
		//explain?='EXPLAIN'? & profile?='PROFILE'? & cypherOption+=CypherOption*
		public UnorderedGroup getUnorderedGroup_1() { return cUnorderedGroup_1; }
		
		//explain?='EXPLAIN'?
		public Assignment getExplainAssignment_1_0() { return cExplainAssignment_1_0; }
		
		//'EXPLAIN'
		public Keyword getExplainEXPLAINKeyword_1_0_0() { return cExplainEXPLAINKeyword_1_0_0; }
		
		//profile?='PROFILE'?
		public Assignment getProfileAssignment_1_1() { return cProfileAssignment_1_1; }
		
		//'PROFILE'
		public Keyword getProfilePROFILEKeyword_1_1_0() { return cProfilePROFILEKeyword_1_1_0; }
		
		//cypherOption+=CypherOption*
		public Assignment getCypherOptionAssignment_1_2() { return cCypherOptionAssignment_1_2; }
		
		//CypherOption
		public RuleCall getCypherOptionCypherOptionParserRuleCall_1_2_0() { return cCypherOptionCypherOptionParserRuleCall_1_2_0; }
	}
	public class CypherOptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.CypherOption");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCypherOptionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCYPHERKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVersionNumberAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVersionNumberVersionNumberParserRuleCall_2_0 = (RuleCall)cVersionNumberAssignment_2.eContents().get(0);
		private final Assignment cConfigurationOptionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConfigurationOptionConfigurationOptionParserRuleCall_3_0 = (RuleCall)cConfigurationOptionAssignment_3.eContents().get(0);
		
		//CypherOption:
		//	{CypherOption} 'CYPHER' versionNumber=VersionNumber? configurationOption+=ConfigurationOption*;
		@Override public ParserRule getRule() { return rule; }
		
		//{CypherOption} 'CYPHER' versionNumber=VersionNumber? configurationOption+=ConfigurationOption*
		public Group getGroup() { return cGroup; }
		
		//{CypherOption}
		public Action getCypherOptionAction_0() { return cCypherOptionAction_0; }
		
		//'CYPHER'
		public Keyword getCYPHERKeyword_1() { return cCYPHERKeyword_1; }
		
		//versionNumber=VersionNumber?
		public Assignment getVersionNumberAssignment_2() { return cVersionNumberAssignment_2; }
		
		//VersionNumber
		public RuleCall getVersionNumberVersionNumberParserRuleCall_2_0() { return cVersionNumberVersionNumberParserRuleCall_2_0; }
		
		//configurationOption+=ConfigurationOption*
		public Assignment getConfigurationOptionAssignment_3() { return cConfigurationOptionAssignment_3; }
		
		//ConfigurationOption
		public RuleCall getConfigurationOptionConfigurationOptionParserRuleCall_3_0() { return cConfigurationOptionConfigurationOptionParserRuleCall_3_0; }
	}
	public class VersionNumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.VersionNumber");
		private final Assignment cVersionNumberAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVersionNumberNumberParserRuleCall_0 = (RuleCall)cVersionNumberAssignment.eContents().get(0);
		
		//VersionNumber:
		//	versionNumber=Number;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * versionNumber : DecimalInteger '.' DecimalInteger ;
		// */ versionNumber=Number
		public Assignment getVersionNumberAssignment() { return cVersionNumberAssignment; }
		
		//Number
		public RuleCall getVersionNumberNumberParserRuleCall_0() { return cVersionNumberNumberParserRuleCall_0; }
	}
	public class ConfigurationOptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ConfigurationOption");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeySYMBOLIC_NAME_XParserRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueSYMBOLIC_NAME_XParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//ConfigurationOption:
		//	key=SYMBOLIC_NAME_X '=' value=SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * configurationOption : symbolicName ws '=' ws symbolicName ;
		// */ key=SYMBOLIC_NAME_X '=' value=SYMBOLIC_NAME_X
		public Group getGroup() { return cGroup; }
		
		///*
		// * configurationOption : symbolicName ws '=' ws symbolicName ;
		// */ key=SYMBOLIC_NAME_X
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getKeySYMBOLIC_NAME_XParserRuleCall_0_0() { return cKeySYMBOLIC_NAME_XParserRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//value=SYMBOLIC_NAME_X
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getValueSYMBOLIC_NAME_XParserRuleCall_2_0() { return cValueSYMBOLIC_NAME_XParserRuleCall_2_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommandParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQueryParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Statement:
		//	Command | Query;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * statement : command
		// *           | query;
		// */ Command | Query
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * statement : command
		// *           | query;
		// */ Command
		public RuleCall getCommandParserRuleCall_0() { return cCommandParserRuleCall_0; }
		
		//Query
		public RuleCall getQueryParserRuleCall_1() { return cQueryParserRuleCall_1; }
	}
	public class QueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Query");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRegularQueryParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStandaloneCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBulkImportQueryParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Query:
		//	RegularQuery | StandaloneCall | BulkImportQuery;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * query : regularQuery
		// *       | standaloneCall
		// *       | bulkImportQuery;
		// */ RegularQuery | StandaloneCall | BulkImportQuery
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * query : regularQuery
		// *       | standaloneCall
		// *       | bulkImportQuery;
		// */ RegularQuery
		public RuleCall getRegularQueryParserRuleCall_0() { return cRegularQueryParserRuleCall_0; }
		
		//StandaloneCall
		public RuleCall getStandaloneCallParserRuleCall_1() { return cStandaloneCallParserRuleCall_1; }
		
		//BulkImportQuery
		public RuleCall getBulkImportQueryParserRuleCall_2() { return cBulkImportQueryParserRuleCall_2; }
	}
	public class RegularQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RegularQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSingleQueryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCombinedQuerySingleQueryAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cUnionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUnionUnionParserRuleCall_1_1_0 = (RuleCall)cUnionAssignment_1_1.eContents().get(0);
		
		//RegularQuery:
		//	SingleQuery ({CombinedQuery.singleQuery=current} union+=Union+)?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * regularQuery : singleQuery ( ws union )* ;
		// */ SingleQuery ({CombinedQuery.singleQuery=current} union+=Union+)?
		public Group getGroup() { return cGroup; }
		
		///*
		// * regularQuery : singleQuery ( ws union )* ;
		// */ SingleQuery
		public RuleCall getSingleQueryParserRuleCall_0() { return cSingleQueryParserRuleCall_0; }
		
		//({CombinedQuery.singleQuery=current} union+=Union+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{CombinedQuery.singleQuery=current}
		public Action getCombinedQuerySingleQueryAction_1_0() { return cCombinedQuerySingleQueryAction_1_0; }
		
		//union+=Union+
		public Assignment getUnionAssignment_1_1() { return cUnionAssignment_1_1; }
		
		//Union
		public RuleCall getUnionUnionParserRuleCall_1_1_0() { return cUnionUnionParserRuleCall_1_1_0; }
	}
	public class BulkImportQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.BulkImportQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPeriodicCommitHintAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPeriodicCommitHintPeriodicCommitHintParserRuleCall_0_0 = (RuleCall)cPeriodicCommitHintAssignment_0.eContents().get(0);
		private final Assignment cLoadCSVQueryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLoadCSVQueryLoadCSVQueryParserRuleCall_1_0 = (RuleCall)cLoadCSVQueryAssignment_1.eContents().get(0);
		
		//BulkImportQuery:
		//	periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * bulkImportQuery : periodicCommitHint ws loadCSVQuery ;
		// */ periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery
		public Group getGroup() { return cGroup; }
		
		///*
		// * bulkImportQuery : periodicCommitHint ws loadCSVQuery ;
		// */ periodicCommitHint=PeriodicCommitHint
		public Assignment getPeriodicCommitHintAssignment_0() { return cPeriodicCommitHintAssignment_0; }
		
		//PeriodicCommitHint
		public RuleCall getPeriodicCommitHintPeriodicCommitHintParserRuleCall_0_0() { return cPeriodicCommitHintPeriodicCommitHintParserRuleCall_0_0; }
		
		//loadCSVQuery=LoadCSVQuery
		public Assignment getLoadCSVQueryAssignment_1() { return cLoadCSVQueryAssignment_1; }
		
		//LoadCSVQuery
		public RuleCall getLoadCSVQueryLoadCSVQueryParserRuleCall_1_0() { return cLoadCSVQueryLoadCSVQueryParserRuleCall_1_0; }
	}
	public class SingleQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.SingleQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cClausesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cClausesClauseParserRuleCall_0_0 = (RuleCall)cClausesAssignment_0.eContents().get(0);
		private final Assignment cClausesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cClausesClauseParserRuleCall_1_0 = (RuleCall)cClausesAssignment_1.eContents().get(0);
		
		//SingleQuery:
		//	clauses+=Clause clauses+=Clause*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * singleQuery : clause ( ws clause )* ;
		// */ clauses+=Clause clauses+=Clause*
		public Group getGroup() { return cGroup; }
		
		///*
		// * singleQuery : clause ( ws clause )* ;
		// */ clauses+=Clause
		public Assignment getClausesAssignment_0() { return cClausesAssignment_0; }
		
		//Clause
		public RuleCall getClausesClauseParserRuleCall_0_0() { return cClausesClauseParserRuleCall_0_0; }
		
		//clauses+=Clause*
		public Assignment getClausesAssignment_1() { return cClausesAssignment_1; }
		
		//Clause
		public RuleCall getClausesClauseParserRuleCall_1_0() { return cClausesClauseParserRuleCall_1_0; }
	}
	public class PeriodicCommitHintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PeriodicCommitHint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPeriodicCommitHintAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cUSINGKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPERIODICKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cCOMMITKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNumberOfRowsPerCommitAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNumberOfRowsPerCommitDecimalIntegerParserRuleCall_4_0 = (RuleCall)cNumberOfRowsPerCommitAssignment_4.eContents().get(0);
		
		//PeriodicCommitHint:
		//	{PeriodicCommitHint} 'USING' 'PERIODIC' 'COMMIT' numberOfRowsPerCommit=DecimalInteger?;
		@Override public ParserRule getRule() { return rule; }
		
		//{PeriodicCommitHint} 'USING' 'PERIODIC' 'COMMIT' numberOfRowsPerCommit=DecimalInteger?
		public Group getGroup() { return cGroup; }
		
		//{PeriodicCommitHint}
		public Action getPeriodicCommitHintAction_0() { return cPeriodicCommitHintAction_0; }
		
		//'USING'
		public Keyword getUSINGKeyword_1() { return cUSINGKeyword_1; }
		
		//'PERIODIC'
		public Keyword getPERIODICKeyword_2() { return cPERIODICKeyword_2; }
		
		//'COMMIT'
		public Keyword getCOMMITKeyword_3() { return cCOMMITKeyword_3; }
		
		//numberOfRowsPerCommit=DecimalInteger?
		public Assignment getNumberOfRowsPerCommitAssignment_4() { return cNumberOfRowsPerCommitAssignment_4; }
		
		//DecimalInteger
		public RuleCall getNumberOfRowsPerCommitDecimalIntegerParserRuleCall_4_0() { return cNumberOfRowsPerCommitDecimalIntegerParserRuleCall_4_0; }
	}
	public class LoadCSVQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.LoadCSVQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLoadCSVAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLoadCSVLoadCSVParserRuleCall_0_0 = (RuleCall)cLoadCSVAssignment_0.eContents().get(0);
		private final Assignment cClausesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cClausesClauseParserRuleCall_1_0 = (RuleCall)cClausesAssignment_1.eContents().get(0);
		
		//LoadCSVQuery:
		//	loadCSV=LoadCSV clauses+=Clause*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * loadCSVQuery : loadCSV ( ws clause )* ;
		// */ loadCSV=LoadCSV clauses+=Clause*
		public Group getGroup() { return cGroup; }
		
		///*
		// * loadCSVQuery : loadCSV ( ws clause )* ;
		// */ loadCSV=LoadCSV
		public Assignment getLoadCSVAssignment_0() { return cLoadCSVAssignment_0; }
		
		//LoadCSV
		public RuleCall getLoadCSVLoadCSVParserRuleCall_0_0() { return cLoadCSVLoadCSVParserRuleCall_0_0; }
		
		//clauses+=Clause*
		public Assignment getClausesAssignment_1() { return cClausesAssignment_1; }
		
		//Clause
		public RuleCall getClausesClauseParserRuleCall_1_0() { return cClausesClauseParserRuleCall_1_0; }
	}
	public class UnionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Union");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUNIONKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAllAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cAllALLKeyword_1_0 = (Keyword)cAllAssignment_1.eContents().get(0);
		private final Assignment cSingleQueryAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSingleQuerySingleQueryParserRuleCall_2_0 = (RuleCall)cSingleQueryAssignment_2.eContents().get(0);
		
		//Union:
		//	'UNION' all?='ALL'? singleQuery=SingleQuery;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * union : ( UNION sp ALL singleQuery )
		// *  | ( UNION singleQuery );
		// */ 'UNION' all?='ALL'? singleQuery=SingleQuery
		public Group getGroup() { return cGroup; }
		
		//'UNION'
		public Keyword getUNIONKeyword_0() { return cUNIONKeyword_0; }
		
		//all?='ALL'?
		public Assignment getAllAssignment_1() { return cAllAssignment_1; }
		
		//'ALL'
		public Keyword getAllALLKeyword_1_0() { return cAllALLKeyword_1_0; }
		
		//singleQuery=SingleQuery
		public Assignment getSingleQueryAssignment_2() { return cSingleQueryAssignment_2; }
		
		//SingleQuery
		public RuleCall getSingleQuerySingleQueryParserRuleCall_2_0() { return cSingleQuerySingleQueryParserRuleCall_2_0; }
	}
	public class ClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Clause");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLoadCSVParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStartParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMatchParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUnwindParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cMergeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cCreateParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cSetParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cDeleteParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cRemoveParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cForeachParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cWithParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cReturnParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cInQueryCallParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		//Clause:
		//	LoadCSV | Start | Match | Unwind | Merge | Create | Set | Delete | Remove | Foreach | With | Return | InQueryCall;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * clause : loadCSV
		// *        | start
		// *        | match
		// *        | unwind
		// *        | merge
		// *        | create
		// *        | createUnique
		// *        | set
		// *        | delete
		// *        | remove
		// *        | foreach
		// *        | with
		// *        | return
		// *        ;
		// * 
		// * Comment: We handle 'createUnique' within the 'create' clause
		// */ LoadCSV | Start | Match | Unwind | Merge | Create | Set | Delete | Remove | Foreach | With | Return | InQueryCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * clause : loadCSV
		// *        | start
		// *        | match
		// *        | unwind
		// *        | merge
		// *        | create
		// *        | createUnique
		// *        | set
		// *        | delete
		// *        | remove
		// *        | foreach
		// *        | with
		// *        | return
		// *        ;
		// * 
		// * Comment: We handle 'createUnique' within the 'create' clause
		// */ LoadCSV
		public RuleCall getLoadCSVParserRuleCall_0() { return cLoadCSVParserRuleCall_0; }
		
		//Start
		public RuleCall getStartParserRuleCall_1() { return cStartParserRuleCall_1; }
		
		//Match
		public RuleCall getMatchParserRuleCall_2() { return cMatchParserRuleCall_2; }
		
		//Unwind
		public RuleCall getUnwindParserRuleCall_3() { return cUnwindParserRuleCall_3; }
		
		//Merge
		public RuleCall getMergeParserRuleCall_4() { return cMergeParserRuleCall_4; }
		
		//Create
		public RuleCall getCreateParserRuleCall_5() { return cCreateParserRuleCall_5; }
		
		//Set
		public RuleCall getSetParserRuleCall_6() { return cSetParserRuleCall_6; }
		
		//Delete
		public RuleCall getDeleteParserRuleCall_7() { return cDeleteParserRuleCall_7; }
		
		//Remove
		public RuleCall getRemoveParserRuleCall_8() { return cRemoveParserRuleCall_8; }
		
		//Foreach
		public RuleCall getForeachParserRuleCall_9() { return cForeachParserRuleCall_9; }
		
		//With
		public RuleCall getWithParserRuleCall_10() { return cWithParserRuleCall_10; }
		
		//Return
		public RuleCall getReturnParserRuleCall_11() { return cReturnParserRuleCall_11; }
		
		//InQueryCall
		public RuleCall getInQueryCallParserRuleCall_12() { return cInQueryCallParserRuleCall_12; }
	}
	public class CommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Command");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCreateIndexParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDropIndexParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCreateUniqueConstraintParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDropUniqueConstraintParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCreateNodePropertyExistenceConstraintParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDropNodePropertyExistenceConstraintParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cCreateRelationshipPropertyExistenceConstraintParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cDropRelationshipPropertyExistenceConstraintParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//Command:
		//	CreateIndex | DropIndex | CreateUniqueConstraint | DropUniqueConstraint | CreateNodePropertyExistenceConstraint |
		//	DropNodePropertyExistenceConstraint | CreateRelationshipPropertyExistenceConstraint |
		//	DropRelationshipPropertyExistenceConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * command : createIndex
		// *         | dropIndex
		// *         | createUniqueConstraint
		// *         | dropUniqueConstraint
		// *         | createNodePropertyExistenceConstraint
		// *         | dropNodePropertyExistenceConstraint
		// *         | createRelationshipPropertyExistenceConstraint
		// *         | dropRelationshipPropertyExistenceConstraint
		// *         ;
		// */ CreateIndex | DropIndex | CreateUniqueConstraint | DropUniqueConstraint | CreateNodePropertyExistenceConstraint |
		//DropNodePropertyExistenceConstraint | CreateRelationshipPropertyExistenceConstraint |
		//DropRelationshipPropertyExistenceConstraint
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * command : createIndex
		// *         | dropIndex
		// *         | createUniqueConstraint
		// *         | dropUniqueConstraint
		// *         | createNodePropertyExistenceConstraint
		// *         | dropNodePropertyExistenceConstraint
		// *         | createRelationshipPropertyExistenceConstraint
		// *         | dropRelationshipPropertyExistenceConstraint
		// *         ;
		// */ CreateIndex
		public RuleCall getCreateIndexParserRuleCall_0() { return cCreateIndexParserRuleCall_0; }
		
		//DropIndex
		public RuleCall getDropIndexParserRuleCall_1() { return cDropIndexParserRuleCall_1; }
		
		//CreateUniqueConstraint
		public RuleCall getCreateUniqueConstraintParserRuleCall_2() { return cCreateUniqueConstraintParserRuleCall_2; }
		
		//DropUniqueConstraint
		public RuleCall getDropUniqueConstraintParserRuleCall_3() { return cDropUniqueConstraintParserRuleCall_3; }
		
		//CreateNodePropertyExistenceConstraint
		public RuleCall getCreateNodePropertyExistenceConstraintParserRuleCall_4() { return cCreateNodePropertyExistenceConstraintParserRuleCall_4; }
		
		//DropNodePropertyExistenceConstraint
		public RuleCall getDropNodePropertyExistenceConstraintParserRuleCall_5() { return cDropNodePropertyExistenceConstraintParserRuleCall_5; }
		
		//CreateRelationshipPropertyExistenceConstraint
		public RuleCall getCreateRelationshipPropertyExistenceConstraintParserRuleCall_6() { return cCreateRelationshipPropertyExistenceConstraintParserRuleCall_6; }
		
		//DropRelationshipPropertyExistenceConstraint
		public RuleCall getDropRelationshipPropertyExistenceConstraintParserRuleCall_7() { return cDropRelationshipPropertyExistenceConstraintParserRuleCall_7; }
	}
	public class CreateUniqueConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.CreateUniqueConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCREATEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cUniqueConstraintParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//CreateUniqueConstraint: /*
		// * createUniqueConstraint : CREATE sp uniqueConstraint ;
		// */ 'CREATE' UniqueConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * createUniqueConstraint : CREATE sp uniqueConstraint ;
		// */ 'CREATE' UniqueConstraint
		public Group getGroup() { return cGroup; }
		
		///*
		// * createUniqueConstraint : CREATE sp uniqueConstraint ;
		// */ 'CREATE'
		public Keyword getCREATEKeyword_0() { return cCREATEKeyword_0; }
		
		//UniqueConstraint
		public RuleCall getUniqueConstraintParserRuleCall_1() { return cUniqueConstraintParserRuleCall_1; }
	}
	public class CreateNodePropertyExistenceConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.CreateNodePropertyExistenceConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCREATEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cNodePropertyExistenceConstraintParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//CreateNodePropertyExistenceConstraint: /*
		// * createNodePropertyExistenceConstraint : CREATE sp nodePropertyExistenceConstraint ;
		// */ 'CREATE' NodePropertyExistenceConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * createNodePropertyExistenceConstraint : CREATE sp nodePropertyExistenceConstraint ;
		// */ 'CREATE' NodePropertyExistenceConstraint
		public Group getGroup() { return cGroup; }
		
		///*
		// * createNodePropertyExistenceConstraint : CREATE sp nodePropertyExistenceConstraint ;
		// */ 'CREATE'
		public Keyword getCREATEKeyword_0() { return cCREATEKeyword_0; }
		
		//NodePropertyExistenceConstraint
		public RuleCall getNodePropertyExistenceConstraintParserRuleCall_1() { return cNodePropertyExistenceConstraintParserRuleCall_1; }
	}
	public class CreateRelationshipPropertyExistenceConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.CreateRelationshipPropertyExistenceConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCREATEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cRelationshipPropertyExistenceConstraintParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//CreateRelationshipPropertyExistenceConstraint: /*
		// * createRelationshipPropertyExistenceConstraint : CREATE sp relationshipPropertyExistenceConstraint ;
		// */ 'CREATE' RelationshipPropertyExistenceConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * createRelationshipPropertyExistenceConstraint : CREATE sp relationshipPropertyExistenceConstraint ;
		// */ 'CREATE' RelationshipPropertyExistenceConstraint
		public Group getGroup() { return cGroup; }
		
		///*
		// * createRelationshipPropertyExistenceConstraint : CREATE sp relationshipPropertyExistenceConstraint ;
		// */ 'CREATE'
		public Keyword getCREATEKeyword_0() { return cCREATEKeyword_0; }
		
		//RelationshipPropertyExistenceConstraint
		public RuleCall getRelationshipPropertyExistenceConstraintParserRuleCall_1() { return cRelationshipPropertyExistenceConstraintParserRuleCall_1; }
	}
	public class CreateIndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.CreateIndex");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCREATEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexIndexParserRuleCall_1_0 = (RuleCall)cIndexAssignment_1.eContents().get(0);
		
		//CreateIndex: /*
		// * createIndex : CREATE sp index ;
		// */ 'CREATE' index=Index;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * createIndex : CREATE sp index ;
		// */ 'CREATE' index=Index
		public Group getGroup() { return cGroup; }
		
		///*
		// * createIndex : CREATE sp index ;
		// */ 'CREATE'
		public Keyword getCREATEKeyword_0() { return cCREATEKeyword_0; }
		
		//index=Index
		public Assignment getIndexAssignment_1() { return cIndexAssignment_1; }
		
		//Index
		public RuleCall getIndexIndexParserRuleCall_1_0() { return cIndexIndexParserRuleCall_1_0; }
	}
	public class DropUniqueConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.DropUniqueConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDROPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cUniqueConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUniqueConstraintUniqueConstraintParserRuleCall_1_0 = (RuleCall)cUniqueConstraintAssignment_1.eContents().get(0);
		
		//DropUniqueConstraint: /*
		// * dropUniqueConstraint : DROP sp uniqueConstraint ;
		// */ 'DROP' uniqueConstraint=UniqueConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * dropUniqueConstraint : DROP sp uniqueConstraint ;
		// */ 'DROP' uniqueConstraint=UniqueConstraint
		public Group getGroup() { return cGroup; }
		
		///*
		// * dropUniqueConstraint : DROP sp uniqueConstraint ;
		// */ 'DROP'
		public Keyword getDROPKeyword_0() { return cDROPKeyword_0; }
		
		//uniqueConstraint=UniqueConstraint
		public Assignment getUniqueConstraintAssignment_1() { return cUniqueConstraintAssignment_1; }
		
		//UniqueConstraint
		public RuleCall getUniqueConstraintUniqueConstraintParserRuleCall_1_0() { return cUniqueConstraintUniqueConstraintParserRuleCall_1_0; }
	}
	public class DropNodePropertyExistenceConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.DropNodePropertyExistenceConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDROPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNodePropertyExistenceConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNodePropertyExistenceConstraintNodePropertyExistenceConstraintParserRuleCall_1_0 = (RuleCall)cNodePropertyExistenceConstraintAssignment_1.eContents().get(0);
		
		//DropNodePropertyExistenceConstraint: /*
		// * dropNodePropertyExistenceConstraint : DROP sp nodePropertyExistenceConstraint ;
		// */ 'DROP' nodePropertyExistenceConstraint=NodePropertyExistenceConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * dropNodePropertyExistenceConstraint : DROP sp nodePropertyExistenceConstraint ;
		// */ 'DROP' nodePropertyExistenceConstraint=NodePropertyExistenceConstraint
		public Group getGroup() { return cGroup; }
		
		///*
		// * dropNodePropertyExistenceConstraint : DROP sp nodePropertyExistenceConstraint ;
		// */ 'DROP'
		public Keyword getDROPKeyword_0() { return cDROPKeyword_0; }
		
		//nodePropertyExistenceConstraint=NodePropertyExistenceConstraint
		public Assignment getNodePropertyExistenceConstraintAssignment_1() { return cNodePropertyExistenceConstraintAssignment_1; }
		
		//NodePropertyExistenceConstraint
		public RuleCall getNodePropertyExistenceConstraintNodePropertyExistenceConstraintParserRuleCall_1_0() { return cNodePropertyExistenceConstraintNodePropertyExistenceConstraintParserRuleCall_1_0; }
	}
	public class DropRelationshipPropertyExistenceConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.DropRelationshipPropertyExistenceConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDROPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRelationshipPropertyExistenceConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationshipPropertyExistenceConstraintRelationshipPropertyExistenceConstraintParserRuleCall_1_0 = (RuleCall)cRelationshipPropertyExistenceConstraintAssignment_1.eContents().get(0);
		
		//DropRelationshipPropertyExistenceConstraint: /*
		// * dropRelationshipPropertyExistenceConstraint : DROP sp relationshipPropertyExistenceConstraint ;
		// */ 'DROP' relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * dropRelationshipPropertyExistenceConstraint : DROP sp relationshipPropertyExistenceConstraint ;
		// */ 'DROP' relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint
		public Group getGroup() { return cGroup; }
		
		///*
		// * dropRelationshipPropertyExistenceConstraint : DROP sp relationshipPropertyExistenceConstraint ;
		// */ 'DROP'
		public Keyword getDROPKeyword_0() { return cDROPKeyword_0; }
		
		//relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint
		public Assignment getRelationshipPropertyExistenceConstraintAssignment_1() { return cRelationshipPropertyExistenceConstraintAssignment_1; }
		
		//RelationshipPropertyExistenceConstraint
		public RuleCall getRelationshipPropertyExistenceConstraintRelationshipPropertyExistenceConstraintParserRuleCall_1_0() { return cRelationshipPropertyExistenceConstraintRelationshipPropertyExistenceConstraintParserRuleCall_1_0; }
	}
	public class DropIndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.DropIndex");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDROPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexIndexParserRuleCall_1_0 = (RuleCall)cIndexAssignment_1.eContents().get(0);
		
		//DropIndex: /*
		// * dropIndex : DROP sp index ;
		// */ 'DROP' index=Index;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * dropIndex : DROP sp index ;
		// */ 'DROP' index=Index
		public Group getGroup() { return cGroup; }
		
		///*
		// * dropIndex : DROP sp index ;
		// */ 'DROP'
		public Keyword getDROPKeyword_0() { return cDROPKeyword_0; }
		
		//index=Index
		public Assignment getIndexAssignment_1() { return cIndexAssignment_1; }
		
		//Index
		public RuleCall getIndexIndexParserRuleCall_1_0() { return cIndexIndexParserRuleCall_1_0; }
	}
	public class IndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Index");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cINDEXKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cONKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNodeLabelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNodeLabelNodeLabelParserRuleCall_2_0 = (RuleCall)cNodeLabelAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPropertyKeyNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPropertyKeyNamePropertyKeyNameParserRuleCall_4_0 = (RuleCall)cPropertyKeyNameAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Index: /*
		// * index : INDEX sp ON ws nodeLabel '(' propertyKeyName ')' ;
		// */ 'INDEX' 'ON' nodeLabel=NodeLabel '(' propertyKeyName=PropertyKeyName ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * index : INDEX sp ON ws nodeLabel '(' propertyKeyName ')' ;
		// */ 'INDEX' 'ON' nodeLabel=NodeLabel '(' propertyKeyName=PropertyKeyName ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * index : INDEX sp ON ws nodeLabel '(' propertyKeyName ')' ;
		// */ 'INDEX'
		public Keyword getINDEXKeyword_0() { return cINDEXKeyword_0; }
		
		//'ON'
		public Keyword getONKeyword_1() { return cONKeyword_1; }
		
		//nodeLabel=NodeLabel
		public Assignment getNodeLabelAssignment_2() { return cNodeLabelAssignment_2; }
		
		//NodeLabel
		public RuleCall getNodeLabelNodeLabelParserRuleCall_2_0() { return cNodeLabelNodeLabelParserRuleCall_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }
		
		//propertyKeyName=PropertyKeyName
		public Assignment getPropertyKeyNameAssignment_4() { return cPropertyKeyNameAssignment_4; }
		
		//PropertyKeyName
		public RuleCall getPropertyKeyNamePropertyKeyNameParserRuleCall_4_0() { return cPropertyKeyNamePropertyKeyNameParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class UniqueConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.UniqueConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCONSTRAINTKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cONKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVariableAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_3_0 = (RuleCall)cVariableAssignment_3.eContents().get(0);
		private final Assignment cNodeLabelAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNodeLabelNodeLabelParserRuleCall_4_0 = (RuleCall)cNodeLabelAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cASSERTKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cPropertyExpressionAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cPropertyExpressionPropertyExpressionParserRuleCall_7_0 = (RuleCall)cPropertyExpressionAssignment_7.eContents().get(0);
		private final Keyword cISKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cUNIQUEKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//UniqueConstraint: /*
		// * uniqueConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp propertyExpression sp IS sp UNIQUE ;
		// */ 'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT'
		//	propertyExpression=PropertyExpression 'IS' 'UNIQUE';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * uniqueConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp propertyExpression sp IS sp UNIQUE ;
		// */ 'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT'
		//propertyExpression=PropertyExpression 'IS' 'UNIQUE'
		public Group getGroup() { return cGroup; }
		
		///*
		// * uniqueConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp propertyExpression sp IS sp UNIQUE ;
		// */ 'CONSTRAINT'
		public Keyword getCONSTRAINTKeyword_0() { return cCONSTRAINTKeyword_0; }
		
		//'ON'
		public Keyword getONKeyword_1() { return cONKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_3() { return cVariableAssignment_3; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_3_0() { return cVariableVariableDeclarationParserRuleCall_3_0; }
		
		//nodeLabel=NodeLabel
		public Assignment getNodeLabelAssignment_4() { return cNodeLabelAssignment_4; }
		
		//NodeLabel
		public RuleCall getNodeLabelNodeLabelParserRuleCall_4_0() { return cNodeLabelNodeLabelParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//'ASSERT'
		public Keyword getASSERTKeyword_6() { return cASSERTKeyword_6; }
		
		//propertyExpression=PropertyExpression
		public Assignment getPropertyExpressionAssignment_7() { return cPropertyExpressionAssignment_7; }
		
		//PropertyExpression
		public RuleCall getPropertyExpressionPropertyExpressionParserRuleCall_7_0() { return cPropertyExpressionPropertyExpressionParserRuleCall_7_0; }
		
		//'IS'
		public Keyword getISKeyword_8() { return cISKeyword_8; }
		
		//'UNIQUE'
		public Keyword getUNIQUEKeyword_9() { return cUNIQUEKeyword_9; }
	}
	public class NodePropertyExistenceConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.NodePropertyExistenceConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCONSTRAINTKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cONKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVariableAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_3_0 = (RuleCall)cVariableAssignment_3.eContents().get(0);
		private final Assignment cNodeLabelAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNodeLabelNodeLabelParserRuleCall_4_0 = (RuleCall)cNodeLabelAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cASSERTKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cEXISTSKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cLeftParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cPropertyExpressionAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cPropertyExpressionPropertyExpressionParserRuleCall_9_0 = (RuleCall)cPropertyExpressionAssignment_9.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//NodePropertyExistenceConstraint: /*
		// * nodePropertyExistenceConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
		// */ 'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT' 'EXISTS' '('
		//	propertyExpression=PropertyExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * nodePropertyExistenceConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
		// */ 'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT' 'EXISTS' '('
		//propertyExpression=PropertyExpression ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * nodePropertyExistenceConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
		// */ 'CONSTRAINT'
		public Keyword getCONSTRAINTKeyword_0() { return cCONSTRAINTKeyword_0; }
		
		//'ON'
		public Keyword getONKeyword_1() { return cONKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_3() { return cVariableAssignment_3; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_3_0() { return cVariableVariableDeclarationParserRuleCall_3_0; }
		
		//nodeLabel=NodeLabel
		public Assignment getNodeLabelAssignment_4() { return cNodeLabelAssignment_4; }
		
		//NodeLabel
		public RuleCall getNodeLabelNodeLabelParserRuleCall_4_0() { return cNodeLabelNodeLabelParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//'ASSERT'
		public Keyword getASSERTKeyword_6() { return cASSERTKeyword_6; }
		
		//'EXISTS'
		public Keyword getEXISTSKeyword_7() { return cEXISTSKeyword_7; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_8() { return cLeftParenthesisKeyword_8; }
		
		//propertyExpression=PropertyExpression
		public Assignment getPropertyExpressionAssignment_9() { return cPropertyExpressionAssignment_9; }
		
		//PropertyExpression
		public RuleCall getPropertyExpressionPropertyExpressionParserRuleCall_9_0() { return cPropertyExpressionPropertyExpressionParserRuleCall_9_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_10() { return cRightParenthesisKeyword_10; }
	}
	public class RelationshipPropertyExistenceConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelationshipPropertyExistenceConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCONSTRAINTKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cONKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRelationshipPatternAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationshipPatternRelationshipPatternSyntaxParserRuleCall_2_0 = (RuleCall)cRelationshipPatternAssignment_2.eContents().get(0);
		private final Keyword cASSERTKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cEXISTSKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cPropertyExpressionAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPropertyExpressionPropertyExpressionParserRuleCall_6_0 = (RuleCall)cPropertyExpressionAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//RelationshipPropertyExistenceConstraint: /*
		// * relationshipPropertyExistenceConstraint : CONSTRAINT sp ON ws relationshipPatternSyntax ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
		// */ 'CONSTRAINT' 'ON' relationshipPattern=RelationshipPatternSyntax 'ASSERT' 'EXISTS' '('
		//	propertyExpression=PropertyExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * relationshipPropertyExistenceConstraint : CONSTRAINT sp ON ws relationshipPatternSyntax ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
		// */ 'CONSTRAINT' 'ON' relationshipPattern=RelationshipPatternSyntax 'ASSERT' 'EXISTS' '('
		//propertyExpression=PropertyExpression ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * relationshipPropertyExistenceConstraint : CONSTRAINT sp ON ws relationshipPatternSyntax ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
		// */ 'CONSTRAINT'
		public Keyword getCONSTRAINTKeyword_0() { return cCONSTRAINTKeyword_0; }
		
		//'ON'
		public Keyword getONKeyword_1() { return cONKeyword_1; }
		
		//relationshipPattern=RelationshipPatternSyntax
		public Assignment getRelationshipPatternAssignment_2() { return cRelationshipPatternAssignment_2; }
		
		//RelationshipPatternSyntax
		public RuleCall getRelationshipPatternRelationshipPatternSyntaxParserRuleCall_2_0() { return cRelationshipPatternRelationshipPatternSyntaxParserRuleCall_2_0; }
		
		//'ASSERT'
		public Keyword getASSERTKeyword_3() { return cASSERTKeyword_3; }
		
		//'EXISTS'
		public Keyword getEXISTSKeyword_4() { return cEXISTSKeyword_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_5() { return cLeftParenthesisKeyword_5; }
		
		//propertyExpression=PropertyExpression
		public Assignment getPropertyExpressionAssignment_6() { return cPropertyExpressionAssignment_6; }
		
		//PropertyExpression
		public RuleCall getPropertyExpressionPropertyExpressionParserRuleCall_6_0() { return cPropertyExpressionPropertyExpressionParserRuleCall_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class RelationshipPatternSyntaxElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelationshipPatternSyntax");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIncomingAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIncomingLeftArrowHeadParserRuleCall_2_0 = (RuleCall)cIncomingAssignment_2.eContents().get(0);
		private final RuleCall cDashParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Keyword cLeftSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cVariableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_5_0 = (RuleCall)cVariableAssignment_5.eContents().get(0);
		private final Assignment cRelTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRelTypeRelTypeParserRuleCall_6_0 = (RuleCall)cRelTypeAssignment_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final RuleCall cDashParserRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		private final Assignment cOutgoingAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cOutgoingRightArrowHeadParserRuleCall_9_0 = (RuleCall)cOutgoingAssignment_9.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cRightParenthesisKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		//RelationshipPatternSyntax:
		//	'(' ')' incoming?=LeftArrowHead? Dash '[' variable=VariableDeclaration relType=RelType ']' Dash
		//	outgoing?=RightArrowHead? '('
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * relationshipPatternSyntax : ( '(' ws ')' dash '[' variable relType ']' dash '(' ws ')' )
		// *                           | ( '(' ws ')' dash '[' variable relType ']' rightArrowHead dash '(' ws ')' )
		// *                           | ( '(' ws ')' leftArrowHead dash '[' variable relType ']' dash '(' ws ')' );
		// */ '(' ')' incoming?=LeftArrowHead? Dash '[' variable=VariableDeclaration relType=RelType ']' Dash
		//outgoing?=RightArrowHead? '(' ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1() { return cRightParenthesisKeyword_1; }
		
		//incoming?=LeftArrowHead?
		public Assignment getIncomingAssignment_2() { return cIncomingAssignment_2; }
		
		//LeftArrowHead
		public RuleCall getIncomingLeftArrowHeadParserRuleCall_2_0() { return cIncomingLeftArrowHeadParserRuleCall_2_0; }
		
		//Dash
		public RuleCall getDashParserRuleCall_3() { return cDashParserRuleCall_3; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_4() { return cLeftSquareBracketKeyword_4; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_5() { return cVariableAssignment_5; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_5_0() { return cVariableVariableDeclarationParserRuleCall_5_0; }
		
		//relType=RelType
		public Assignment getRelTypeAssignment_6() { return cRelTypeAssignment_6; }
		
		//RelType
		public RuleCall getRelTypeRelTypeParserRuleCall_6_0() { return cRelTypeRelTypeParserRuleCall_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7() { return cRightSquareBracketKeyword_7; }
		
		//Dash
		public RuleCall getDashParserRuleCall_8() { return cDashParserRuleCall_8; }
		
		//outgoing?=RightArrowHead?
		public Assignment getOutgoingAssignment_9() { return cOutgoingAssignment_9; }
		
		//RightArrowHead
		public RuleCall getOutgoingRightArrowHeadParserRuleCall_9_0() { return cOutgoingRightArrowHeadParserRuleCall_9_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_10() { return cLeftParenthesisKeyword_10; }
		
		//')'
		public Keyword getRightParenthesisKeyword_11() { return cRightParenthesisKeyword_11; }
	}
	public class LoadCSVElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.LoadCSV");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLoadCSVAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLOADKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cCSVKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cWithHeadersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWithHeadersLoadCSVWithHeadersParserRuleCall_3_0 = (RuleCall)cWithHeadersAssignment_3.eContents().get(0);
		private final Keyword cFROMKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpressionExpressionParserRuleCall_5_0 = (RuleCall)cExpressionAssignment_5.eContents().get(0);
		private final Keyword cASKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cVariableAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_7_0 = (RuleCall)cVariableAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cFIELDTERMINATORKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cFieldterminatorAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cFieldterminatorSTRING_LITERALTerminalRuleCall_8_1_0 = (RuleCall)cFieldterminatorAssignment_8_1.eContents().get(0);
		
		//LoadCSV:
		//	{LoadCSV} 'LOAD' 'CSV' withHeaders?=LoadCSVWithHeaders? 'FROM' expression=Expression 'AS' variable=VariableDeclaration
		//	('FIELDTERMINATOR' fieldterminator=STRING_LITERAL)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{LoadCSV} 'LOAD' 'CSV' withHeaders?=LoadCSVWithHeaders? 'FROM' expression=Expression 'AS' variable=VariableDeclaration
		//('FIELDTERMINATOR' fieldterminator=STRING_LITERAL)?
		public Group getGroup() { return cGroup; }
		
		//{LoadCSV}
		public Action getLoadCSVAction_0() { return cLoadCSVAction_0; }
		
		//'LOAD'
		public Keyword getLOADKeyword_1() { return cLOADKeyword_1; }
		
		//'CSV'
		public Keyword getCSVKeyword_2() { return cCSVKeyword_2; }
		
		//withHeaders?=LoadCSVWithHeaders?
		public Assignment getWithHeadersAssignment_3() { return cWithHeadersAssignment_3; }
		
		//LoadCSVWithHeaders
		public RuleCall getWithHeadersLoadCSVWithHeadersParserRuleCall_3_0() { return cWithHeadersLoadCSVWithHeadersParserRuleCall_3_0; }
		
		//'FROM'
		public Keyword getFROMKeyword_4() { return cFROMKeyword_4; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_5() { return cExpressionAssignment_5; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_5_0() { return cExpressionExpressionParserRuleCall_5_0; }
		
		//'AS'
		public Keyword getASKeyword_6() { return cASKeyword_6; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_7() { return cVariableAssignment_7; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_7_0() { return cVariableVariableDeclarationParserRuleCall_7_0; }
		
		//('FIELDTERMINATOR' fieldterminator=STRING_LITERAL)?
		public Group getGroup_8() { return cGroup_8; }
		
		//'FIELDTERMINATOR'
		public Keyword getFIELDTERMINATORKeyword_8_0() { return cFIELDTERMINATORKeyword_8_0; }
		
		//fieldterminator=STRING_LITERAL
		public Assignment getFieldterminatorAssignment_8_1() { return cFieldterminatorAssignment_8_1; }
		
		//STRING_LITERAL
		public RuleCall getFieldterminatorSTRING_LITERALTerminalRuleCall_8_1_0() { return cFieldterminatorSTRING_LITERALTerminalRuleCall_8_1_0; }
	}
	public class LoadCSVWithHeadersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.LoadCSVWithHeaders");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWITHKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cHEADERSKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//LoadCSVWithHeaders:
		//	'WITH' 'HEADERS';
		@Override public ParserRule getRule() { return rule; }
		
		//'WITH' 'HEADERS'
		public Group getGroup() { return cGroup; }
		
		//'WITH'
		public Keyword getWITHKeyword_0() { return cWITHKeyword_0; }
		
		//'HEADERS'
		public Keyword getHEADERSKeyword_1() { return cHEADERSKeyword_1; }
	}
	public class MatchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Match");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOptionalAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOptionalOPTIONALKeyword_0_0 = (Keyword)cOptionalAssignment_0.eContents().get(0);
		private final Keyword cMATCHKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPatternAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternPatternParserRuleCall_2_0 = (RuleCall)cPatternAssignment_2.eContents().get(0);
		private final Assignment cHintsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cHintsHintParserRuleCall_3_0 = (RuleCall)cHintsAssignment_3.eContents().get(0);
		private final Assignment cWhereAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cWhereWhereParserRuleCall_4_0 = (RuleCall)cWhereAssignment_4.eContents().get(0);
		
		//Match:
		//	optional?='OPTIONAL'? 'MATCH' pattern=Pattern hints+=Hint* where=Where?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * match : ( OPTIONAL sp )? MATCH ws pattern ( hint )* ( ws where )? ;
		// */ optional?='OPTIONAL'? 'MATCH' pattern=Pattern hints+=Hint* where=Where?
		public Group getGroup() { return cGroup; }
		
		///*
		// * match : ( OPTIONAL sp )? MATCH ws pattern ( hint )* ( ws where )? ;
		// */ optional?='OPTIONAL'?
		public Assignment getOptionalAssignment_0() { return cOptionalAssignment_0; }
		
		//'OPTIONAL'
		public Keyword getOptionalOPTIONALKeyword_0_0() { return cOptionalOPTIONALKeyword_0_0; }
		
		//'MATCH'
		public Keyword getMATCHKeyword_1() { return cMATCHKeyword_1; }
		
		//pattern=Pattern
		public Assignment getPatternAssignment_2() { return cPatternAssignment_2; }
		
		//Pattern
		public RuleCall getPatternPatternParserRuleCall_2_0() { return cPatternPatternParserRuleCall_2_0; }
		
		//hints+=Hint*
		public Assignment getHintsAssignment_3() { return cHintsAssignment_3; }
		
		//Hint
		public RuleCall getHintsHintParserRuleCall_3_0() { return cHintsHintParserRuleCall_3_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_4() { return cWhereAssignment_4; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_4_0() { return cWhereWhereParserRuleCall_4_0; }
	}
	public class UnwindElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Unwind");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUNWINDKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cASKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVariableAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_3_0 = (RuleCall)cVariableAssignment_3.eContents().get(0);
		
		//Unwind: /*
		// * unwind : UNWIND ws expression sp AS sp variable ;
		// */ 'UNWIND' expression=Expression 'AS' variable=VariableDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * unwind : UNWIND ws expression sp AS sp variable ;
		// */ 'UNWIND' expression=Expression 'AS' variable=VariableDeclaration
		public Group getGroup() { return cGroup; }
		
		///*
		// * unwind : UNWIND ws expression sp AS sp variable ;
		// */ 'UNWIND'
		public Keyword getUNWINDKeyword_0() { return cUNWINDKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//'AS'
		public Keyword getASKeyword_2() { return cASKeyword_2; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_3() { return cVariableAssignment_3; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_3_0() { return cVariableVariableDeclarationParserRuleCall_3_0; }
	}
	public class MergeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Merge");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMERGEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPatternPartAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPatternPartPatternPartParserRuleCall_1_0 = (RuleCall)cPatternPartAssignment_1.eContents().get(0);
		private final Assignment cMergeActionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMergeActionsMergeActionParserRuleCall_2_0 = (RuleCall)cMergeActionsAssignment_2.eContents().get(0);
		
		//Merge: /*
		// * merge : MERGE ws patternPart ( sp mergeAction )* ;
		// */ 'MERGE' patternPart=PatternPart mergeActions+=MergeAction*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * merge : MERGE ws patternPart ( sp mergeAction )* ;
		// */ 'MERGE' patternPart=PatternPart mergeActions+=MergeAction*
		public Group getGroup() { return cGroup; }
		
		///*
		// * merge : MERGE ws patternPart ( sp mergeAction )* ;
		// */ 'MERGE'
		public Keyword getMERGEKeyword_0() { return cMERGEKeyword_0; }
		
		//patternPart=PatternPart
		public Assignment getPatternPartAssignment_1() { return cPatternPartAssignment_1; }
		
		//PatternPart
		public RuleCall getPatternPartPatternPartParserRuleCall_1_0() { return cPatternPartPatternPartParserRuleCall_1_0; }
		
		//mergeActions+=MergeAction*
		public Assignment getMergeActionsAssignment_2() { return cMergeActionsAssignment_2; }
		
		//MergeAction
		public RuleCall getMergeActionsMergeActionParserRuleCall_2_0() { return cMergeActionsMergeActionParserRuleCall_2_0; }
	}
	public class MergeActionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.MergeAction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cONKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cActionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cActionAlternatives_1_0 = (Alternatives)cActionAssignment_1.eContents().get(0);
		private final Keyword cActionMATCHKeyword_1_0_0 = (Keyword)cActionAlternatives_1_0.eContents().get(0);
		private final Keyword cActionCREATEKeyword_1_0_1 = (Keyword)cActionAlternatives_1_0.eContents().get(1);
		private final Assignment cSetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSetSetParserRuleCall_2_0 = (RuleCall)cSetAssignment_2.eContents().get(0);
		
		//MergeAction: /*
		// * mergeAction : ( ON sp MATCH sp set )
		// *             | ( ON sp CREATE sp set )
		// *             ;
		// */ 'ON' action=('MATCH' | 'CREATE') set=Set;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * mergeAction : ( ON sp MATCH sp set )
		// *             | ( ON sp CREATE sp set )
		// *             ;
		// */ 'ON' action=('MATCH' | 'CREATE') set=Set
		public Group getGroup() { return cGroup; }
		
		///*
		// * mergeAction : ( ON sp MATCH sp set )
		// *             | ( ON sp CREATE sp set )
		// *             ;
		// */ 'ON'
		public Keyword getONKeyword_0() { return cONKeyword_0; }
		
		//action=('MATCH' | 'CREATE')
		public Assignment getActionAssignment_1() { return cActionAssignment_1; }
		
		//('MATCH' | 'CREATE')
		public Alternatives getActionAlternatives_1_0() { return cActionAlternatives_1_0; }
		
		//'MATCH'
		public Keyword getActionMATCHKeyword_1_0_0() { return cActionMATCHKeyword_1_0_0; }
		
		//'CREATE'
		public Keyword getActionCREATEKeyword_1_0_1() { return cActionCREATEKeyword_1_0_1; }
		
		//set=Set
		public Assignment getSetAssignment_2() { return cSetAssignment_2; }
		
		//Set
		public RuleCall getSetSetParserRuleCall_2_0() { return cSetSetParserRuleCall_2_0; }
	}
	public class CreateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Create");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCREATEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cUniqueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cUniqueUNIQUEKeyword_1_0 = (Keyword)cUniqueAssignment_1.eContents().get(0);
		private final Assignment cPatternAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternPatternParserRuleCall_2_0 = (RuleCall)cPatternAssignment_2.eContents().get(0);
		
		//Create: /*
		// * create : CREATE ws pattern ;
		// * createUnique : CREATE sp UNIQUE ws pattern ;
		// * 
		// * Comment: We handle 'create' and 'createUnqiue' in the same clause
		// */ 'CREATE' unique?='UNIQUE'? pattern=Pattern;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * create : CREATE ws pattern ;
		// * createUnique : CREATE sp UNIQUE ws pattern ;
		// * 
		// * Comment: We handle 'create' and 'createUnqiue' in the same clause
		// */ 'CREATE' unique?='UNIQUE'? pattern=Pattern
		public Group getGroup() { return cGroup; }
		
		///*
		// * create : CREATE ws pattern ;
		// * createUnique : CREATE sp UNIQUE ws pattern ;
		// * 
		// * Comment: We handle 'create' and 'createUnqiue' in the same clause
		// */ 'CREATE'
		public Keyword getCREATEKeyword_0() { return cCREATEKeyword_0; }
		
		//unique?='UNIQUE'?
		public Assignment getUniqueAssignment_1() { return cUniqueAssignment_1; }
		
		//'UNIQUE'
		public Keyword getUniqueUNIQUEKeyword_1_0() { return cUniqueUNIQUEKeyword_1_0; }
		
		//pattern=Pattern
		public Assignment getPatternAssignment_2() { return cPatternAssignment_2; }
		
		//Pattern
		public RuleCall getPatternPatternParserRuleCall_2_0() { return cPatternPatternParserRuleCall_2_0; }
	}
	public class SetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Set");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSETKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSetItemsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSetItemsSetItemParserRuleCall_1_0 = (RuleCall)cSetItemsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSetItemsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSetItemsSetItemParserRuleCall_2_1_0 = (RuleCall)cSetItemsAssignment_2_1.eContents().get(0);
		
		//Set: /*
		// * set : SET setItem ( ',' setItem )* ;
		// */ 'SET' setItems+=SetItem (',' setItems+=SetItem)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * set : SET setItem ( ',' setItem )* ;
		// */ 'SET' setItems+=SetItem (',' setItems+=SetItem)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * set : SET setItem ( ',' setItem )* ;
		// */ 'SET'
		public Keyword getSETKeyword_0() { return cSETKeyword_0; }
		
		//setItems+=SetItem
		public Assignment getSetItemsAssignment_1() { return cSetItemsAssignment_1; }
		
		//SetItem
		public RuleCall getSetItemsSetItemParserRuleCall_1_0() { return cSetItemsSetItemParserRuleCall_1_0; }
		
		//(',' setItems+=SetItem)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//setItems+=SetItem
		public Assignment getSetItemsAssignment_2_1() { return cSetItemsAssignment_2_1; }
		
		//SetItem
		public RuleCall getSetItemsSetItemParserRuleCall_2_1_0() { return cSetItemsSetItemParserRuleCall_2_1_0; }
	}
	public class SetItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.SetItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cPropertyExpressionAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cPropertyExpressionPropertyExpressionParserRuleCall_0_0_0 = (RuleCall)cPropertyExpressionAssignment_0_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_0_2_0 = (RuleCall)cExpressionAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cVariableAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_1_0_0 = (RuleCall)cVariableAssignment_1_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cVariableAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_2_0_0 = (RuleCall)cVariableAssignment_2_0.eContents().get(0);
		private final Keyword cPlusSignEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cExpressionAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_2_0 = (RuleCall)cExpressionAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cVariableAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_3_0_0 = (RuleCall)cVariableAssignment_3_0.eContents().get(0);
		private final Assignment cNodeLabelsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cNodeLabelsNodeLabelsParserRuleCall_3_1_0 = (RuleCall)cNodeLabelsAssignment_3_1.eContents().get(0);
		
		//SetItem:
		//	propertyExpression=PropertyExpression '=' expression=Expression | variable=VariableDeclaration '='
		//	expression=Expression | variable=VariableDeclaration '+=' expression=Expression | variable=VariableDeclaration
		//	nodeLabels=NodeLabels;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * setItem : ( propertyExpression '=' expression )
		// *         | ( variable '=' expression )
		// *         | ( variable '+=' expression )
		// *         | ( variable nodeLabels );
		// */ propertyExpression=PropertyExpression '=' expression=Expression | variable=VariableDeclaration '='
		//expression=Expression | variable=VariableDeclaration '+=' expression=Expression | variable=VariableDeclaration
		//nodeLabels=NodeLabels
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * setItem : ( propertyExpression '=' expression )
		// *         | ( variable '=' expression )
		// *         | ( variable '+=' expression )
		// *         | ( variable nodeLabels );
		// */ propertyExpression=PropertyExpression '=' expression=Expression
		public Group getGroup_0() { return cGroup_0; }
		
		//propertyExpression=PropertyExpression
		public Assignment getPropertyExpressionAssignment_0_0() { return cPropertyExpressionAssignment_0_0; }
		
		//PropertyExpression
		public RuleCall getPropertyExpressionPropertyExpressionParserRuleCall_0_0_0() { return cPropertyExpressionPropertyExpressionParserRuleCall_0_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_1() { return cEqualsSignKeyword_0_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_0_2() { return cExpressionAssignment_0_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_2_0() { return cExpressionExpressionParserRuleCall_0_2_0; }
		
		//variable=VariableDeclaration '=' expression=Expression
		public Group getGroup_1() { return cGroup_1; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_1_0() { return cVariableAssignment_1_0; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_1_0_0() { return cVariableVariableDeclarationParserRuleCall_1_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_2_0() { return cExpressionExpressionParserRuleCall_1_2_0; }
		
		//variable=VariableDeclaration '+=' expression=Expression
		public Group getGroup_2() { return cGroup_2; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_2_0() { return cVariableAssignment_2_0; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_2_0_0() { return cVariableVariableDeclarationParserRuleCall_2_0_0; }
		
		//'+='
		public Keyword getPlusSignEqualsSignKeyword_2_1() { return cPlusSignEqualsSignKeyword_2_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2_2() { return cExpressionAssignment_2_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_2_0() { return cExpressionExpressionParserRuleCall_2_2_0; }
		
		//variable=VariableDeclaration nodeLabels=NodeLabels
		public Group getGroup_3() { return cGroup_3; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_3_0() { return cVariableAssignment_3_0; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_3_0_0() { return cVariableVariableDeclarationParserRuleCall_3_0_0; }
		
		//nodeLabels=NodeLabels
		public Assignment getNodeLabelsAssignment_3_1() { return cNodeLabelsAssignment_3_1; }
		
		//NodeLabels
		public RuleCall getNodeLabelsNodeLabelsParserRuleCall_3_1_0() { return cNodeLabelsNodeLabelsParserRuleCall_3_1_0; }
	}
	public class DeleteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Delete");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDetachAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDetachDETACHKeyword_0_0 = (Keyword)cDetachAssignment_0.eContents().get(0);
		private final Keyword cDELETEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionsExpressionParserRuleCall_2_0 = (RuleCall)cExpressionsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cExpressionsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_3_1_0 = (RuleCall)cExpressionsAssignment_3_1.eContents().get(0);
		
		//Delete:
		//	detach?='DETACH'? 'DELETE' expressions+=Expression (',' expressions+=Expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * delete : ( DELETE expression ( ',' expression )* )
		// *        | ( DETACH sp DELETE expression ( ',' expression )* );
		// */ detach?='DETACH'? 'DELETE' expressions+=Expression (',' expressions+=Expression)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * delete : ( DELETE expression ( ',' expression )* )
		// *        | ( DETACH sp DELETE expression ( ',' expression )* );
		// */ detach?='DETACH'?
		public Assignment getDetachAssignment_0() { return cDetachAssignment_0; }
		
		//'DETACH'
		public Keyword getDetachDETACHKeyword_0_0() { return cDetachDETACHKeyword_0_0; }
		
		//'DELETE'
		public Keyword getDELETEKeyword_1() { return cDELETEKeyword_1; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_2() { return cExpressionsAssignment_2; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_2_0() { return cExpressionsExpressionParserRuleCall_2_0; }
		
		//(',' expressions+=Expression)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_3_1() { return cExpressionsAssignment_3_1; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_3_1_0() { return cExpressionsExpressionParserRuleCall_3_1_0; }
	}
	public class RemoveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Remove");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cREMOVEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRemoveItemsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRemoveItemsRemoveItemParserRuleCall_1_0 = (RuleCall)cRemoveItemsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cRemoveItemsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cRemoveItemsRemoveItemParserRuleCall_2_1_0 = (RuleCall)cRemoveItemsAssignment_2_1.eContents().get(0);
		
		//Remove: /*
		// * remove : REMOVE sp removeItem ( ws ',' ws removeItem )* ;
		// */ 'REMOVE' removeItems+=RemoveItem (',' removeItems+=RemoveItem)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * remove : REMOVE sp removeItem ( ws ',' ws removeItem )* ;
		// */ 'REMOVE' removeItems+=RemoveItem (',' removeItems+=RemoveItem)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * remove : REMOVE sp removeItem ( ws ',' ws removeItem )* ;
		// */ 'REMOVE'
		public Keyword getREMOVEKeyword_0() { return cREMOVEKeyword_0; }
		
		//removeItems+=RemoveItem
		public Assignment getRemoveItemsAssignment_1() { return cRemoveItemsAssignment_1; }
		
		//RemoveItem
		public RuleCall getRemoveItemsRemoveItemParserRuleCall_1_0() { return cRemoveItemsRemoveItemParserRuleCall_1_0; }
		
		//(',' removeItems+=RemoveItem)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//removeItems+=RemoveItem
		public Assignment getRemoveItemsAssignment_2_1() { return cRemoveItemsAssignment_2_1; }
		
		//RemoveItem
		public RuleCall getRemoveItemsRemoveItemParserRuleCall_2_1_0() { return cRemoveItemsRemoveItemParserRuleCall_2_1_0; }
	}
	public class RemoveItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RemoveItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cRemoveItemLabelAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cVariableAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_0_1_0 = (RuleCall)cVariableAssignment_0_1.eContents().get(0);
		private final Assignment cNodeLabelsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNodeLabelsNodeLabelsParserRuleCall_0_2_0 = (RuleCall)cNodeLabelsAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cRemoveItemPropertyAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cPropertyExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPropertyExpressionPropertyExpressionParserRuleCall_1_1_0 = (RuleCall)cPropertyExpressionAssignment_1_1.eContents().get(0);
		
		//RemoveItem:
		//	{RemoveItemLabel} variable=VariableDeclaration nodeLabels=NodeLabels | {RemoveItemProperty}
		//	propertyExpression=PropertyExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//{RemoveItemLabel} variable=VariableDeclaration nodeLabels=NodeLabels | {RemoveItemProperty}
		//propertyExpression=PropertyExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{RemoveItemLabel} variable=VariableDeclaration nodeLabels=NodeLabels
		public Group getGroup_0() { return cGroup_0; }
		
		//{RemoveItemLabel}
		public Action getRemoveItemLabelAction_0_0() { return cRemoveItemLabelAction_0_0; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_0_1() { return cVariableAssignment_0_1; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_0_1_0() { return cVariableVariableDeclarationParserRuleCall_0_1_0; }
		
		//nodeLabels=NodeLabels
		public Assignment getNodeLabelsAssignment_0_2() { return cNodeLabelsAssignment_0_2; }
		
		//NodeLabels
		public RuleCall getNodeLabelsNodeLabelsParserRuleCall_0_2_0() { return cNodeLabelsNodeLabelsParserRuleCall_0_2_0; }
		
		//{RemoveItemProperty} propertyExpression=PropertyExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{RemoveItemProperty}
		public Action getRemoveItemPropertyAction_1_0() { return cRemoveItemPropertyAction_1_0; }
		
		//propertyExpression=PropertyExpression
		public Assignment getPropertyExpressionAssignment_1_1() { return cPropertyExpressionAssignment_1_1; }
		
		//PropertyExpression
		public RuleCall getPropertyExpressionPropertyExpressionParserRuleCall_1_1_0() { return cPropertyExpressionPropertyExpressionParserRuleCall_1_1_0; }
	}
	public class ForeachElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Foreach");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFOREACHKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_2_0 = (RuleCall)cVariableAssignment_2.eContents().get(0);
		private final Keyword cINKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExpressionExpressionParserRuleCall_4_0 = (RuleCall)cExpressionAssignment_4.eContents().get(0);
		private final Keyword cVerticalLineKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cClausesAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cClausesClauseParserRuleCall_6_0 = (RuleCall)cClausesAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Foreach: /*
		// * foreach : FOREACH ws '(' ws variable sp IN sp expression ws '|' ( sp clause )+ ws ')' ;
		// */ 'FOREACH' '(' variable=VariableDeclaration 'IN' expression=Expression '|' clauses+=Clause+ ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * foreach : FOREACH ws '(' ws variable sp IN sp expression ws '|' ( sp clause )+ ws ')' ;
		// */ 'FOREACH' '(' variable=VariableDeclaration 'IN' expression=Expression '|' clauses+=Clause+ ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * foreach : FOREACH ws '(' ws variable sp IN sp expression ws '|' ( sp clause )+ ws ')' ;
		// */ 'FOREACH'
		public Keyword getFOREACHKeyword_0() { return cFOREACHKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_2() { return cVariableAssignment_2; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_2_0() { return cVariableVariableDeclarationParserRuleCall_2_0; }
		
		//'IN'
		public Keyword getINKeyword_3() { return cINKeyword_3; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_4() { return cExpressionAssignment_4; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_4_0() { return cExpressionExpressionParserRuleCall_4_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_5() { return cVerticalLineKeyword_5; }
		
		//clauses+=Clause+
		public Assignment getClausesAssignment_6() { return cClausesAssignment_6; }
		
		//Clause
		public RuleCall getClausesClauseParserRuleCall_6_0() { return cClausesClauseParserRuleCall_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class InQueryCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.InQueryCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCALLKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInvocationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInvocationExplicitProcedureInvocationParserRuleCall_1_0 = (RuleCall)cInvocationAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cYIELDKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cYieldItemsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cYieldItemsYieldItemsParserRuleCall_2_1_0 = (RuleCall)cYieldItemsAssignment_2_1.eContents().get(0);
		
		//InQueryCall: /*
		// * inQueryCall : CALL sp explicitProcedureInvocation ( YIELD sp yieldItems )? ;
		// */ 'CALL' invocation=ExplicitProcedureInvocation ('YIELD' yieldItems=YieldItems)?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * inQueryCall : CALL sp explicitProcedureInvocation ( YIELD sp yieldItems )? ;
		// */ 'CALL' invocation=ExplicitProcedureInvocation ('YIELD' yieldItems=YieldItems)?
		public Group getGroup() { return cGroup; }
		
		///*
		// * inQueryCall : CALL sp explicitProcedureInvocation ( YIELD sp yieldItems )? ;
		// */ 'CALL'
		public Keyword getCALLKeyword_0() { return cCALLKeyword_0; }
		
		//invocation=ExplicitProcedureInvocation
		public Assignment getInvocationAssignment_1() { return cInvocationAssignment_1; }
		
		//ExplicitProcedureInvocation
		public RuleCall getInvocationExplicitProcedureInvocationParserRuleCall_1_0() { return cInvocationExplicitProcedureInvocationParserRuleCall_1_0; }
		
		//('YIELD' yieldItems=YieldItems)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'YIELD'
		public Keyword getYIELDKeyword_2_0() { return cYIELDKeyword_2_0; }
		
		//yieldItems=YieldItems
		public Assignment getYieldItemsAssignment_2_1() { return cYieldItemsAssignment_2_1; }
		
		//YieldItems
		public RuleCall getYieldItemsYieldItemsParserRuleCall_2_1_0() { return cYieldItemsYieldItemsParserRuleCall_2_1_0; }
	}
	public class StandaloneCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.StandaloneCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCALLKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInvocationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cInvocationAlternatives_1_0 = (Alternatives)cInvocationAssignment_1.eContents().get(0);
		private final RuleCall cInvocationExplicitProcedureInvocationParserRuleCall_1_0_0 = (RuleCall)cInvocationAlternatives_1_0.eContents().get(0);
		private final RuleCall cInvocationImplicitProcedureInvocationParserRuleCall_1_0_1 = (RuleCall)cInvocationAlternatives_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cYIELDKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cYieldItemsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cYieldItemsYieldItemsParserRuleCall_2_1_0 = (RuleCall)cYieldItemsAssignment_2_1.eContents().get(0);
		
		//StandaloneCall: /*
		// * standaloneCall: 'CALL' sp ( ExplicitProcedureInvocation | ImplicitProcedureInvocation ) ( sp YIELD sp YieldItems )? ;
		// */ 'CALL' invocation=(ExplicitProcedureInvocation | ImplicitProcedureInvocation) ('YIELD' yieldItems=YieldItems)?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * standaloneCall: 'CALL' sp ( ExplicitProcedureInvocation | ImplicitProcedureInvocation ) ( sp YIELD sp YieldItems )? ;
		// */ 'CALL' invocation=(ExplicitProcedureInvocation | ImplicitProcedureInvocation) ('YIELD' yieldItems=YieldItems)?
		public Group getGroup() { return cGroup; }
		
		///*
		// * standaloneCall: 'CALL' sp ( ExplicitProcedureInvocation | ImplicitProcedureInvocation ) ( sp YIELD sp YieldItems )? ;
		// */ 'CALL'
		public Keyword getCALLKeyword_0() { return cCALLKeyword_0; }
		
		//invocation=(ExplicitProcedureInvocation | ImplicitProcedureInvocation)
		public Assignment getInvocationAssignment_1() { return cInvocationAssignment_1; }
		
		//(ExplicitProcedureInvocation | ImplicitProcedureInvocation)
		public Alternatives getInvocationAlternatives_1_0() { return cInvocationAlternatives_1_0; }
		
		//ExplicitProcedureInvocation
		public RuleCall getInvocationExplicitProcedureInvocationParserRuleCall_1_0_0() { return cInvocationExplicitProcedureInvocationParserRuleCall_1_0_0; }
		
		//ImplicitProcedureInvocation
		public RuleCall getInvocationImplicitProcedureInvocationParserRuleCall_1_0_1() { return cInvocationImplicitProcedureInvocationParserRuleCall_1_0_1; }
		
		//('YIELD' yieldItems=YieldItems)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'YIELD'
		public Keyword getYIELDKeyword_2_0() { return cYIELDKeyword_2_0; }
		
		//yieldItems=YieldItems
		public Assignment getYieldItemsAssignment_2_1() { return cYieldItemsAssignment_2_1; }
		
		//YieldItems
		public RuleCall getYieldItemsYieldItemsParserRuleCall_2_1_0() { return cYieldItemsYieldItemsParserRuleCall_2_1_0; }
	}
	public class YieldItemsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.YieldItems");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cYieldItemsAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cItemsAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cItemsYieldItemParserRuleCall_1_0_0_0 = (RuleCall)cItemsAssignment_1_0_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Assignment cItemsAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cItemsYieldItemParserRuleCall_1_0_1_1_0 = (RuleCall)cItemsAssignment_1_0_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//YieldItems:
		//	{YieldItems} (items+=YieldItem (',' items+=YieldItem)* | '-');
		@Override public ParserRule getRule() { return rule; }
		
		//{YieldItems} (items+=YieldItem (',' items+=YieldItem)* | '-')
		public Group getGroup() { return cGroup; }
		
		//{YieldItems}
		public Action getYieldItemsAction_0() { return cYieldItemsAction_0; }
		
		//items+=YieldItem (',' items+=YieldItem)* | '-'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//items+=YieldItem (',' items+=YieldItem)*
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//items+=YieldItem
		public Assignment getItemsAssignment_1_0_0() { return cItemsAssignment_1_0_0; }
		
		//YieldItem
		public RuleCall getItemsYieldItemParserRuleCall_1_0_0_0() { return cItemsYieldItemParserRuleCall_1_0_0_0; }
		
		//(',' items+=YieldItem)*
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//','
		public Keyword getCommaKeyword_1_0_1_0() { return cCommaKeyword_1_0_1_0; }
		
		//items+=YieldItem
		public Assignment getItemsAssignment_1_0_1_1() { return cItemsAssignment_1_0_1_1; }
		
		//YieldItem
		public RuleCall getItemsYieldItemParserRuleCall_1_0_1_1_0() { return cItemsYieldItemParserRuleCall_1_0_1_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
	}
	public class YieldItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.YieldItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cFieldAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cFieldProcedureResultFieldParserRuleCall_0_0_0 = (RuleCall)cFieldAssignment_0_0.eContents().get(0);
		private final Keyword cASKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		
		//YieldItem:
		//	(field=ProcedureResultField 'AS')? variable=VariableDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//(field=ProcedureResultField 'AS')? variable=VariableDeclaration
		public Group getGroup() { return cGroup; }
		
		//(field=ProcedureResultField 'AS')?
		public Group getGroup_0() { return cGroup_0; }
		
		//field=ProcedureResultField
		public Assignment getFieldAssignment_0_0() { return cFieldAssignment_0_0; }
		
		//ProcedureResultField
		public RuleCall getFieldProcedureResultFieldParserRuleCall_0_0_0() { return cFieldProcedureResultFieldParserRuleCall_0_0_0; }
		
		//'AS'
		public Keyword getASKeyword_0_1() { return cASKeyword_0_1; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_1_0() { return cVariableVariableDeclarationParserRuleCall_1_0; }
	}
	public class WithElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.With");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWITHKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDistintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cDistintDISTINCTKeyword_1_0 = (Keyword)cDistintAssignment_1.eContents().get(0);
		private final Assignment cReturnBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cReturnBodyReturnBodyParserRuleCall_2_0 = (RuleCall)cReturnBodyAssignment_2.eContents().get(0);
		private final Assignment cWhereAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWhereWhereParserRuleCall_3_0 = (RuleCall)cWhereAssignment_3.eContents().get(0);
		
		//With: /*
		// * with : ( WITH DISTINCT sp returnBody where? )
		// *      | ( WITH sp returnBody where? );
		// */ 'WITH' distint?='DISTINCT'? returnBody=ReturnBody where=Where?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * with : ( WITH DISTINCT sp returnBody where? )
		// *      | ( WITH sp returnBody where? );
		// */ 'WITH' distint?='DISTINCT'? returnBody=ReturnBody where=Where?
		public Group getGroup() { return cGroup; }
		
		///*
		// * with : ( WITH DISTINCT sp returnBody where? )
		// *      | ( WITH sp returnBody where? );
		// */ 'WITH'
		public Keyword getWITHKeyword_0() { return cWITHKeyword_0; }
		
		//distint?='DISTINCT'?
		public Assignment getDistintAssignment_1() { return cDistintAssignment_1; }
		
		//'DISTINCT'
		public Keyword getDistintDISTINCTKeyword_1_0() { return cDistintDISTINCTKeyword_1_0; }
		
		//returnBody=ReturnBody
		public Assignment getReturnBodyAssignment_2() { return cReturnBodyAssignment_2; }
		
		//ReturnBody
		public RuleCall getReturnBodyReturnBodyParserRuleCall_2_0() { return cReturnBodyReturnBodyParserRuleCall_2_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_3() { return cWhereAssignment_3; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_3_0() { return cWhereWhereParserRuleCall_3_0; }
	}
	public class ReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Return");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cReturnAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cReturnRETURNKeyword_0_0 = (Keyword)cReturnAssignment_0.eContents().get(0);
		private final Assignment cDistinctAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cDistinctDISTINCTKeyword_1_0 = (Keyword)cDistinctAssignment_1.eContents().get(0);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyReturnBodyParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		
		//Return:
		//	return='RETURN' distinct?='DISTINCT'? body=ReturnBody;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * return : ( RETURN sp DISTINCT sp returnBody )
		// *        | ( RETURN sp returnBody );
		// */ return='RETURN' distinct?='DISTINCT'? body=ReturnBody
		public Group getGroup() { return cGroup; }
		
		//return='RETURN'
		public Assignment getReturnAssignment_0() { return cReturnAssignment_0; }
		
		//'RETURN'
		public Keyword getReturnRETURNKeyword_0_0() { return cReturnRETURNKeyword_0_0; }
		
		//distinct?='DISTINCT'?
		public Assignment getDistinctAssignment_1() { return cDistinctAssignment_1; }
		
		//'DISTINCT'
		public Keyword getDistinctDISTINCTKeyword_1_0() { return cDistinctDISTINCTKeyword_1_0; }
		
		//body=ReturnBody
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }
		
		//ReturnBody
		public RuleCall getBodyReturnBodyParserRuleCall_2_0() { return cBodyReturnBodyParserRuleCall_2_0; }
	}
	public class ReturnBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ReturnBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cReturnItemsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cReturnItemsReturnItemsParserRuleCall_0_0 = (RuleCall)cReturnItemsAssignment_0.eContents().get(0);
		private final Assignment cOrderAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOrderOrderParserRuleCall_1_0 = (RuleCall)cOrderAssignment_1.eContents().get(0);
		private final Assignment cSkipAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSkipSkipParserRuleCall_2_0 = (RuleCall)cSkipAssignment_2.eContents().get(0);
		private final Assignment cLimitAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLimitLimitParserRuleCall_3_0 = (RuleCall)cLimitAssignment_3.eContents().get(0);
		
		//ReturnBody:
		//	returnItems=ReturnItems order=Order? skip=Skip? limit=Limit?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * returnBody : returnItems ( sp order )? ( sp skip )? ( sp limit )? ;
		// */ returnItems=ReturnItems order=Order? skip=Skip? limit=Limit?
		public Group getGroup() { return cGroup; }
		
		///*
		// * returnBody : returnItems ( sp order )? ( sp skip )? ( sp limit )? ;
		// */ returnItems=ReturnItems
		public Assignment getReturnItemsAssignment_0() { return cReturnItemsAssignment_0; }
		
		//ReturnItems
		public RuleCall getReturnItemsReturnItemsParserRuleCall_0_0() { return cReturnItemsReturnItemsParserRuleCall_0_0; }
		
		//order=Order?
		public Assignment getOrderAssignment_1() { return cOrderAssignment_1; }
		
		//Order
		public RuleCall getOrderOrderParserRuleCall_1_0() { return cOrderOrderParserRuleCall_1_0; }
		
		//skip=Skip?
		public Assignment getSkipAssignment_2() { return cSkipAssignment_2; }
		
		//Skip
		public RuleCall getSkipSkipParserRuleCall_2_0() { return cSkipSkipParserRuleCall_2_0; }
		
		//limit=Limit?
		public Assignment getLimitAssignment_3() { return cLimitAssignment_3; }
		
		//Limit
		public RuleCall getLimitLimitParserRuleCall_3_0() { return cLimitLimitParserRuleCall_3_0; }
	}
	public class ReturnItemsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ReturnItems");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cReturnItemsAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Assignment cAllAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final Keyword cAllAsteriskKeyword_0_1_0_0 = (Keyword)cAllAssignment_0_1_0.eContents().get(0);
		private final Group cGroup_0_1_1 = (Group)cGroup_0_1.eContents().get(1);
		private final Keyword cCommaKeyword_0_1_1_0 = (Keyword)cGroup_0_1_1.eContents().get(0);
		private final Assignment cItemsAssignment_0_1_1_1 = (Assignment)cGroup_0_1_1.eContents().get(1);
		private final RuleCall cItemsReturnItemParserRuleCall_0_1_1_1_0 = (RuleCall)cItemsAssignment_0_1_1_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cItemsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cItemsReturnItemParserRuleCall_1_0_0 = (RuleCall)cItemsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cItemsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cItemsReturnItemParserRuleCall_1_1_1_0 = (RuleCall)cItemsAssignment_1_1_1.eContents().get(0);
		
		//ReturnItems:
		//	{ReturnItems} (all='*' (',' items+=ReturnItem)*) | items+=ReturnItem (',' items+=ReturnItem)*;
		@Override public ParserRule getRule() { return rule; }
		
		//{ReturnItems} (all='*' (',' items+=ReturnItem)*) | items+=ReturnItem (',' items+=ReturnItem)*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ReturnItems} (all='*' (',' items+=ReturnItem)*)
		public Group getGroup_0() { return cGroup_0; }
		
		//{ReturnItems}
		public Action getReturnItemsAction_0_0() { return cReturnItemsAction_0_0; }
		
		//all='*' (',' items+=ReturnItem)*
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//all='*'
		public Assignment getAllAssignment_0_1_0() { return cAllAssignment_0_1_0; }
		
		//'*'
		public Keyword getAllAsteriskKeyword_0_1_0_0() { return cAllAsteriskKeyword_0_1_0_0; }
		
		//(',' items+=ReturnItem)*
		public Group getGroup_0_1_1() { return cGroup_0_1_1; }
		
		//','
		public Keyword getCommaKeyword_0_1_1_0() { return cCommaKeyword_0_1_1_0; }
		
		//items+=ReturnItem
		public Assignment getItemsAssignment_0_1_1_1() { return cItemsAssignment_0_1_1_1; }
		
		//ReturnItem
		public RuleCall getItemsReturnItemParserRuleCall_0_1_1_1_0() { return cItemsReturnItemParserRuleCall_0_1_1_1_0; }
		
		//items+=ReturnItem (',' items+=ReturnItem)*
		public Group getGroup_1() { return cGroup_1; }
		
		//items+=ReturnItem
		public Assignment getItemsAssignment_1_0() { return cItemsAssignment_1_0; }
		
		//ReturnItem
		public RuleCall getItemsReturnItemParserRuleCall_1_0_0() { return cItemsReturnItemParserRuleCall_1_0_0; }
		
		//(',' items+=ReturnItem)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//','
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }
		
		//items+=ReturnItem
		public Assignment getItemsAssignment_1_1_1() { return cItemsAssignment_1_1_1; }
		
		//ReturnItem
		public RuleCall getItemsReturnItemParserRuleCall_1_1_1_0() { return cItemsReturnItemParserRuleCall_1_1_1_0; }
	}
	public class ReturnItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ReturnItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cASKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cAliasAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAliasVariableDeclarationParserRuleCall_1_1_0 = (RuleCall)cAliasAssignment_1_1.eContents().get(0);
		
		//ReturnItem:
		//	expression=Expression ('AS' alias=VariableDeclaration)?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * returnItem : ( expression sp AS sp variable )
		// *              | expression;
		// */ expression=Expression ('AS' alias=VariableDeclaration)?
		public Group getGroup() { return cGroup; }
		
		///*
		// * returnItem : ( expression sp AS sp variable )
		// *              | expression;
		// */ expression=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }
		
		//('AS' alias=VariableDeclaration)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'AS'
		public Keyword getASKeyword_1_0() { return cASKeyword_1_0; }
		
		//alias=VariableDeclaration
		public Assignment getAliasAssignment_1_1() { return cAliasAssignment_1_1; }
		
		//VariableDeclaration
		public RuleCall getAliasVariableDeclarationParserRuleCall_1_1_0() { return cAliasVariableDeclarationParserRuleCall_1_1_0; }
	}
	public class OrderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Order");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cORDERKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cBYKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOrderByAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOrderBySortItemParserRuleCall_2_0 = (RuleCall)cOrderByAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cOrderByAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOrderBySortItemParserRuleCall_3_1_0 = (RuleCall)cOrderByAssignment_3_1.eContents().get(0);
		
		//Order: /*
		// * order : ORDER sp BY sp sortItem ( ',' ws sortItem )* ;
		// */ 'ORDER' 'BY' orderBy+=SortItem (',' orderBy+=SortItem)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * order : ORDER sp BY sp sortItem ( ',' ws sortItem )* ;
		// */ 'ORDER' 'BY' orderBy+=SortItem (',' orderBy+=SortItem)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * order : ORDER sp BY sp sortItem ( ',' ws sortItem )* ;
		// */ 'ORDER'
		public Keyword getORDERKeyword_0() { return cORDERKeyword_0; }
		
		//'BY'
		public Keyword getBYKeyword_1() { return cBYKeyword_1; }
		
		//orderBy+=SortItem
		public Assignment getOrderByAssignment_2() { return cOrderByAssignment_2; }
		
		//SortItem
		public RuleCall getOrderBySortItemParserRuleCall_2_0() { return cOrderBySortItemParserRuleCall_2_0; }
		
		//(',' orderBy+=SortItem)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//orderBy+=SortItem
		public Assignment getOrderByAssignment_3_1() { return cOrderByAssignment_3_1; }
		
		//SortItem
		public RuleCall getOrderBySortItemParserRuleCall_3_1_0() { return cOrderBySortItemParserRuleCall_3_1_0; }
	}
	public class SkipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Skip");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSKIPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSkipAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSkipExpressionParserRuleCall_1_0 = (RuleCall)cSkipAssignment_1.eContents().get(0);
		
		//Skip: /*
		// * skip: L_SKIP sp expression;
		// */ 'SKIP' skip=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * skip: L_SKIP sp expression;
		// */ 'SKIP' skip=Expression
		public Group getGroup() { return cGroup; }
		
		///*
		// * skip: L_SKIP sp expression;
		// */ 'SKIP'
		public Keyword getSKIPKeyword_0() { return cSKIPKeyword_0; }
		
		//skip=Expression
		public Assignment getSkipAssignment_1() { return cSkipAssignment_1; }
		
		//Expression
		public RuleCall getSkipExpressionParserRuleCall_1_0() { return cSkipExpressionParserRuleCall_1_0; }
	}
	public class LimitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Limit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLIMITKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLimitAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLimitExpressionParserRuleCall_1_0 = (RuleCall)cLimitAssignment_1.eContents().get(0);
		
		//Limit: /*
		// * limit: LIMIT sp expression;
		// */ 'LIMIT' limit=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * limit: LIMIT sp expression;
		// */ 'LIMIT' limit=Expression
		public Group getGroup() { return cGroup; }
		
		///*
		// * limit: LIMIT sp expression;
		// */ 'LIMIT'
		public Keyword getLIMITKeyword_0() { return cLIMITKeyword_0; }
		
		//limit=Expression
		public Assignment getLimitAssignment_1() { return cLimitAssignment_1; }
		
		//Expression
		public RuleCall getLimitExpressionParserRuleCall_1_0() { return cLimitExpressionParserRuleCall_1_0; }
	}
	public class SortItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.SortItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Assignment cSortAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cSortAlternatives_1_0 = (Alternatives)cSortAssignment_1.eContents().get(0);
		private final Keyword cSortDESCENDINGKeyword_1_0_0 = (Keyword)cSortAlternatives_1_0.eContents().get(0);
		private final Keyword cSortDESCKeyword_1_0_1 = (Keyword)cSortAlternatives_1_0.eContents().get(1);
		private final Keyword cSortASCENDINGKeyword_1_0_2 = (Keyword)cSortAlternatives_1_0.eContents().get(2);
		private final Keyword cSortASCKeyword_1_0_3 = (Keyword)cSortAlternatives_1_0.eContents().get(3);
		
		//SortItem:
		//	expression=Expression sort=('DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC')?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * sortItem : ( expression ( DESCENDING | DESC ) )
		// *          | ( expression ( ASCENDING | ASC )? );
		// */ expression=Expression sort=('DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC')?
		public Group getGroup() { return cGroup; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }
		
		//sort=('DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC')?
		public Assignment getSortAssignment_1() { return cSortAssignment_1; }
		
		//('DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC')
		public Alternatives getSortAlternatives_1_0() { return cSortAlternatives_1_0; }
		
		//'DESCENDING'
		public Keyword getSortDESCENDINGKeyword_1_0_0() { return cSortDESCENDINGKeyword_1_0_0; }
		
		//'DESC'
		public Keyword getSortDESCKeyword_1_0_1() { return cSortDESCKeyword_1_0_1; }
		
		//'ASCENDING'
		public Keyword getSortASCENDINGKeyword_1_0_2() { return cSortASCENDINGKeyword_1_0_2; }
		
		//'ASC'
		public Keyword getSortASCKeyword_1_0_3() { return cSortASCKeyword_1_0_3; }
	}
	public class HintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Hint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIndexHintAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cUSINGKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Keyword cINDEXKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final RuleCall cWSTerminalRuleCall_0_4 = (RuleCall)cGroup_0.eContents().get(4);
		private final Assignment cVariableAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_0_5_0 = (RuleCall)cVariableAssignment_0_5.eContents().get(0);
		private final Assignment cNodeLabelAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cNodeLabelNodeLabelParserRuleCall_0_6_0 = (RuleCall)cNodeLabelAssignment_0_6.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_0_7 = (RuleCall)cGroup_0.eContents().get(7);
		private final Keyword cLeftParenthesisKeyword_0_8 = (Keyword)cGroup_0.eContents().get(8);
		private final Assignment cPropertyKeyNameAssignment_0_9 = (Assignment)cGroup_0.eContents().get(9);
		private final RuleCall cPropertyKeyNamePropertyKeyNameParserRuleCall_0_9_0 = (RuleCall)cPropertyKeyNameAssignment_0_9.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_10 = (Keyword)cGroup_0.eContents().get(10);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cJoinHintAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cUSINGKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1_1_1 = (RuleCall)cGroup_1_1.eContents().get(1);
		private final Keyword cJOINKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		private final RuleCall cWSTerminalRuleCall_1_1_3 = (RuleCall)cGroup_1_1.eContents().get(3);
		private final Keyword cONKeyword_1_1_4 = (Keyword)cGroup_1_1.eContents().get(4);
		private final Assignment cVariablesAssignment_1_1_5 = (Assignment)cGroup_1_1.eContents().get(5);
		private final RuleCall cVariablesVariableDeclarationParserRuleCall_1_1_5_0 = (RuleCall)cVariablesAssignment_1_1_5.eContents().get(0);
		private final Group cGroup_1_1_6 = (Group)cGroup_1_1.eContents().get(6);
		private final Keyword cCommaKeyword_1_1_6_0 = (Keyword)cGroup_1_1_6.eContents().get(0);
		private final Assignment cVariablesAssignment_1_1_6_1 = (Assignment)cGroup_1_1_6.eContents().get(1);
		private final RuleCall cVariablesVariableDeclarationParserRuleCall_1_1_6_1_0 = (RuleCall)cVariablesAssignment_1_1_6_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cScanHintAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cUSINGKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_2_1_1 = (RuleCall)cGroup_2_1.eContents().get(1);
		private final Keyword cSCANKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final RuleCall cWSTerminalRuleCall_2_1_3 = (RuleCall)cGroup_2_1.eContents().get(3);
		private final Assignment cVariableAssignment_2_1_4 = (Assignment)cGroup_2_1.eContents().get(4);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_2_1_4_0 = (RuleCall)cVariableAssignment_2_1_4.eContents().get(0);
		private final Assignment cNodeLabelAssignment_2_1_5 = (Assignment)cGroup_2_1.eContents().get(5);
		private final RuleCall cNodeLabelNodeLabelParserRuleCall_2_1_5_0 = (RuleCall)cNodeLabelAssignment_2_1_5.eContents().get(0);
		
		//Hint hidden():
		//	{IndexHint} 'USING' WS 'INDEX' WS variable=VariableDeclaration nodeLabel=NodeLabel WS '('
		//	propertyKeyName=PropertyKeyName ')' | {JoinHint} ('USING' WS 'JOIN' WS 'ON' variables+=VariableDeclaration (','
		//	variables+=VariableDeclaration)*) | {ScanHint} ('USING' WS 'SCAN'
		//	WS variable=VariableDeclaration nodeLabel=NodeLabel);
		@Override public ParserRule getRule() { return rule; }
		
		//{IndexHint} 'USING' WS 'INDEX' WS variable=VariableDeclaration nodeLabel=NodeLabel WS '('
		//propertyKeyName=PropertyKeyName ')' | {JoinHint} ('USING' WS 'JOIN' WS 'ON' variables+=VariableDeclaration (','
		//variables+=VariableDeclaration)*) | {ScanHint} ('USING' WS 'SCAN' WS variable=VariableDeclaration nodeLabel=NodeLabel)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{IndexHint} 'USING' WS 'INDEX' WS variable=VariableDeclaration nodeLabel=NodeLabel WS '('
		//propertyKeyName=PropertyKeyName ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//{IndexHint}
		public Action getIndexHintAction_0_0() { return cIndexHintAction_0_0; }
		
		//'USING'
		public Keyword getUSINGKeyword_0_1() { return cUSINGKeyword_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_0_2() { return cWSTerminalRuleCall_0_2; }
		
		//'INDEX'
		public Keyword getINDEXKeyword_0_3() { return cINDEXKeyword_0_3; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_0_4() { return cWSTerminalRuleCall_0_4; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_0_5() { return cVariableAssignment_0_5; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_0_5_0() { return cVariableVariableDeclarationParserRuleCall_0_5_0; }
		
		//nodeLabel=NodeLabel
		public Assignment getNodeLabelAssignment_0_6() { return cNodeLabelAssignment_0_6; }
		
		//NodeLabel
		public RuleCall getNodeLabelNodeLabelParserRuleCall_0_6_0() { return cNodeLabelNodeLabelParserRuleCall_0_6_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_0_7() { return cWSTerminalRuleCall_0_7; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_8() { return cLeftParenthesisKeyword_0_8; }
		
		//propertyKeyName=PropertyKeyName
		public Assignment getPropertyKeyNameAssignment_0_9() { return cPropertyKeyNameAssignment_0_9; }
		
		//PropertyKeyName
		public RuleCall getPropertyKeyNamePropertyKeyNameParserRuleCall_0_9_0() { return cPropertyKeyNamePropertyKeyNameParserRuleCall_0_9_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_10() { return cRightParenthesisKeyword_0_10; }
		
		//{JoinHint} ('USING' WS 'JOIN' WS 'ON' variables+=VariableDeclaration (',' variables+=VariableDeclaration)*)
		public Group getGroup_1() { return cGroup_1; }
		
		//{JoinHint}
		public Action getJoinHintAction_1_0() { return cJoinHintAction_1_0; }
		
		//'USING' WS 'JOIN' WS 'ON' variables+=VariableDeclaration (',' variables+=VariableDeclaration)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'USING'
		public Keyword getUSINGKeyword_1_1_0() { return cUSINGKeyword_1_1_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1_1() { return cWSTerminalRuleCall_1_1_1; }
		
		//'JOIN'
		public Keyword getJOINKeyword_1_1_2() { return cJOINKeyword_1_1_2; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_1_1_3() { return cWSTerminalRuleCall_1_1_3; }
		
		//'ON'
		public Keyword getONKeyword_1_1_4() { return cONKeyword_1_1_4; }
		
		//variables+=VariableDeclaration
		public Assignment getVariablesAssignment_1_1_5() { return cVariablesAssignment_1_1_5; }
		
		//VariableDeclaration
		public RuleCall getVariablesVariableDeclarationParserRuleCall_1_1_5_0() { return cVariablesVariableDeclarationParserRuleCall_1_1_5_0; }
		
		//(',' variables+=VariableDeclaration)*
		public Group getGroup_1_1_6() { return cGroup_1_1_6; }
		
		//','
		public Keyword getCommaKeyword_1_1_6_0() { return cCommaKeyword_1_1_6_0; }
		
		//variables+=VariableDeclaration
		public Assignment getVariablesAssignment_1_1_6_1() { return cVariablesAssignment_1_1_6_1; }
		
		//VariableDeclaration
		public RuleCall getVariablesVariableDeclarationParserRuleCall_1_1_6_1_0() { return cVariablesVariableDeclarationParserRuleCall_1_1_6_1_0; }
		
		//{ScanHint} ('USING' WS 'SCAN' WS variable=VariableDeclaration nodeLabel=NodeLabel)
		public Group getGroup_2() { return cGroup_2; }
		
		//{ScanHint}
		public Action getScanHintAction_2_0() { return cScanHintAction_2_0; }
		
		//'USING' WS 'SCAN' WS variable=VariableDeclaration nodeLabel=NodeLabel
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//'USING'
		public Keyword getUSINGKeyword_2_1_0() { return cUSINGKeyword_2_1_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_2_1_1() { return cWSTerminalRuleCall_2_1_1; }
		
		//'SCAN'
		public Keyword getSCANKeyword_2_1_2() { return cSCANKeyword_2_1_2; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_2_1_3() { return cWSTerminalRuleCall_2_1_3; }
		
		//variable=VariableDeclaration
		public Assignment getVariableAssignment_2_1_4() { return cVariableAssignment_2_1_4; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_2_1_4_0() { return cVariableVariableDeclarationParserRuleCall_2_1_4_0; }
		
		//nodeLabel=NodeLabel
		public Assignment getNodeLabelAssignment_2_1_5() { return cNodeLabelAssignment_2_1_5; }
		
		//NodeLabel
		public RuleCall getNodeLabelNodeLabelParserRuleCall_2_1_5_0() { return cNodeLabelNodeLabelParserRuleCall_2_1_5_0; }
	}
	public class StartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Start");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSTARTKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStartPointAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStartPointStartPointParserRuleCall_1_0 = (RuleCall)cStartPointAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStartPointAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStartPointStartPointParserRuleCall_2_1_0 = (RuleCall)cStartPointAssignment_2_1.eContents().get(0);
		private final Assignment cWhereAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWhereWhereParserRuleCall_3_0 = (RuleCall)cWhereAssignment_3.eContents().get(0);
		
		//Start: /*
		// * start : START sp startPoint ( ws ',' ws startPoint )* where? ;
		// */ 'START' startPoint+=StartPoint (',' startPoint+=StartPoint)* where=Where?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * start : START sp startPoint ( ws ',' ws startPoint )* where? ;
		// */ 'START' startPoint+=StartPoint (',' startPoint+=StartPoint)* where=Where?
		public Group getGroup() { return cGroup; }
		
		///*
		// * start : START sp startPoint ( ws ',' ws startPoint )* where? ;
		// */ 'START'
		public Keyword getSTARTKeyword_0() { return cSTARTKeyword_0; }
		
		//startPoint+=StartPoint
		public Assignment getStartPointAssignment_1() { return cStartPointAssignment_1; }
		
		//StartPoint
		public RuleCall getStartPointStartPointParserRuleCall_1_0() { return cStartPointStartPointParserRuleCall_1_0; }
		
		//(',' startPoint+=StartPoint)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//startPoint+=StartPoint
		public Assignment getStartPointAssignment_2_1() { return cStartPointAssignment_2_1; }
		
		//StartPoint
		public RuleCall getStartPointStartPointParserRuleCall_2_1_0() { return cStartPointStartPointParserRuleCall_2_1_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_3() { return cWhereAssignment_3; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_3_0() { return cWhereWhereParserRuleCall_3_0; }
	}
	public class StartPointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.StartPoint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLookupAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLookupLookupParserRuleCall_2_0 = (RuleCall)cLookupAssignment_2.eContents().get(0);
		
		//StartPoint:
		//	variable=VariableDeclaration '=' lookup=Lookup;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * startPoint : variable ws '=' ws lookup ;
		// */ variable=VariableDeclaration '=' lookup=Lookup
		public Group getGroup() { return cGroup; }
		
		///*
		// * startPoint : variable ws '=' ws lookup ;
		// */ variable=VariableDeclaration
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_0_0() { return cVariableVariableDeclarationParserRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//lookup=Lookup
		public Assignment getLookupAssignment_2() { return cLookupAssignment_2; }
		
		//Lookup
		public RuleCall getLookupLookupParserRuleCall_2_0() { return cLookupLookupParserRuleCall_2_0; }
	}
	public class LookupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Lookup");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNodeLookupParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRelationshipLookupParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Lookup:
		//	NodeLookup | RelationshipLookup;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * lookup : nodeLookup
		// *        | relationshipLookup;
		// */ NodeLookup | RelationshipLookup
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * lookup : nodeLookup
		// *        | relationshipLookup;
		// */ NodeLookup
		public RuleCall getNodeLookupParserRuleCall_0() { return cNodeLookupParserRuleCall_0; }
		
		//RelationshipLookup
		public RuleCall getRelationshipLookupParserRuleCall_1() { return cRelationshipLookupParserRuleCall_1; }
	}
	public class NodeLookupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.NodeLookup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNODEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cIdentifiedIndexLookupParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cIndexQueryParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cIdLookupParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		
		//NodeLookup: /*
		// * nodeLookup : NODE ( identifiedIndexLookup | indexQuery | idLookup ) ;
		// */ 'NODE' (IdentifiedIndexLookup | IndexQuery | IdLookup);
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * nodeLookup : NODE ( identifiedIndexLookup | indexQuery | idLookup ) ;
		// */ 'NODE' (IdentifiedIndexLookup | IndexQuery | IdLookup)
		public Group getGroup() { return cGroup; }
		
		///*
		// * nodeLookup : NODE ( identifiedIndexLookup | indexQuery | idLookup ) ;
		// */ 'NODE'
		public Keyword getNODEKeyword_0() { return cNODEKeyword_0; }
		
		//IdentifiedIndexLookup | IndexQuery | IdLookup
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//IdentifiedIndexLookup
		public RuleCall getIdentifiedIndexLookupParserRuleCall_1_0() { return cIdentifiedIndexLookupParserRuleCall_1_0; }
		
		//IndexQuery
		public RuleCall getIndexQueryParserRuleCall_1_1() { return cIndexQueryParserRuleCall_1_1; }
		
		//IdLookup
		public RuleCall getIdLookupParserRuleCall_1_2() { return cIdLookupParserRuleCall_1_2; }
	}
	public class RelationshipLookupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelationshipLookup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cRELATIONSHIPKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cRELKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cIdentifiedIndexLookupParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cIndexQueryParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cIdLookupParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		
		//RelationshipLookup:
		//	('RELATIONSHIP' | 'REL') (IdentifiedIndexLookup | IndexQuery | IdLookup);
		@Override public ParserRule getRule() { return rule; }
		
		//('RELATIONSHIP' | 'REL') (IdentifiedIndexLookup | IndexQuery | IdLookup)
		public Group getGroup() { return cGroup; }
		
		///*
		// * relationshipLookup : ( RELATIONSHIP | REL ) ( identifiedIndexLookup | indexQuery | idLookup ) ;
		// */ 'RELATIONSHIP' | 'REL'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'RELATIONSHIP'
		public Keyword getRELATIONSHIPKeyword_0_0() { return cRELATIONSHIPKeyword_0_0; }
		
		//'REL'
		public Keyword getRELKeyword_0_1() { return cRELKeyword_0_1; }
		
		//IdentifiedIndexLookup | IndexQuery | IdLookup
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//IdentifiedIndexLookup
		public RuleCall getIdentifiedIndexLookupParserRuleCall_1_0() { return cIdentifiedIndexLookupParserRuleCall_1_0; }
		
		//IndexQuery
		public RuleCall getIndexQueryParserRuleCall_1_1() { return cIndexQueryParserRuleCall_1_1; }
		
		//IdLookup
		public RuleCall getIdLookupParserRuleCall_1_2() { return cIdLookupParserRuleCall_1_2; }
	}
	public class IdentifiedIndexLookupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.IdentifiedIndexLookup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexNameSYMBOLIC_NAME_XParserRuleCall_1_0 = (RuleCall)cIndexNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cKeyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cKeySYMBOLIC_NAME_XParserRuleCall_3_0 = (RuleCall)cKeyAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cValueAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cValueSTRING_LITERALTerminalRuleCall_5_0_0 = (RuleCall)cValueAssignment_5_0.eContents().get(0);
		private final Assignment cLegacyParameterAssignment_5_1 = (Assignment)cAlternatives_5.eContents().get(1);
		private final RuleCall cLegacyParameterLegacyParameterParserRuleCall_5_1_0 = (RuleCall)cLegacyParameterAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IdentifiedIndexLookup: /*
		// * identifiedIndexLookup : ':' symbolicName '(' symbolicName '=' ( StringLiteral | legacyParameter ) ')' ;
		// */ ':' indexName=SYMBOLIC_NAME_X '(' key=SYMBOLIC_NAME_X '=' (value=STRING_LITERAL | legacyParameter=LegacyParameter)
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * identifiedIndexLookup : ':' symbolicName '(' symbolicName '=' ( StringLiteral | legacyParameter ) ')' ;
		// */ ':' indexName=SYMBOLIC_NAME_X '(' key=SYMBOLIC_NAME_X '=' (value=STRING_LITERAL | legacyParameter=LegacyParameter)
		//')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * identifiedIndexLookup : ':' symbolicName '(' symbolicName '=' ( StringLiteral | legacyParameter ) ')' ;
		// */ ':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//indexName=SYMBOLIC_NAME_X
		public Assignment getIndexNameAssignment_1() { return cIndexNameAssignment_1; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getIndexNameSYMBOLIC_NAME_XParserRuleCall_1_0() { return cIndexNameSYMBOLIC_NAME_XParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//key=SYMBOLIC_NAME_X
		public Assignment getKeyAssignment_3() { return cKeyAssignment_3; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getKeySYMBOLIC_NAME_XParserRuleCall_3_0() { return cKeySYMBOLIC_NAME_XParserRuleCall_3_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }
		
		//value=STRING_LITERAL | legacyParameter=LegacyParameter
		public Alternatives getAlternatives_5() { return cAlternatives_5; }
		
		//value=STRING_LITERAL
		public Assignment getValueAssignment_5_0() { return cValueAssignment_5_0; }
		
		//STRING_LITERAL
		public RuleCall getValueSTRING_LITERALTerminalRuleCall_5_0_0() { return cValueSTRING_LITERALTerminalRuleCall_5_0_0; }
		
		//legacyParameter=LegacyParameter
		public Assignment getLegacyParameterAssignment_5_1() { return cLegacyParameterAssignment_5_1; }
		
		//LegacyParameter
		public RuleCall getLegacyParameterLegacyParameterParserRuleCall_5_1_0() { return cLegacyParameterLegacyParameterParserRuleCall_5_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}
	public class IndexQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.IndexQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexNameSYMBOLIC_NAME_XParserRuleCall_1_0 = (RuleCall)cIndexNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cQueryAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cQuerySTRING_LITERALTerminalRuleCall_3_0_0 = (RuleCall)cQueryAssignment_3_0.eContents().get(0);
		private final Assignment cParameterAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cParameterParameterParserRuleCall_3_1_0 = (RuleCall)cParameterAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//IndexQuery: /*
		// * indexQuery : ':' symbolicName '(' ( StringLiteral | legacyParameter ) ')' ;
		// */ ':' indexName=SYMBOLIC_NAME_X '(' (query=STRING_LITERAL | parameter=Parameter) ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * indexQuery : ':' symbolicName '(' ( StringLiteral | legacyParameter ) ')' ;
		// */ ':' indexName=SYMBOLIC_NAME_X '(' (query=STRING_LITERAL | parameter=Parameter) ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * indexQuery : ':' symbolicName '(' ( StringLiteral | legacyParameter ) ')' ;
		// */ ':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//indexName=SYMBOLIC_NAME_X
		public Assignment getIndexNameAssignment_1() { return cIndexNameAssignment_1; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getIndexNameSYMBOLIC_NAME_XParserRuleCall_1_0() { return cIndexNameSYMBOLIC_NAME_XParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//query=STRING_LITERAL | parameter=Parameter
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//query=STRING_LITERAL
		public Assignment getQueryAssignment_3_0() { return cQueryAssignment_3_0; }
		
		//STRING_LITERAL
		public RuleCall getQuerySTRING_LITERALTerminalRuleCall_3_0_0() { return cQuerySTRING_LITERALTerminalRuleCall_3_0_0; }
		
		//parameter=Parameter
		public Assignment getParameterAssignment_3_1() { return cParameterAssignment_3_1; }
		
		//Parameter
		public RuleCall getParameterParameterParserRuleCall_3_1_0() { return cParameterParameterParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class IdLookupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.IdLookup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIdsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cIdsLiteralIdsParserRuleCall_1_0_0 = (RuleCall)cIdsAssignment_1_0.eContents().get(0);
		private final Assignment cLegacyParameterAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cLegacyParameterParameterParserRuleCall_1_1_0 = (RuleCall)cLegacyParameterAssignment_1_1.eContents().get(0);
		private final Assignment cWildcardAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final Keyword cWildcardAsteriskKeyword_1_2_0 = (Keyword)cWildcardAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//IdLookup: /*
		// * idLookup : '(' ( literalIds | legacyParameter | '*' ) ')' ;
		// */ '(' (ids=LiteralIds | legacyParameter=Parameter | wildcard='*') ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * idLookup : '(' ( literalIds | legacyParameter | '*' ) ')' ;
		// */ '(' (ids=LiteralIds | legacyParameter=Parameter | wildcard='*') ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * idLookup : '(' ( literalIds | legacyParameter | '*' ) ')' ;
		// */ '('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//ids=LiteralIds | legacyParameter=Parameter | wildcard='*'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//ids=LiteralIds
		public Assignment getIdsAssignment_1_0() { return cIdsAssignment_1_0; }
		
		//LiteralIds
		public RuleCall getIdsLiteralIdsParserRuleCall_1_0_0() { return cIdsLiteralIdsParserRuleCall_1_0_0; }
		
		//legacyParameter=Parameter
		public Assignment getLegacyParameterAssignment_1_1() { return cLegacyParameterAssignment_1_1; }
		
		//Parameter
		public RuleCall getLegacyParameterParameterParserRuleCall_1_1_0() { return cLegacyParameterParameterParserRuleCall_1_1_0; }
		
		//wildcard='*'
		public Assignment getWildcardAssignment_1_2() { return cWildcardAssignment_1_2; }
		
		//'*'
		public Keyword getWildcardAsteriskKeyword_1_2_0() { return cWildcardAsteriskKeyword_1_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class LiteralIdsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.LiteralIds");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdsDecimalIntegerParserRuleCall_0_0 = (RuleCall)cIdsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIdsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdsDecimalIntegerParserRuleCall_1_1_0 = (RuleCall)cIdsAssignment_1_1.eContents().get(0);
		
		//LiteralIds:
		//	ids+=DecimalInteger (',' ids+=DecimalInteger)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * literalIds : unsignedIntegerLiteral ( ws ',' ws unsignedIntegerLiteral )*;
		// */ ids+=DecimalInteger (',' ids+=DecimalInteger)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * literalIds : unsignedIntegerLiteral ( ws ',' ws unsignedIntegerLiteral )*;
		// */ ids+=DecimalInteger
		public Assignment getIdsAssignment_0() { return cIdsAssignment_0; }
		
		//DecimalInteger
		public RuleCall getIdsDecimalIntegerParserRuleCall_0_0() { return cIdsDecimalIntegerParserRuleCall_0_0; }
		
		//(',' ids+=DecimalInteger)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//ids+=DecimalInteger
		public Assignment getIdsAssignment_1_1() { return cIdsAssignment_1_1; }
		
		//DecimalInteger
		public RuleCall getIdsDecimalIntegerParserRuleCall_1_1_0() { return cIdsDecimalIntegerParserRuleCall_1_1_0; }
	}
	public class WhereElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Where");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWHEREKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//Where: /*
		// * where : WHERE sp expression;
		// */ 'WHERE' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * where : WHERE sp expression;
		// */ 'WHERE' expression=Expression
		public Group getGroup() { return cGroup; }
		
		///*
		// * where : WHERE sp expression;
		// */ 'WHERE'
		public Keyword getWHEREKeyword_0() { return cWHEREKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
	}
	public class PatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Pattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPatternsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPatternsPatternPartParserRuleCall_0_0 = (RuleCall)cPatternsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cPatternsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPatternsPatternPartParserRuleCall_1_1_0 = (RuleCall)cPatternsAssignment_1_1.eContents().get(0);
		
		//Pattern:
		//	patterns+=PatternPart (',' patterns+=PatternPart)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * pattern : patternPart ( ',' patternPart )*;
		// */ patterns+=PatternPart (',' patterns+=PatternPart)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * pattern : patternPart ( ',' patternPart )*;
		// */ patterns+=PatternPart
		public Assignment getPatternsAssignment_0() { return cPatternsAssignment_0; }
		
		//PatternPart
		public RuleCall getPatternsPatternPartParserRuleCall_0_0() { return cPatternsPatternPartParserRuleCall_0_0; }
		
		//(',' patterns+=PatternPart)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//patterns+=PatternPart
		public Assignment getPatternsAssignment_1_1() { return cPatternsAssignment_1_1; }
		
		//PatternPart
		public RuleCall getPatternsPatternPartParserRuleCall_1_1_0() { return cPatternsPatternPartParserRuleCall_1_1_0; }
	}
	public class PatternPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PatternPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cVarAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cVarVariableDeclarationParserRuleCall_0_0_0 = (RuleCall)cVarAssignment_0_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPartAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cPartAnonymousPatternPartParserRuleCall_0_2_0 = (RuleCall)cPartAssignment_0_2.eContents().get(0);
		private final RuleCall cAnonymousPatternPartParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PatternPart:
		//	var=VariableDeclaration '=' part=AnonymousPatternPart | AnonymousPatternPart;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * patternPart : ( variable ws '=' ws anonymousPatternPart )
		// *               | anonymousPatternPart;
		// */ var=VariableDeclaration '=' part=AnonymousPatternPart | AnonymousPatternPart
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * patternPart : ( variable ws '=' ws anonymousPatternPart )
		// *               | anonymousPatternPart;
		// */ var=VariableDeclaration '=' part=AnonymousPatternPart
		public Group getGroup_0() { return cGroup_0; }
		
		//var=VariableDeclaration
		public Assignment getVarAssignment_0_0() { return cVarAssignment_0_0; }
		
		//VariableDeclaration
		public RuleCall getVarVariableDeclarationParserRuleCall_0_0_0() { return cVarVariableDeclarationParserRuleCall_0_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_1() { return cEqualsSignKeyword_0_1; }
		
		//part=AnonymousPatternPart
		public Assignment getPartAssignment_0_2() { return cPartAssignment_0_2; }
		
		//AnonymousPatternPart
		public RuleCall getPartAnonymousPatternPartParserRuleCall_0_2_0() { return cPartAnonymousPatternPartParserRuleCall_0_2_0; }
		
		//AnonymousPatternPart
		public RuleCall getAnonymousPatternPartParserRuleCall_1() { return cAnonymousPatternPartParserRuleCall_1; }
	}
	public class AnonymousPatternPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.AnonymousPatternPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cShortestPathPatternParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPatternElementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AnonymousPatternPart:
		//	ShortestPathPattern | PatternElement;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * anonymousPatternPart : shortestPathPattern
		// *                      | patternElement;
		// */ ShortestPathPattern | PatternElement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * anonymousPatternPart : shortestPathPattern
		// *                      | patternElement;
		// */ ShortestPathPattern
		public RuleCall getShortestPathPatternParserRuleCall_0() { return cShortestPathPatternParserRuleCall_0; }
		
		//PatternElement
		public RuleCall getPatternElementParserRuleCall_1() { return cPatternElementParserRuleCall_1; }
	}
	public class ShortestPathPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ShortestPathPattern");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cShortestPathAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cSHORTESTPATHKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cPatternElementAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cPatternElementPatternElementParserRuleCall_0_3_0 = (RuleCall)cPatternElementAssignment_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cAllShortestPathsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cALLSHORTESTPATHSKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cPatternElementAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cPatternElementPatternElementParserRuleCall_1_3_0 = (RuleCall)cPatternElementAssignment_1_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		//ShortestPathPattern:
		//	{ShortestPath} 'SHORTESTPATH' '(' patternElement=PatternElement ')' | {AllShortestPaths} 'ALLSHORTESTPATHS' '('
		//	patternElement=PatternElement ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{ShortestPath} 'SHORTESTPATH' '(' patternElement=PatternElement ')' | {AllShortestPaths} 'ALLSHORTESTPATHS' '('
		//patternElement=PatternElement ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ShortestPath} 'SHORTESTPATH' '(' patternElement=PatternElement ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//{ShortestPath}
		public Action getShortestPathAction_0_0() { return cShortestPathAction_0_0; }
		
		//'SHORTESTPATH'
		public Keyword getSHORTESTPATHKeyword_0_1() { return cSHORTESTPATHKeyword_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_2() { return cLeftParenthesisKeyword_0_2; }
		
		//patternElement=PatternElement
		public Assignment getPatternElementAssignment_0_3() { return cPatternElementAssignment_0_3; }
		
		//PatternElement
		public RuleCall getPatternElementPatternElementParserRuleCall_0_3_0() { return cPatternElementPatternElementParserRuleCall_0_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_4() { return cRightParenthesisKeyword_0_4; }
		
		//{AllShortestPaths} 'ALLSHORTESTPATHS' '(' patternElement=PatternElement ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//{AllShortestPaths}
		public Action getAllShortestPathsAction_1_0() { return cAllShortestPathsAction_1_0; }
		
		//'ALLSHORTESTPATHS'
		public Keyword getALLSHORTESTPATHSKeyword_1_1() { return cALLSHORTESTPATHSKeyword_1_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }
		
		//patternElement=PatternElement
		public Assignment getPatternElementAssignment_1_3() { return cPatternElementAssignment_1_3; }
		
		//PatternElement
		public RuleCall getPatternElementPatternElementParserRuleCall_1_3_0() { return cPatternElementPatternElementParserRuleCall_1_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_4() { return cRightParenthesisKeyword_1_4; }
	}
	public class PatternElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PatternElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cNodepatternAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cNodepatternNodePatternParserRuleCall_0_0_0 = (RuleCall)cNodepatternAssignment_0_0.eContents().get(0);
		private final Assignment cChainAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cChainPatternElementChainParserRuleCall_0_1_0 = (RuleCall)cChainAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cPatternElementParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PatternElement:
		//	nodepattern=NodePattern chain+=PatternElementChain* | '(' PatternElement ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * patternElement : ( nodePattern ( ws patternElementChain )* )
		// *                | ( '(' patternElement ')' );
		// */ nodepattern=NodePattern chain+=PatternElementChain* | '(' PatternElement ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * patternElement : ( nodePattern ( ws patternElementChain )* )
		// *                | ( '(' patternElement ')' );
		// */ nodepattern=NodePattern chain+=PatternElementChain*
		public Group getGroup_0() { return cGroup_0; }
		
		//nodepattern=NodePattern
		public Assignment getNodepatternAssignment_0_0() { return cNodepatternAssignment_0_0; }
		
		//NodePattern
		public RuleCall getNodepatternNodePatternParserRuleCall_0_0_0() { return cNodepatternNodePatternParserRuleCall_0_0_0; }
		
		//chain+=PatternElementChain*
		public Assignment getChainAssignment_0_1() { return cChainAssignment_0_1; }
		
		//PatternElementChain
		public RuleCall getChainPatternElementChainParserRuleCall_0_1_0() { return cChainPatternElementChainParserRuleCall_0_1_0; }
		
		//'(' PatternElement ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//PatternElement
		public RuleCall getPatternElementParserRuleCall_1_1() { return cPatternElementParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class NodePatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.NodePattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodePatternAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_2_0 = (RuleCall)cVariableAssignment_2.eContents().get(0);
		private final Assignment cNodeLabelsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNodeLabelsNodeLabelsParserRuleCall_3_0 = (RuleCall)cNodeLabelsAssignment_3.eContents().get(0);
		private final Assignment cPropertiesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPropertiesPropertiesParserRuleCall_4_0 = (RuleCall)cPropertiesAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//NodePattern:
		//	{NodePattern} '(' variable=VariableDeclaration? nodeLabels=NodeLabels? properties=Properties? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{NodePattern} '(' variable=VariableDeclaration? nodeLabels=NodeLabels? properties=Properties? ')'
		public Group getGroup() { return cGroup; }
		
		//{NodePattern}
		public Action getNodePatternAction_0() { return cNodePatternAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//variable=VariableDeclaration?
		public Assignment getVariableAssignment_2() { return cVariableAssignment_2; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_2_0() { return cVariableVariableDeclarationParserRuleCall_2_0; }
		
		//nodeLabels=NodeLabels?
		public Assignment getNodeLabelsAssignment_3() { return cNodeLabelsAssignment_3; }
		
		//NodeLabels
		public RuleCall getNodeLabelsNodeLabelsParserRuleCall_3_0() { return cNodeLabelsNodeLabelsParserRuleCall_3_0; }
		
		//properties=Properties?
		public Assignment getPropertiesAssignment_4() { return cPropertiesAssignment_4; }
		
		//Properties
		public RuleCall getPropertiesPropertiesParserRuleCall_4_0() { return cPropertiesPropertiesParserRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class PatternElementChainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PatternElementChain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRelationshipPatternAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRelationshipPatternRelationshipPatternParserRuleCall_0_0 = (RuleCall)cRelationshipPatternAssignment_0.eContents().get(0);
		private final Assignment cNodePatternAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNodePatternNodePatternParserRuleCall_1_0 = (RuleCall)cNodePatternAssignment_1.eContents().get(0);
		
		//PatternElementChain:
		//	relationshipPattern=RelationshipPattern nodePattern=NodePattern;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * patternElementChain : relationshipPattern ws nodePattern ;
		// */ relationshipPattern=RelationshipPattern nodePattern=NodePattern
		public Group getGroup() { return cGroup; }
		
		///*
		// * patternElementChain : relationshipPattern ws nodePattern ;
		// */ relationshipPattern=RelationshipPattern
		public Assignment getRelationshipPatternAssignment_0() { return cRelationshipPatternAssignment_0; }
		
		//RelationshipPattern
		public RuleCall getRelationshipPatternRelationshipPatternParserRuleCall_0_0() { return cRelationshipPatternRelationshipPatternParserRuleCall_0_0; }
		
		//nodePattern=NodePattern
		public Assignment getNodePatternAssignment_1() { return cNodePatternAssignment_1; }
		
		//NodePattern
		public RuleCall getNodePatternNodePatternParserRuleCall_1_0() { return cNodePatternNodePatternParserRuleCall_1_0; }
	}
	public class RelationshipPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelationshipPattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRelationshipPatternAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cIncomingAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cIncomingLeftArrowHeadParserRuleCall_1_0_0 = (RuleCall)cIncomingAssignment_1_0.eContents().get(0);
		private final RuleCall cDashParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cDetailAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cDetailRelationshipDetailParserRuleCall_1_2_0 = (RuleCall)cDetailAssignment_1_2.eContents().get(0);
		private final RuleCall cDashParserRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Assignment cOutgoingAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cOutgoingRightArrowHeadParserRuleCall_1_4_0 = (RuleCall)cOutgoingAssignment_1_4.eContents().get(0);
		
		//RelationshipPattern:
		//	{RelationshipPattern} (incoming?=LeftArrowHead? Dash detail=RelationshipDetail? Dash outgoing?=RightArrowHead?);
		@Override public ParserRule getRule() { return rule; }
		
		//{RelationshipPattern} (incoming?=LeftArrowHead? Dash detail=RelationshipDetail? Dash outgoing?=RightArrowHead?)
		public Group getGroup() { return cGroup; }
		
		//{RelationshipPattern}
		public Action getRelationshipPatternAction_0() { return cRelationshipPatternAction_0; }
		
		//incoming?=LeftArrowHead? Dash detail=RelationshipDetail? Dash outgoing?=RightArrowHead?
		public Group getGroup_1() { return cGroup_1; }
		
		//incoming?=LeftArrowHead?
		public Assignment getIncomingAssignment_1_0() { return cIncomingAssignment_1_0; }
		
		//LeftArrowHead
		public RuleCall getIncomingLeftArrowHeadParserRuleCall_1_0_0() { return cIncomingLeftArrowHeadParserRuleCall_1_0_0; }
		
		//Dash
		public RuleCall getDashParserRuleCall_1_1() { return cDashParserRuleCall_1_1; }
		
		//detail=RelationshipDetail?
		public Assignment getDetailAssignment_1_2() { return cDetailAssignment_1_2; }
		
		//RelationshipDetail
		public RuleCall getDetailRelationshipDetailParserRuleCall_1_2_0() { return cDetailRelationshipDetailParserRuleCall_1_2_0; }
		
		//Dash
		public RuleCall getDashParserRuleCall_1_3() { return cDashParserRuleCall_1_3; }
		
		//outgoing?=RightArrowHead?
		public Assignment getOutgoingAssignment_1_4() { return cOutgoingAssignment_1_4; }
		
		//RightArrowHead
		public RuleCall getOutgoingRightArrowHeadParserRuleCall_1_4_0() { return cOutgoingRightArrowHeadParserRuleCall_1_4_0; }
	}
	public class RelationshipDetailElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelationshipDetail");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRelationshipDetailAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_2_0 = (RuleCall)cVariableAssignment_2.eContents().get(0);
		private final Assignment cOptionalAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cOptionalQuestionMarkKeyword_3_0 = (Keyword)cOptionalAssignment_3.eContents().get(0);
		private final Assignment cTypesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypesRelationshipTypesParserRuleCall_4_0 = (RuleCall)cTypesAssignment_4.eContents().get(0);
		private final Assignment cRangeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cRangeRangeLiteralParserRuleCall_5_0 = (RuleCall)cRangeAssignment_5.eContents().get(0);
		private final Assignment cPropertiesAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPropertiesPropertiesParserRuleCall_6_0 = (RuleCall)cPropertiesAssignment_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//RelationshipDetail:
		//	{RelationshipDetail} '[' variable=VariableDeclaration? optional?='?'? types=RelationshipTypes? range=RangeLiteral?
		//	properties=Properties? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{RelationshipDetail} '[' variable=VariableDeclaration? optional?='?'? types=RelationshipTypes? range=RangeLiteral?
		//properties=Properties? ']'
		public Group getGroup() { return cGroup; }
		
		//{RelationshipDetail}
		public Action getRelationshipDetailAction_0() { return cRelationshipDetailAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//variable=VariableDeclaration?
		public Assignment getVariableAssignment_2() { return cVariableAssignment_2; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_2_0() { return cVariableVariableDeclarationParserRuleCall_2_0; }
		
		//optional?='?'?
		public Assignment getOptionalAssignment_3() { return cOptionalAssignment_3; }
		
		//'?'
		public Keyword getOptionalQuestionMarkKeyword_3_0() { return cOptionalQuestionMarkKeyword_3_0; }
		
		//types=RelationshipTypes?
		public Assignment getTypesAssignment_4() { return cTypesAssignment_4; }
		
		//RelationshipTypes
		public RuleCall getTypesRelationshipTypesParserRuleCall_4_0() { return cTypesRelationshipTypesParserRuleCall_4_0; }
		
		//range=RangeLiteral?
		public Assignment getRangeAssignment_5() { return cRangeAssignment_5; }
		
		//RangeLiteral
		public RuleCall getRangeRangeLiteralParserRuleCall_5_0() { return cRangeRangeLiteralParserRuleCall_5_0; }
		
		//properties=Properties?
		public Assignment getPropertiesAssignment_6() { return cPropertiesAssignment_6; }
		
		//Properties
		public RuleCall getPropertiesPropertiesParserRuleCall_6_0() { return cPropertiesPropertiesParserRuleCall_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7() { return cRightSquareBracketKeyword_7; }
	}
	public class PropertiesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Properties");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMapLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLegacyParameterParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Properties:
		//	MapLiteral | Parameter | LegacyParameter;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * properties : mapLiteral
		// *            | parameter
		// *            | legacyParameter
		// *            ;
		// */ MapLiteral | Parameter | LegacyParameter
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * properties : mapLiteral
		// *            | parameter
		// *            | legacyParameter
		// *            ;
		// */ MapLiteral
		public RuleCall getMapLiteralParserRuleCall_0() { return cMapLiteralParserRuleCall_0; }
		
		//Parameter
		public RuleCall getParameterParserRuleCall_1() { return cParameterParserRuleCall_1; }
		
		//LegacyParameter
		public RuleCall getLegacyParameterParserRuleCall_2() { return cLegacyParameterParserRuleCall_2; }
	}
	public class RelTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cRelTypeNameParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//RelType: /*
		// * relType : ':' relTypeName ;
		// */ ':' RelTypeName;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * relType : ':' relTypeName ;
		// */ ':' RelTypeName
		public Group getGroup() { return cGroup; }
		
		///*
		// * relType : ':' relTypeName ;
		// */ ':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//RelTypeName
		public RuleCall getRelTypeNameParserRuleCall_1() { return cRelTypeNameParserRuleCall_1; }
	}
	public class RelationshipTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelationshipTypes");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRelTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelTypeNameRelTypeNameParserRuleCall_1_0 = (RuleCall)cRelTypeNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cVerticalLineKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cColonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cRelTypeNameAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cRelTypeNameRelTypeNameParserRuleCall_2_2_0 = (RuleCall)cRelTypeNameAssignment_2_2.eContents().get(0);
		
		//RelationshipTypes: /*
		// * relationshipTypes : ':' relTypeName ( ws '|' ':'? ws relTypeName )* ;
		// */ ':' relTypeName+=RelTypeName ('|' ':'? relTypeName+=RelTypeName)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * relationshipTypes : ':' relTypeName ( ws '|' ':'? ws relTypeName )* ;
		// */ ':' relTypeName+=RelTypeName ('|' ':'? relTypeName+=RelTypeName)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * relationshipTypes : ':' relTypeName ( ws '|' ':'? ws relTypeName )* ;
		// */ ':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//relTypeName+=RelTypeName
		public Assignment getRelTypeNameAssignment_1() { return cRelTypeNameAssignment_1; }
		
		//RelTypeName
		public RuleCall getRelTypeNameRelTypeNameParserRuleCall_1_0() { return cRelTypeNameRelTypeNameParserRuleCall_1_0; }
		
		//('|' ':'? relTypeName+=RelTypeName)*
		public Group getGroup_2() { return cGroup_2; }
		
		//'|'
		public Keyword getVerticalLineKeyword_2_0() { return cVerticalLineKeyword_2_0; }
		
		//':'?
		public Keyword getColonKeyword_2_1() { return cColonKeyword_2_1; }
		
		//relTypeName+=RelTypeName
		public Assignment getRelTypeNameAssignment_2_2() { return cRelTypeNameAssignment_2_2; }
		
		//RelTypeName
		public RuleCall getRelTypeNameRelTypeNameParserRuleCall_2_2_0() { return cRelTypeNameRelTypeNameParserRuleCall_2_2_0; }
	}
	public class NodeLabelsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.NodeLabels");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodeLabelsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNodeLabelsNodeLabelParserRuleCall_0_0 = (RuleCall)cNodeLabelsAssignment_0.eContents().get(0);
		private final Assignment cNodeLabelsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNodeLabelsNodeLabelParserRuleCall_1_0 = (RuleCall)cNodeLabelsAssignment_1.eContents().get(0);
		
		//NodeLabels:
		//	nodeLabels+=NodeLabel nodeLabels+=NodeLabel*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * nodeLabels : nodeLabel ( ws nodeLabel )* ;
		// */ nodeLabels+=NodeLabel nodeLabels+=NodeLabel*
		public Group getGroup() { return cGroup; }
		
		///*
		// * nodeLabels : nodeLabel ( ws nodeLabel )* ;
		// */ nodeLabels+=NodeLabel
		public Assignment getNodeLabelsAssignment_0() { return cNodeLabelsAssignment_0; }
		
		//NodeLabel
		public RuleCall getNodeLabelsNodeLabelParserRuleCall_0_0() { return cNodeLabelsNodeLabelParserRuleCall_0_0; }
		
		//nodeLabels+=NodeLabel*
		public Assignment getNodeLabelsAssignment_1() { return cNodeLabelsAssignment_1; }
		
		//NodeLabel
		public RuleCall getNodeLabelsNodeLabelParserRuleCall_1_0() { return cNodeLabelsNodeLabelParserRuleCall_1_0; }
	}
	public class NodeLabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.NodeLabel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLabelNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLabelNameLabelNameParserRuleCall_1_0 = (RuleCall)cLabelNameAssignment_1.eContents().get(0);
		
		//NodeLabel: /*
		// * nodeLabel : ':' labelName ;
		// */ ':' labelName=LabelName;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * nodeLabel : ':' labelName ;
		// */ ':' labelName=LabelName
		public Group getGroup() { return cGroup; }
		
		///*
		// * nodeLabel : ':' labelName ;
		// */ ':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//labelName=LabelName
		public Assignment getLabelNameAssignment_1() { return cLabelNameAssignment_1; }
		
		//LabelName
		public RuleCall getLabelNameLabelNameParserRuleCall_1_0() { return cLabelNameLabelNameParserRuleCall_1_0; }
	}
	public class RangeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RangeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRangeLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cLowerAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cLowerNumberParserRuleCall_2_0_0 = (RuleCall)cLowerAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cUpperAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cUpperNumberParserRuleCall_2_1_1_0 = (RuleCall)cUpperAssignment_2_1_1.eContents().get(0);
		
		//RangeLiteral:
		//	{RangeLiteral} '*' (lower=Number? ('..' upper=Number?)?)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{RangeLiteral} '*' (lower=Number? ('..' upper=Number?)?)?
		public Group getGroup() { return cGroup; }
		
		//{RangeLiteral}
		public Action getRangeLiteralAction_0() { return cRangeLiteralAction_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
		
		//(lower=Number? ('..' upper=Number?)?)?
		public Group getGroup_2() { return cGroup_2; }
		
		//lower=Number?
		public Assignment getLowerAssignment_2_0() { return cLowerAssignment_2_0; }
		
		//Number
		public RuleCall getLowerNumberParserRuleCall_2_0_0() { return cLowerNumberParserRuleCall_2_0_0; }
		
		//('..' upper=Number?)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_2_1_0() { return cFullStopFullStopKeyword_2_1_0; }
		
		//upper=Number?
		public Assignment getUpperAssignment_2_1_1() { return cUpperAssignment_2_1_1; }
		
		//Number
		public RuleCall getUpperNumberParserRuleCall_2_1_1_0() { return cUpperNumberParserRuleCall_2_1_1_0; }
	}
	public class LabelNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.LabelName");
		private final RuleCall cSYMBOLIC_NAME_XParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LabelName:
		//	SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * labelName : symbolicName ;
		// */ SYMBOLIC_NAME_X
		public RuleCall getSYMBOLIC_NAME_XParserRuleCall() { return cSYMBOLIC_NAME_XParserRuleCall; }
	}
	public class RelTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelTypeName");
		private final RuleCall cSYMBOLIC_NAME_XParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//RelTypeName:
		//	SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * relTypeName : symbolicName ;
		// */ SYMBOLIC_NAME_X
		public RuleCall getSYMBOLIC_NAME_XParserRuleCall() { return cSYMBOLIC_NAME_XParserRuleCall; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Expression");
		private final RuleCall cExpressionOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	ExpressionOr;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression : expression12 ;
		// */ ExpressionOr
		public RuleCall getExpressionOrParserRuleCall() { return cExpressionOrParserRuleCall; }
	}
	public class ExpressionOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorORKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExpressionOr Expression:
		//	ExpressionXor ({ExpressionOr.left=current} operator='OR' right=ExpressionXor)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression12 : expression11 ( sp OR sp expression11 )* ;
		// */ ExpressionXor ({ExpressionOr.left=current} operator='OR' right=ExpressionXor)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression12 : expression11 ( sp OR sp expression11 )* ;
		// */ ExpressionXor
		public RuleCall getExpressionXorParserRuleCall_0() { return cExpressionXorParserRuleCall_0; }
		
		//({ExpressionOr.left=current} operator='OR' right=ExpressionXor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionOr.left=current}
		public Action getExpressionOrLeftAction_1_0() { return cExpressionOrLeftAction_1_0; }
		
		//operator='OR'
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//'OR'
		public Keyword getOperatorORKeyword_1_1_0() { return cOperatorORKeyword_1_1_0; }
		
		//right=ExpressionXor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpressionXor
		public RuleCall getRightExpressionXorParserRuleCall_1_2_0() { return cRightExpressionXorParserRuleCall_1_2_0; }
	}
	public class ExpressionXorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionXor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorXORKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExpressionXor Expression:
		//	ExpressionAnd ({ExpressionXor.left=current} operator='XOR' right=ExpressionAnd)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression11 : expression10 ( sp XOR sp expression10 )* ;
		// */ ExpressionAnd ({ExpressionXor.left=current} operator='XOR' right=ExpressionAnd)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression11 : expression10 ( sp XOR sp expression10 )* ;
		// */ ExpressionAnd
		public RuleCall getExpressionAndParserRuleCall_0() { return cExpressionAndParserRuleCall_0; }
		
		//({ExpressionXor.left=current} operator='XOR' right=ExpressionAnd)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionXor.left=current}
		public Action getExpressionXorLeftAction_1_0() { return cExpressionXorLeftAction_1_0; }
		
		//operator='XOR'
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//'XOR'
		public Keyword getOperatorXORKeyword_1_1_0() { return cOperatorXORKeyword_1_1_0; }
		
		//right=ExpressionAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpressionAnd
		public RuleCall getRightExpressionAndParserRuleCall_1_2_0() { return cRightExpressionAndParserRuleCall_1_2_0; }
	}
	public class ExpressionAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionNotParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorANDKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionNotParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExpressionAnd Expression:
		//	ExpressionNot ({ExpressionAnd.left=current} operator='AND' right=ExpressionNot)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression10 : expression9 ( sp AND sp expression9 )* ;
		// */ ExpressionNot ({ExpressionAnd.left=current} operator='AND' right=ExpressionNot)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression10 : expression9 ( sp AND sp expression9 )* ;
		// */ ExpressionNot
		public RuleCall getExpressionNotParserRuleCall_0() { return cExpressionNotParserRuleCall_0; }
		
		//({ExpressionAnd.left=current} operator='AND' right=ExpressionNot)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionAnd.left=current}
		public Action getExpressionAndLeftAction_1_0() { return cExpressionAndLeftAction_1_0; }
		
		//operator='AND'
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//'AND'
		public Keyword getOperatorANDKeyword_1_1_0() { return cOperatorANDKeyword_1_1_0; }
		
		//right=ExpressionNot
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpressionNot
		public RuleCall getRightExpressionNotParserRuleCall_1_2_0() { return cRightExpressionNotParserRuleCall_1_2_0; }
	}
	public class ExpressionNotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionNot");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cExpressionNotAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cOperatorNOTKeyword_0_1_0 = (Keyword)cOperatorAssignment_0_1.eContents().get(0);
		private final Assignment cLeftAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cLeftExpressionNotParserRuleCall_0_2_0 = (RuleCall)cLeftAssignment_0_2.eContents().get(0);
		private final RuleCall cExpressionComparisonParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ExpressionNot Expression:
		//	{ExpressionNot} operator='NOT' left=ExpressionNot | ExpressionComparison;
		@Override public ParserRule getRule() { return rule; }
		
		//{ExpressionNot} operator='NOT' left=ExpressionNot | ExpressionComparison
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ExpressionNot} operator='NOT' left=ExpressionNot
		public Group getGroup_0() { return cGroup_0; }
		
		//{ExpressionNot}
		public Action getExpressionNotAction_0_0() { return cExpressionNotAction_0_0; }
		
		//operator='NOT'
		public Assignment getOperatorAssignment_0_1() { return cOperatorAssignment_0_1; }
		
		//'NOT'
		public Keyword getOperatorNOTKeyword_0_1_0() { return cOperatorNOTKeyword_0_1_0; }
		
		//left=ExpressionNot
		public Assignment getLeftAssignment_0_2() { return cLeftAssignment_0_2; }
		
		//ExpressionNot
		public RuleCall getLeftExpressionNotParserRuleCall_0_2_0() { return cLeftExpressionNotParserRuleCall_0_2_0; }
		
		//ExpressionComparison
		public RuleCall getExpressionComparisonParserRuleCall_1() { return cExpressionComparisonParserRuleCall_1; }
	}
	public class ExpressionComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionPlusMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorEqualsSignKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorLessThanSignGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOperatorLessThanSignKeyword_1_1_0_2 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOperatorGreaterThanSignKeyword_1_1_0_3 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(3);
		private final Keyword cOperatorLessThanSignEqualsSignKeyword_1_1_0_4 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(4);
		private final Keyword cOperatorGreaterThanSignEqualsSignKeyword_1_1_0_5 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(5);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionPlusMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExpressionComparison Expression:
		//	ExpressionPlusMinus ({ExpressionComparison.left=current} operator=('=' | '<>' | '<' | '>' | '<=' | '>=')
		//	right=ExpressionPlusMinus)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression8 : expression7 ( ws partialComparisonExpression )* ;
		// * 
		// * partialComparisonExpression : ( '=' ws expression7 )
		// *                             | ( '<>' ws expression7 )
		// *                             | ( '<' ws expression7 )
		// *                             | ( '>' ws expression7 )
		// *                             | ( '<=' ws expression7 )
		// *                             | ( '>=' ws expression7 );
		// * 
		// * Comment: combined clause for 'expression8' and 'partialComparisonExpression'
		// */ ExpressionPlusMinus ({ExpressionComparison.left=current} operator=('=' | '<>' | '<' | '>' | '<=' | '>=')
		//right=ExpressionPlusMinus)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression8 : expression7 ( ws partialComparisonExpression )* ;
		// * 
		// * partialComparisonExpression : ( '=' ws expression7 )
		// *                             | ( '<>' ws expression7 )
		// *                             | ( '<' ws expression7 )
		// *                             | ( '>' ws expression7 )
		// *                             | ( '<=' ws expression7 )
		// *                             | ( '>=' ws expression7 );
		// * 
		// * Comment: combined clause for 'expression8' and 'partialComparisonExpression'
		// */ ExpressionPlusMinus
		public RuleCall getExpressionPlusMinusParserRuleCall_0() { return cExpressionPlusMinusParserRuleCall_0; }
		
		//({ExpressionComparison.left=current} operator=('=' | '<>' | '<' | '>' | '<=' | '>=') right=ExpressionPlusMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionComparison.left=current}
		public Action getExpressionComparisonLeftAction_1_0() { return cExpressionComparisonLeftAction_1_0; }
		
		//operator=('=' | '<>' | '<' | '>' | '<=' | '>=')
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//('=' | '<>' | '<' | '>' | '<=' | '>=')
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }
		
		//'='
		public Keyword getOperatorEqualsSignKeyword_1_1_0_0() { return cOperatorEqualsSignKeyword_1_1_0_0; }
		
		//'<>'
		public Keyword getOperatorLessThanSignGreaterThanSignKeyword_1_1_0_1() { return cOperatorLessThanSignGreaterThanSignKeyword_1_1_0_1; }
		
		//'<'
		public Keyword getOperatorLessThanSignKeyword_1_1_0_2() { return cOperatorLessThanSignKeyword_1_1_0_2; }
		
		//'>'
		public Keyword getOperatorGreaterThanSignKeyword_1_1_0_3() { return cOperatorGreaterThanSignKeyword_1_1_0_3; }
		
		//'<='
		public Keyword getOperatorLessThanSignEqualsSignKeyword_1_1_0_4() { return cOperatorLessThanSignEqualsSignKeyword_1_1_0_4; }
		
		//'>='
		public Keyword getOperatorGreaterThanSignEqualsSignKeyword_1_1_0_5() { return cOperatorGreaterThanSignEqualsSignKeyword_1_1_0_5; }
		
		//right=ExpressionPlusMinus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpressionPlusMinus
		public RuleCall getRightExpressionPlusMinusParserRuleCall_1_2_0() { return cRightExpressionPlusMinusParserRuleCall_1_2_0; }
	}
	public class ExpressionPlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionPlusMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionMulDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionPlusMinusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorPlusSignKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorHyphenMinusKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionMulDivParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExpressionPlusMinus Expression:
		//	ExpressionMulDiv ({ExpressionPlusMinus.left=current} operator=('+' | '-') right=ExpressionMulDiv)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression7 : expression6 ( ( ws '+' ws expression6 ) | ( ws '-' ws expression6 ) )* ;
		// */ ExpressionMulDiv ({ExpressionPlusMinus.left=current} operator=('+' | '-') right=ExpressionMulDiv)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression7 : expression6 ( ( ws '+' ws expression6 ) | ( ws '-' ws expression6 ) )* ;
		// */ ExpressionMulDiv
		public RuleCall getExpressionMulDivParserRuleCall_0() { return cExpressionMulDivParserRuleCall_0; }
		
		//({ExpressionPlusMinus.left=current} operator=('+' | '-') right=ExpressionMulDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionPlusMinus.left=current}
		public Action getExpressionPlusMinusLeftAction_1_0() { return cExpressionPlusMinusLeftAction_1_0; }
		
		//operator=('+' | '-')
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//('+' | '-')
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }
		
		//'+'
		public Keyword getOperatorPlusSignKeyword_1_1_0_0() { return cOperatorPlusSignKeyword_1_1_0_0; }
		
		//'-'
		public Keyword getOperatorHyphenMinusKeyword_1_1_0_1() { return cOperatorHyphenMinusKeyword_1_1_0_1; }
		
		//right=ExpressionMulDiv
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpressionMulDiv
		public RuleCall getRightExpressionMulDivParserRuleCall_1_2_0() { return cRightExpressionMulDivParserRuleCall_1_2_0; }
	}
	public class ExpressionMulDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionMulDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionPowerParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionMulDivLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorAsteriskKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorSolidusKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOperatorPercentSignKeyword_1_1_0_2 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionPowerParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExpressionMulDiv Expression:
		//	ExpressionPower ({ExpressionMulDiv.left=current} operator=('*' | '/' | '%') right=ExpressionPower)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression6 : expression5 ( ( ws '*' ws expression5 ) | ( ws '/' ws expression5 ) | ( ws '%' ws expression5 ) )* ;
		// */ ExpressionPower ({ExpressionMulDiv.left=current} operator=('*' | '/' | '%') right=ExpressionPower)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression6 : expression5 ( ( ws '*' ws expression5 ) | ( ws '/' ws expression5 ) | ( ws '%' ws expression5 ) )* ;
		// */ ExpressionPower
		public RuleCall getExpressionPowerParserRuleCall_0() { return cExpressionPowerParserRuleCall_0; }
		
		//({ExpressionMulDiv.left=current} operator=('*' | '/' | '%') right=ExpressionPower)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionMulDiv.left=current}
		public Action getExpressionMulDivLeftAction_1_0() { return cExpressionMulDivLeftAction_1_0; }
		
		//operator=('*' | '/' | '%')
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//('*' | '/' | '%')
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }
		
		//'*'
		public Keyword getOperatorAsteriskKeyword_1_1_0_0() { return cOperatorAsteriskKeyword_1_1_0_0; }
		
		//'/'
		public Keyword getOperatorSolidusKeyword_1_1_0_1() { return cOperatorSolidusKeyword_1_1_0_1; }
		
		//'%'
		public Keyword getOperatorPercentSignKeyword_1_1_0_2() { return cOperatorPercentSignKeyword_1_1_0_2; }
		
		//right=ExpressionPower
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpressionPower
		public RuleCall getRightExpressionPowerParserRuleCall_1_2_0() { return cRightExpressionPowerParserRuleCall_1_2_0; }
	}
	public class ExpressionPowerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionPower");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionUnaryPlusMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionPowerLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorCircumflexAccentKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpressionUnaryPlusMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExpressionPower Expression:
		//	ExpressionUnaryPlusMinus ({ExpressionPower.left=current} operator='^' right=ExpressionUnaryPlusMinus)*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression5 : expression4 ( ws '^' ws expression4 )* ;
		// */ ExpressionUnaryPlusMinus ({ExpressionPower.left=current} operator='^' right=ExpressionUnaryPlusMinus)*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression5 : expression4 ( ws '^' ws expression4 )* ;
		// */ ExpressionUnaryPlusMinus
		public RuleCall getExpressionUnaryPlusMinusParserRuleCall_0() { return cExpressionUnaryPlusMinusParserRuleCall_0; }
		
		//({ExpressionPower.left=current} operator='^' right=ExpressionUnaryPlusMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionPower.left=current}
		public Action getExpressionPowerLeftAction_1_0() { return cExpressionPowerLeftAction_1_0; }
		
		//operator='^'
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//'^'
		public Keyword getOperatorCircumflexAccentKeyword_1_1_0() { return cOperatorCircumflexAccentKeyword_1_1_0; }
		
		//right=ExpressionUnaryPlusMinus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpressionUnaryPlusMinus
		public RuleCall getRightExpressionUnaryPlusMinusParserRuleCall_1_2_0() { return cRightExpressionUnaryPlusMinusParserRuleCall_1_2_0; }
	}
	public class ExpressionUnaryPlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionUnaryPlusMinus");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpression3ParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cExpressionUnaryPlusMinusAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorPlusSignKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorHyphenMinusKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Assignment cLeftAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cLeftExpressionUnaryPlusMinusParserRuleCall_1_2_0 = (RuleCall)cLeftAssignment_1_2.eContents().get(0);
		
		//ExpressionUnaryPlusMinus Expression:
		//	Expression3 | {ExpressionUnaryPlusMinus} operator=('+' | '-') left=ExpressionUnaryPlusMinus;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression4 : ( ( '+' | '-' ) ws )* expression3 ;
		// * 
		// * Comment: In order to restrict our model for a single operator at a time, clause is modeled after a rewritetten form of the antlr clause 'expression4 : expression3 | ( ( '+' | '-' ) ws ) expression4;'
		// */ Expression3 | {ExpressionUnaryPlusMinus} operator=('+' | '-') left=ExpressionUnaryPlusMinus
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * expression4 : ( ( '+' | '-' ) ws )* expression3 ;
		// * 
		// * Comment: In order to restrict our model for a single operator at a time, clause is modeled after a rewritetten form of the antlr clause 'expression4 : expression3 | ( ( '+' | '-' ) ws ) expression4;'
		// */ Expression3
		public RuleCall getExpression3ParserRuleCall_0() { return cExpression3ParserRuleCall_0; }
		
		//{ExpressionUnaryPlusMinus} operator=('+' | '-') left=ExpressionUnaryPlusMinus
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionUnaryPlusMinus}
		public Action getExpressionUnaryPlusMinusAction_1_0() { return cExpressionUnaryPlusMinusAction_1_0; }
		
		//operator=('+' | '-')
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//('+' | '-')
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }
		
		//'+'
		public Keyword getOperatorPlusSignKeyword_1_1_0_0() { return cOperatorPlusSignKeyword_1_1_0_0; }
		
		//'-'
		public Keyword getOperatorHyphenMinusKeyword_1_1_0_1() { return cOperatorHyphenMinusKeyword_1_1_0_1; }
		
		//left=ExpressionUnaryPlusMinus
		public Assignment getLeftAssignment_1_2() { return cLeftAssignment_1_2; }
		
		//ExpressionUnaryPlusMinus
		public RuleCall getLeftExpressionUnaryPlusMinusParserRuleCall_1_2_0() { return cLeftExpressionUnaryPlusMinusParserRuleCall_1_2_0; }
	}
	public class Expression3Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Expression3");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionNodeLabelsAndPropertyLookupParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cIndexExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cExpressionAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0_2_0 = (RuleCall)cExpressionAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_0_3 = (Group)cGroup_1_0.eContents().get(3);
		private final Keyword cFullStopFullStopKeyword_1_0_3_0 = (Keyword)cGroup_1_0_3.eContents().get(0);
		private final Assignment cUpperAssignment_1_0_3_1 = (Assignment)cGroup_1_0_3.eContents().get(1);
		private final RuleCall cUpperExpressionParserRuleCall_1_0_3_1_0 = (RuleCall)cUpperAssignment_1_0_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_0_4 = (Keyword)cGroup_1_0.eContents().get(4);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cRegExpMatchingExpressionLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cEqualsSignTildeKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cInCollectionExpressionLeftAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cINKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cRightAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_2_2_0 = (RuleCall)cRightAssignment_1_2_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final Action cStartsWithExpressionLeftAction_1_3_0 = (Action)cGroup_1_3.eContents().get(0);
		private final Keyword cSTARTSKeyword_1_3_1 = (Keyword)cGroup_1_3.eContents().get(1);
		private final Keyword cWITHKeyword_1_3_2 = (Keyword)cGroup_1_3.eContents().get(2);
		private final Assignment cRightAssignment_1_3_3 = (Assignment)cGroup_1_3.eContents().get(3);
		private final RuleCall cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_3_3_0 = (RuleCall)cRightAssignment_1_3_3.eContents().get(0);
		private final Group cGroup_1_4 = (Group)cAlternatives_1.eContents().get(4);
		private final Action cEndsWithExpressionLeftAction_1_4_0 = (Action)cGroup_1_4.eContents().get(0);
		private final Keyword cENDSKeyword_1_4_1 = (Keyword)cGroup_1_4.eContents().get(1);
		private final Keyword cWITHKeyword_1_4_2 = (Keyword)cGroup_1_4.eContents().get(2);
		private final Assignment cRightAssignment_1_4_3 = (Assignment)cGroup_1_4.eContents().get(3);
		private final RuleCall cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_4_3_0 = (RuleCall)cRightAssignment_1_4_3.eContents().get(0);
		private final Group cGroup_1_5 = (Group)cAlternatives_1.eContents().get(5);
		private final Action cContainsExpressionLeftAction_1_5_0 = (Action)cGroup_1_5.eContents().get(0);
		private final Keyword cCONTAINSKeyword_1_5_1 = (Keyword)cGroup_1_5.eContents().get(1);
		private final Assignment cRightAssignment_1_5_2 = (Assignment)cGroup_1_5.eContents().get(2);
		private final RuleCall cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_5_2_0 = (RuleCall)cRightAssignment_1_5_2.eContents().get(0);
		private final Group cGroup_1_6 = (Group)cAlternatives_1.eContents().get(6);
		private final Action cIsNullExpressionLeftAction_1_6_0 = (Action)cGroup_1_6.eContents().get(0);
		private final Keyword cISKeyword_1_6_1 = (Keyword)cGroup_1_6.eContents().get(1);
		private final Keyword cNULLKeyword_1_6_2 = (Keyword)cGroup_1_6.eContents().get(2);
		private final Group cGroup_1_7 = (Group)cAlternatives_1.eContents().get(7);
		private final Action cIsNotNullExpressionLeftAction_1_7_0 = (Action)cGroup_1_7.eContents().get(0);
		private final Keyword cISKeyword_1_7_1 = (Keyword)cGroup_1_7.eContents().get(1);
		private final Keyword cNOTKeyword_1_7_2 = (Keyword)cGroup_1_7.eContents().get(2);
		private final Keyword cNULLKeyword_1_7_3 = (Keyword)cGroup_1_7.eContents().get(3);
		
		//Expression3 Expression:
		//	ExpressionNodeLabelsAndPropertyLookup ({IndexExpression.left=current} '[' expression=Expression ('..'
		//	upper=Expression)? ']' | {RegExpMatchingExpression.left=current} '=~'
		//	right=ExpressionNodeLabelsAndPropertyLookup | {InCollectionExpression.left=current} 'IN'
		//	right=ExpressionNodeLabelsAndPropertyLookup | {StartsWithExpression.left=current} 'STARTS' 'WITH'
		//	right=ExpressionNodeLabelsAndPropertyLookup | {EndsWithExpression.left=current} 'ENDS' 'WITH'
		//	right=ExpressionNodeLabelsAndPropertyLookup | {ContainsExpression.left=current} 'CONTAINS'
		//	right=ExpressionNodeLabelsAndPropertyLookup | {IsNullExpression.left=current} 'IS' 'NULL' |
		//	{IsNotNullExpression.left=current} 'IS' 'NOT' 'NULL')*;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * expression3 : expression2 ( ( ws '[' expression ']' ) | ( ws '[' expression? '..' expression? ']' ) | ( ( ( ws '=~' ) | ( sp IN ) | ( sp STARTS sp WITH ) | ( sp ENDS sp WITH ) | ( sp CONTAINS ) ) ws expression2 ) | ( sp IS sp NULL ) | ( sp IS sp NOT sp NULL ) )* ;
		// */ ExpressionNodeLabelsAndPropertyLookup ({IndexExpression.left=current} '[' expression=Expression ('..'
		//upper=Expression)? ']' | {RegExpMatchingExpression.left=current} '=~' right=ExpressionNodeLabelsAndPropertyLookup |
		//{InCollectionExpression.left=current} 'IN' right=ExpressionNodeLabelsAndPropertyLookup |
		//{StartsWithExpression.left=current} 'STARTS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup |
		//{EndsWithExpression.left=current} 'ENDS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup |
		//{ContainsExpression.left=current} 'CONTAINS' right=ExpressionNodeLabelsAndPropertyLookup |
		//{IsNullExpression.left=current} 'IS' 'NULL' | {IsNotNullExpression.left=current} 'IS' 'NOT' 'NULL')*
		public Group getGroup() { return cGroup; }
		
		///*
		// * expression3 : expression2 ( ( ws '[' expression ']' ) | ( ws '[' expression? '..' expression? ']' ) | ( ( ( ws '=~' ) | ( sp IN ) | ( sp STARTS sp WITH ) | ( sp ENDS sp WITH ) | ( sp CONTAINS ) ) ws expression2 ) | ( sp IS sp NULL ) | ( sp IS sp NOT sp NULL ) )* ;
		// */ ExpressionNodeLabelsAndPropertyLookup
		public RuleCall getExpressionNodeLabelsAndPropertyLookupParserRuleCall_0() { return cExpressionNodeLabelsAndPropertyLookupParserRuleCall_0; }
		
		//({IndexExpression.left=current} '[' expression=Expression ('..' upper=Expression)? ']' |
		//{RegExpMatchingExpression.left=current} '=~' right=ExpressionNodeLabelsAndPropertyLookup |
		//{InCollectionExpression.left=current} 'IN' right=ExpressionNodeLabelsAndPropertyLookup |
		//{StartsWithExpression.left=current} 'STARTS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup |
		//{EndsWithExpression.left=current} 'ENDS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup |
		//{ContainsExpression.left=current} 'CONTAINS' right=ExpressionNodeLabelsAndPropertyLookup |
		//{IsNullExpression.left=current} 'IS' 'NULL' | {IsNotNullExpression.left=current} 'IS' 'NOT' 'NULL')*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//{IndexExpression.left=current} '[' expression=Expression ('..' upper=Expression)? ']'
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{IndexExpression.left=current}
		public Action getIndexExpressionLeftAction_1_0_0() { return cIndexExpressionLeftAction_1_0_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0_1() { return cLeftSquareBracketKeyword_1_0_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1_0_2() { return cExpressionAssignment_1_0_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0_2_0() { return cExpressionExpressionParserRuleCall_1_0_2_0; }
		
		//('..' upper=Expression)?
		public Group getGroup_1_0_3() { return cGroup_1_0_3; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1_0_3_0() { return cFullStopFullStopKeyword_1_0_3_0; }
		
		//upper=Expression
		public Assignment getUpperAssignment_1_0_3_1() { return cUpperAssignment_1_0_3_1; }
		
		//Expression
		public RuleCall getUpperExpressionParserRuleCall_1_0_3_1_0() { return cUpperExpressionParserRuleCall_1_0_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_0_4() { return cRightSquareBracketKeyword_1_0_4; }
		
		//{RegExpMatchingExpression.left=current} '=~' right=ExpressionNodeLabelsAndPropertyLookup
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{RegExpMatchingExpression.left=current}
		public Action getRegExpMatchingExpressionLeftAction_1_1_0() { return cRegExpMatchingExpressionLeftAction_1_1_0; }
		
		//'=~'
		public Keyword getEqualsSignTildeKeyword_1_1_1() { return cEqualsSignTildeKeyword_1_1_1; }
		
		//right=ExpressionNodeLabelsAndPropertyLookup
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }
		
		//ExpressionNodeLabelsAndPropertyLookup
		public RuleCall getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_1_2_0() { return cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_1_2_0; }
		
		//{InCollectionExpression.left=current} 'IN' right=ExpressionNodeLabelsAndPropertyLookup
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//{InCollectionExpression.left=current}
		public Action getInCollectionExpressionLeftAction_1_2_0() { return cInCollectionExpressionLeftAction_1_2_0; }
		
		//'IN'
		public Keyword getINKeyword_1_2_1() { return cINKeyword_1_2_1; }
		
		//right=ExpressionNodeLabelsAndPropertyLookup
		public Assignment getRightAssignment_1_2_2() { return cRightAssignment_1_2_2; }
		
		//ExpressionNodeLabelsAndPropertyLookup
		public RuleCall getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_2_2_0() { return cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_2_2_0; }
		
		//{StartsWithExpression.left=current} 'STARTS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//{StartsWithExpression.left=current}
		public Action getStartsWithExpressionLeftAction_1_3_0() { return cStartsWithExpressionLeftAction_1_3_0; }
		
		//'STARTS'
		public Keyword getSTARTSKeyword_1_3_1() { return cSTARTSKeyword_1_3_1; }
		
		//'WITH'
		public Keyword getWITHKeyword_1_3_2() { return cWITHKeyword_1_3_2; }
		
		//right=ExpressionNodeLabelsAndPropertyLookup
		public Assignment getRightAssignment_1_3_3() { return cRightAssignment_1_3_3; }
		
		//ExpressionNodeLabelsAndPropertyLookup
		public RuleCall getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_3_3_0() { return cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_3_3_0; }
		
		//{EndsWithExpression.left=current} 'ENDS' 'WITH' right=ExpressionNodeLabelsAndPropertyLookup
		public Group getGroup_1_4() { return cGroup_1_4; }
		
		//{EndsWithExpression.left=current}
		public Action getEndsWithExpressionLeftAction_1_4_0() { return cEndsWithExpressionLeftAction_1_4_0; }
		
		//'ENDS'
		public Keyword getENDSKeyword_1_4_1() { return cENDSKeyword_1_4_1; }
		
		//'WITH'
		public Keyword getWITHKeyword_1_4_2() { return cWITHKeyword_1_4_2; }
		
		//right=ExpressionNodeLabelsAndPropertyLookup
		public Assignment getRightAssignment_1_4_3() { return cRightAssignment_1_4_3; }
		
		//ExpressionNodeLabelsAndPropertyLookup
		public RuleCall getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_4_3_0() { return cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_4_3_0; }
		
		//{ContainsExpression.left=current} 'CONTAINS' right=ExpressionNodeLabelsAndPropertyLookup
		public Group getGroup_1_5() { return cGroup_1_5; }
		
		//{ContainsExpression.left=current}
		public Action getContainsExpressionLeftAction_1_5_0() { return cContainsExpressionLeftAction_1_5_0; }
		
		//'CONTAINS'
		public Keyword getCONTAINSKeyword_1_5_1() { return cCONTAINSKeyword_1_5_1; }
		
		//right=ExpressionNodeLabelsAndPropertyLookup
		public Assignment getRightAssignment_1_5_2() { return cRightAssignment_1_5_2; }
		
		//ExpressionNodeLabelsAndPropertyLookup
		public RuleCall getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_5_2_0() { return cRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_5_2_0; }
		
		//{IsNullExpression.left=current} 'IS' 'NULL'
		public Group getGroup_1_6() { return cGroup_1_6; }
		
		//{IsNullExpression.left=current}
		public Action getIsNullExpressionLeftAction_1_6_0() { return cIsNullExpressionLeftAction_1_6_0; }
		
		//'IS'
		public Keyword getISKeyword_1_6_1() { return cISKeyword_1_6_1; }
		
		//'NULL'
		public Keyword getNULLKeyword_1_6_2() { return cNULLKeyword_1_6_2; }
		
		//{IsNotNullExpression.left=current} 'IS' 'NOT' 'NULL'
		public Group getGroup_1_7() { return cGroup_1_7; }
		
		//{IsNotNullExpression.left=current}
		public Action getIsNotNullExpressionLeftAction_1_7_0() { return cIsNotNullExpressionLeftAction_1_7_0; }
		
		//'IS'
		public Keyword getISKeyword_1_7_1() { return cISKeyword_1_7_1; }
		
		//'NOT'
		public Keyword getNOTKeyword_1_7_2() { return cNOTKeyword_1_7_2; }
		
		//'NULL'
		public Keyword getNULLKeyword_1_7_3() { return cNULLKeyword_1_7_3; }
	}
	public class ExpressionNodeLabelsAndPropertyLookupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExpressionNodeLabelsAndPropertyLookup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionPropertyLookupLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cPropertyLookupsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPropertyLookupsPropertyLookupParserRuleCall_1_1_0 = (RuleCall)cPropertyLookupsAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Action cExpressionNodeLabelsLeftAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cNodeLabelsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNodeLabelsNodeLabelParserRuleCall_2_1_0 = (RuleCall)cNodeLabelsAssignment_2_1.eContents().get(0);
		
		//ExpressionNodeLabelsAndPropertyLookup Expression:
		//	Atom ({ExpressionPropertyLookup.left=current} propertyLookups+=PropertyLookup+)? ({ExpressionNodeLabels.left=current}
		//	nodeLabels+=NodeLabel+)?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * this is a clarified and corrected form of openCypher spec M08 version which had ambiguity
		// * oC_PropertyOrLabelsExpression : oC_Atom ( SP? oC_PropertyLookup )* ( SP? oC_NodeLabels )?
		// *
		// * Note: we want ExpressionPropertyLookup and ExpressionNodeLabelsConstraint to
		// * appear in the AST iff property lookups and node label constraints were given, respectively
		// */ Atom ({ExpressionPropertyLookup.left=current} propertyLookups+=PropertyLookup+)?
		//({ExpressionNodeLabels.left=current} nodeLabels+=NodeLabel+)?
		public Group getGroup() { return cGroup; }
		
		///*
		// * this is a clarified and corrected form of openCypher spec M08 version which had ambiguity
		// * oC_PropertyOrLabelsExpression : oC_Atom ( SP? oC_PropertyLookup )* ( SP? oC_NodeLabels )?
		// *
		// * Note: we want ExpressionPropertyLookup and ExpressionNodeLabelsConstraint to
		// * appear in the AST iff property lookups and node label constraints were given, respectively
		// */ Atom
		public RuleCall getAtomParserRuleCall_0() { return cAtomParserRuleCall_0; }
		
		//({ExpressionPropertyLookup.left=current} propertyLookups+=PropertyLookup+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionPropertyLookup.left=current}
		public Action getExpressionPropertyLookupLeftAction_1_0() { return cExpressionPropertyLookupLeftAction_1_0; }
		
		//propertyLookups+=PropertyLookup+
		public Assignment getPropertyLookupsAssignment_1_1() { return cPropertyLookupsAssignment_1_1; }
		
		//PropertyLookup
		public RuleCall getPropertyLookupsPropertyLookupParserRuleCall_1_1_0() { return cPropertyLookupsPropertyLookupParserRuleCall_1_1_0; }
		
		//({ExpressionNodeLabels.left=current} nodeLabels+=NodeLabel+)?
		public Group getGroup_2() { return cGroup_2; }
		
		//{ExpressionNodeLabels.left=current}
		public Action getExpressionNodeLabelsLeftAction_2_0() { return cExpressionNodeLabelsLeftAction_2_0; }
		
		//nodeLabels+=NodeLabel+
		public Assignment getNodeLabelsAssignment_2_1() { return cNodeLabelsAssignment_2_1; }
		
		//NodeLabel
		public RuleCall getNodeLabelsNodeLabelParserRuleCall_2_1_0() { return cNodeLabelsNodeLabelParserRuleCall_2_1_0; }
	}
	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNumberConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueNumberParserRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cStringConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueSTRING_LITERALTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final RuleCall cParameterParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLegacyParameterParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cBoolConstantAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final Alternatives cValueAlternatives_4_1_0 = (Alternatives)cValueAssignment_4_1.eContents().get(0);
		private final Keyword cValueTRUEKeyword_4_1_0_0 = (Keyword)cValueAlternatives_4_1_0.eContents().get(0);
		private final Keyword cValueFALSEKeyword_4_1_0_1 = (Keyword)cValueAlternatives_4_1_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cNullConstantAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Keyword cNULLKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final RuleCall cCaseExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cCountAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Keyword cCOUNTKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Keyword cAsteriskKeyword_7_3 = (Keyword)cGroup_7.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_7_4 = (Keyword)cGroup_7.eContents().get(4);
		private final RuleCall cMapLiteralParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cListComprehensionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cPatternComprehensionParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final Group cGroup_11 = (Group)cAlternatives.eContents().get(11);
		private final Action cExpressionListAction_11_0 = (Action)cGroup_11.eContents().get(0);
		private final Group cGroup_11_1 = (Group)cGroup_11.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_11_1_0 = (Keyword)cGroup_11_1.eContents().get(0);
		private final Group cGroup_11_1_1 = (Group)cGroup_11_1.eContents().get(1);
		private final Assignment cExpressionsAssignment_11_1_1_0 = (Assignment)cGroup_11_1_1.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_11_1_1_0_0 = (RuleCall)cExpressionsAssignment_11_1_1_0.eContents().get(0);
		private final Group cGroup_11_1_1_1 = (Group)cGroup_11_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_11_1_1_1_0 = (Keyword)cGroup_11_1_1_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_11_1_1_1_1 = (Assignment)cGroup_11_1_1_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_11_1_1_1_1_0 = (RuleCall)cExpressionsAssignment_11_1_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_11_1_2 = (Keyword)cGroup_11_1.eContents().get(2);
		private final Group cGroup_12 = (Group)cAlternatives.eContents().get(12);
		private final Action cExtractAction_12_0 = (Action)cGroup_12.eContents().get(0);
		private final Keyword cEXTRACTKeyword_12_1 = (Keyword)cGroup_12.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_12_2 = (Keyword)cGroup_12.eContents().get(2);
		private final Assignment cFilterExpressionAssignment_12_3 = (Assignment)cGroup_12.eContents().get(3);
		private final RuleCall cFilterExpressionFilterExpressionParserRuleCall_12_3_0 = (RuleCall)cFilterExpressionAssignment_12_3.eContents().get(0);
		private final Group cGroup_12_4 = (Group)cGroup_12.eContents().get(4);
		private final Keyword cVerticalLineKeyword_12_4_0 = (Keyword)cGroup_12_4.eContents().get(0);
		private final Assignment cExpressionAssignment_12_4_1 = (Assignment)cGroup_12_4.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_12_4_1_0 = (RuleCall)cExpressionAssignment_12_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_12_5 = (Keyword)cGroup_12.eContents().get(5);
		private final RuleCall cReduceParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Action cFilterAction_14_0 = (Action)cGroup_14.eContents().get(0);
		private final Keyword cFILTERKeyword_14_1 = (Keyword)cGroup_14.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_14_2 = (Keyword)cGroup_14.eContents().get(2);
		private final Assignment cFilterExpressionAssignment_14_3 = (Assignment)cGroup_14.eContents().get(3);
		private final RuleCall cFilterExpressionFilterExpressionParserRuleCall_14_3_0 = (RuleCall)cFilterExpressionAssignment_14_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_14_4 = (Keyword)cGroup_14.eContents().get(4);
		private final Group cGroup_15 = (Group)cAlternatives.eContents().get(15);
		private final Action cAllAction_15_0 = (Action)cGroup_15.eContents().get(0);
		private final Keyword cALLKeyword_15_1 = (Keyword)cGroup_15.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_15_2 = (Keyword)cGroup_15.eContents().get(2);
		private final Assignment cFilterExpressionAssignment_15_3 = (Assignment)cGroup_15.eContents().get(3);
		private final RuleCall cFilterExpressionFilterExpressionParserRuleCall_15_3_0 = (RuleCall)cFilterExpressionAssignment_15_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_15_4 = (Keyword)cGroup_15.eContents().get(4);
		private final Group cGroup_16 = (Group)cAlternatives.eContents().get(16);
		private final Action cAnyAction_16_0 = (Action)cGroup_16.eContents().get(0);
		private final Keyword cANYKeyword_16_1 = (Keyword)cGroup_16.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_16_2 = (Keyword)cGroup_16.eContents().get(2);
		private final Assignment cFilterExpressionAssignment_16_3 = (Assignment)cGroup_16.eContents().get(3);
		private final RuleCall cFilterExpressionFilterExpressionParserRuleCall_16_3_0 = (RuleCall)cFilterExpressionAssignment_16_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_16_4 = (Keyword)cGroup_16.eContents().get(4);
		private final Group cGroup_17 = (Group)cAlternatives.eContents().get(17);
		private final Action cNoneAction_17_0 = (Action)cGroup_17.eContents().get(0);
		private final Keyword cNONEKeyword_17_1 = (Keyword)cGroup_17.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_17_2 = (Keyword)cGroup_17.eContents().get(2);
		private final Assignment cFilterExpressionAssignment_17_3 = (Assignment)cGroup_17.eContents().get(3);
		private final RuleCall cFilterExpressionFilterExpressionParserRuleCall_17_3_0 = (RuleCall)cFilterExpressionAssignment_17_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_17_4 = (Keyword)cGroup_17.eContents().get(4);
		private final Group cGroup_18 = (Group)cAlternatives.eContents().get(18);
		private final Action cSingleAction_18_0 = (Action)cGroup_18.eContents().get(0);
		private final Keyword cSINGLEKeyword_18_1 = (Keyword)cGroup_18.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_18_2 = (Keyword)cGroup_18.eContents().get(2);
		private final Assignment cFilterExpressionAssignment_18_3 = (Assignment)cGroup_18.eContents().get(3);
		private final RuleCall cFilterExpressionFilterExpressionParserRuleCall_18_3_0 = (RuleCall)cFilterExpressionAssignment_18_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_18_4 = (Keyword)cGroup_18.eContents().get(4);
		private final RuleCall cShortestPathPatternParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cRelationshipsPatternParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		private final RuleCall cParenthesizedExpressionParserRuleCall_21 = (RuleCall)cAlternatives.eContents().get(21);
		private final RuleCall cFunctionInvocationParserRuleCall_22 = (RuleCall)cAlternatives.eContents().get(22);
		private final Group cGroup_23 = (Group)cAlternatives.eContents().get(23);
		private final Action cVariableRefAction_23_0 = (Action)cGroup_23.eContents().get(0);
		private final Assignment cVariableRefAssignment_23_1 = (Assignment)cGroup_23.eContents().get(1);
		private final CrossReference cVariableRefVariableDeclarationCrossReference_23_1_0 = (CrossReference)cVariableRefAssignment_23_1.eContents().get(0);
		private final RuleCall cVariableRefVariableDeclarationSYMBOLIC_NAME_XParserRuleCall_23_1_0_1 = (RuleCall)cVariableRefVariableDeclarationCrossReference_23_1_0.eContents().get(1);
		
		///* Expression1 */ Atom Expression:
		//	{NumberConstant} value=Number | {StringConstant} value=STRING_LITERAL | Parameter | LegacyParameter | {BoolConstant}
		//	value=('TRUE' | 'FALSE') | {NullConstant} 'NULL' | CaseExpression | {Count} 'COUNT' '(' '*' ')' | MapLiteral |
		//	ListComprehension | PatternComprehension | {ExpressionList} ('[' (expressions+=Expression (','
		//	expressions+=Expression)*)? ']') | {Extract} 'EXTRACT' '(' filterExpression=FilterExpression ('|'
		//	expression=Expression)? ')' | Reduce | {Filter} 'FILTER' '(' filterExpression=FilterExpression ')' | {All} 'ALL' '('
		//	filterExpression=FilterExpression ')' | {Any} 'ANY' '(' filterExpression=FilterExpression ')' | {None} 'NONE' '('
		//	filterExpression=FilterExpression ')' | {Single} 'SINGLE' '(' filterExpression=FilterExpression ')' |
		//	ShortestPathPattern | RelationshipsPattern | ParenthesizedExpression | FunctionInvocation | {VariableRef}
		//	variableRef=[VariableDeclaration|SYMBOLIC_NAME_X];
		@Override public ParserRule getRule() { return rule; }
		
		//{NumberConstant} value=Number | {StringConstant} value=STRING_LITERAL | Parameter | LegacyParameter | {BoolConstant}
		//value=('TRUE' | 'FALSE') | {NullConstant} 'NULL' | CaseExpression | {Count} 'COUNT' '(' '*' ')' | MapLiteral |
		//ListComprehension | PatternComprehension | {ExpressionList} ('[' (expressions+=Expression (','
		//expressions+=Expression)*)? ']') | {Extract} 'EXTRACT' '(' filterExpression=FilterExpression ('|'
		//expression=Expression)? ')' | Reduce | {Filter} 'FILTER' '(' filterExpression=FilterExpression ')' | {All} 'ALL' '('
		//filterExpression=FilterExpression ')' | {Any} 'ANY' '(' filterExpression=FilterExpression ')' | {None} 'NONE' '('
		//filterExpression=FilterExpression ')' | {Single} 'SINGLE' '(' filterExpression=FilterExpression ')' |
		//ShortestPathPattern | RelationshipsPattern | ParenthesizedExpression | FunctionInvocation | {VariableRef}
		//variableRef=[VariableDeclaration|SYMBOLIC_NAME_X]
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{NumberConstant} value=Number
		public Group getGroup_0() { return cGroup_0; }
		
		//{NumberConstant}
		public Action getNumberConstantAction_0_0() { return cNumberConstantAction_0_0; }
		
		//value=Number
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//Number
		public RuleCall getValueNumberParserRuleCall_0_1_0() { return cValueNumberParserRuleCall_0_1_0; }
		
		//{StringConstant} value=STRING_LITERAL
		public Group getGroup_1() { return cGroup_1; }
		
		//{StringConstant}
		public Action getStringConstantAction_1_0() { return cStringConstantAction_1_0; }
		
		//value=STRING_LITERAL
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//STRING_LITERAL
		public RuleCall getValueSTRING_LITERALTerminalRuleCall_1_1_0() { return cValueSTRING_LITERALTerminalRuleCall_1_1_0; }
		
		//Parameter
		public RuleCall getParameterParserRuleCall_2() { return cParameterParserRuleCall_2; }
		
		//LegacyParameter
		public RuleCall getLegacyParameterParserRuleCall_3() { return cLegacyParameterParserRuleCall_3; }
		
		//{BoolConstant} value=('TRUE' | 'FALSE')
		public Group getGroup_4() { return cGroup_4; }
		
		//{BoolConstant}
		public Action getBoolConstantAction_4_0() { return cBoolConstantAction_4_0; }
		
		//value=('TRUE' | 'FALSE')
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }
		
		//('TRUE' | 'FALSE')
		public Alternatives getValueAlternatives_4_1_0() { return cValueAlternatives_4_1_0; }
		
		//'TRUE'
		public Keyword getValueTRUEKeyword_4_1_0_0() { return cValueTRUEKeyword_4_1_0_0; }
		
		//'FALSE'
		public Keyword getValueFALSEKeyword_4_1_0_1() { return cValueFALSEKeyword_4_1_0_1; }
		
		//{NullConstant} 'NULL'
		public Group getGroup_5() { return cGroup_5; }
		
		//{NullConstant}
		public Action getNullConstantAction_5_0() { return cNullConstantAction_5_0; }
		
		//'NULL'
		public Keyword getNULLKeyword_5_1() { return cNULLKeyword_5_1; }
		
		//CaseExpression
		public RuleCall getCaseExpressionParserRuleCall_6() { return cCaseExpressionParserRuleCall_6; }
		
		//{Count} 'COUNT' '(' '*' ')'
		public Group getGroup_7() { return cGroup_7; }
		
		//{Count}
		public Action getCountAction_7_0() { return cCountAction_7_0; }
		
		//'COUNT'
		public Keyword getCOUNTKeyword_7_1() { return cCOUNTKeyword_7_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_7_2() { return cLeftParenthesisKeyword_7_2; }
		
		//'*'
		public Keyword getAsteriskKeyword_7_3() { return cAsteriskKeyword_7_3; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7_4() { return cRightParenthesisKeyword_7_4; }
		
		//MapLiteral
		public RuleCall getMapLiteralParserRuleCall_8() { return cMapLiteralParserRuleCall_8; }
		
		//ListComprehension
		public RuleCall getListComprehensionParserRuleCall_9() { return cListComprehensionParserRuleCall_9; }
		
		//PatternComprehension
		public RuleCall getPatternComprehensionParserRuleCall_10() { return cPatternComprehensionParserRuleCall_10; }
		
		//{ExpressionList} ('[' (expressions+=Expression (',' expressions+=Expression)*)? ']')
		public Group getGroup_11() { return cGroup_11; }
		
		//{ExpressionList}
		public Action getExpressionListAction_11_0() { return cExpressionListAction_11_0; }
		
		//'[' (expressions+=Expression (',' expressions+=Expression)*)? ']'
		public Group getGroup_11_1() { return cGroup_11_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_11_1_0() { return cLeftSquareBracketKeyword_11_1_0; }
		
		//(expressions+=Expression (',' expressions+=Expression)*)?
		public Group getGroup_11_1_1() { return cGroup_11_1_1; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_11_1_1_0() { return cExpressionsAssignment_11_1_1_0; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_11_1_1_0_0() { return cExpressionsExpressionParserRuleCall_11_1_1_0_0; }
		
		//(',' expressions+=Expression)*
		public Group getGroup_11_1_1_1() { return cGroup_11_1_1_1; }
		
		//','
		public Keyword getCommaKeyword_11_1_1_1_0() { return cCommaKeyword_11_1_1_1_0; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_11_1_1_1_1() { return cExpressionsAssignment_11_1_1_1_1; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_11_1_1_1_1_0() { return cExpressionsExpressionParserRuleCall_11_1_1_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_11_1_2() { return cRightSquareBracketKeyword_11_1_2; }
		
		//{Extract} 'EXTRACT' '(' filterExpression=FilterExpression ('|' expression=Expression)? ')'
		public Group getGroup_12() { return cGroup_12; }
		
		//{Extract}
		public Action getExtractAction_12_0() { return cExtractAction_12_0; }
		
		//'EXTRACT'
		public Keyword getEXTRACTKeyword_12_1() { return cEXTRACTKeyword_12_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_12_2() { return cLeftParenthesisKeyword_12_2; }
		
		//filterExpression=FilterExpression
		public Assignment getFilterExpressionAssignment_12_3() { return cFilterExpressionAssignment_12_3; }
		
		//FilterExpression
		public RuleCall getFilterExpressionFilterExpressionParserRuleCall_12_3_0() { return cFilterExpressionFilterExpressionParserRuleCall_12_3_0; }
		
		//('|' expression=Expression)?
		public Group getGroup_12_4() { return cGroup_12_4; }
		
		//'|'
		public Keyword getVerticalLineKeyword_12_4_0() { return cVerticalLineKeyword_12_4_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_12_4_1() { return cExpressionAssignment_12_4_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_12_4_1_0() { return cExpressionExpressionParserRuleCall_12_4_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_12_5() { return cRightParenthesisKeyword_12_5; }
		
		//Reduce
		public RuleCall getReduceParserRuleCall_13() { return cReduceParserRuleCall_13; }
		
		//{Filter} 'FILTER' '(' filterExpression=FilterExpression ')'
		public Group getGroup_14() { return cGroup_14; }
		
		//{Filter}
		public Action getFilterAction_14_0() { return cFilterAction_14_0; }
		
		//'FILTER'
		public Keyword getFILTERKeyword_14_1() { return cFILTERKeyword_14_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_14_2() { return cLeftParenthesisKeyword_14_2; }
		
		//filterExpression=FilterExpression
		public Assignment getFilterExpressionAssignment_14_3() { return cFilterExpressionAssignment_14_3; }
		
		//FilterExpression
		public RuleCall getFilterExpressionFilterExpressionParserRuleCall_14_3_0() { return cFilterExpressionFilterExpressionParserRuleCall_14_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_14_4() { return cRightParenthesisKeyword_14_4; }
		
		//{All} 'ALL' '(' filterExpression=FilterExpression ')'
		public Group getGroup_15() { return cGroup_15; }
		
		//{All}
		public Action getAllAction_15_0() { return cAllAction_15_0; }
		
		//'ALL'
		public Keyword getALLKeyword_15_1() { return cALLKeyword_15_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_15_2() { return cLeftParenthesisKeyword_15_2; }
		
		//filterExpression=FilterExpression
		public Assignment getFilterExpressionAssignment_15_3() { return cFilterExpressionAssignment_15_3; }
		
		//FilterExpression
		public RuleCall getFilterExpressionFilterExpressionParserRuleCall_15_3_0() { return cFilterExpressionFilterExpressionParserRuleCall_15_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_15_4() { return cRightParenthesisKeyword_15_4; }
		
		//{Any} 'ANY' '(' filterExpression=FilterExpression ')'
		public Group getGroup_16() { return cGroup_16; }
		
		//{Any}
		public Action getAnyAction_16_0() { return cAnyAction_16_0; }
		
		//'ANY'
		public Keyword getANYKeyword_16_1() { return cANYKeyword_16_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_16_2() { return cLeftParenthesisKeyword_16_2; }
		
		//filterExpression=FilterExpression
		public Assignment getFilterExpressionAssignment_16_3() { return cFilterExpressionAssignment_16_3; }
		
		//FilterExpression
		public RuleCall getFilterExpressionFilterExpressionParserRuleCall_16_3_0() { return cFilterExpressionFilterExpressionParserRuleCall_16_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_16_4() { return cRightParenthesisKeyword_16_4; }
		
		//{None} 'NONE' '(' filterExpression=FilterExpression ')'
		public Group getGroup_17() { return cGroup_17; }
		
		//{None}
		public Action getNoneAction_17_0() { return cNoneAction_17_0; }
		
		//'NONE'
		public Keyword getNONEKeyword_17_1() { return cNONEKeyword_17_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_17_2() { return cLeftParenthesisKeyword_17_2; }
		
		//filterExpression=FilterExpression
		public Assignment getFilterExpressionAssignment_17_3() { return cFilterExpressionAssignment_17_3; }
		
		//FilterExpression
		public RuleCall getFilterExpressionFilterExpressionParserRuleCall_17_3_0() { return cFilterExpressionFilterExpressionParserRuleCall_17_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_17_4() { return cRightParenthesisKeyword_17_4; }
		
		//{Single} 'SINGLE' '(' filterExpression=FilterExpression ')'
		public Group getGroup_18() { return cGroup_18; }
		
		//{Single}
		public Action getSingleAction_18_0() { return cSingleAction_18_0; }
		
		//'SINGLE'
		public Keyword getSINGLEKeyword_18_1() { return cSINGLEKeyword_18_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_18_2() { return cLeftParenthesisKeyword_18_2; }
		
		//filterExpression=FilterExpression
		public Assignment getFilterExpressionAssignment_18_3() { return cFilterExpressionAssignment_18_3; }
		
		//FilterExpression
		public RuleCall getFilterExpressionFilterExpressionParserRuleCall_18_3_0() { return cFilterExpressionFilterExpressionParserRuleCall_18_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_18_4() { return cRightParenthesisKeyword_18_4; }
		
		//ShortestPathPattern
		public RuleCall getShortestPathPatternParserRuleCall_19() { return cShortestPathPatternParserRuleCall_19; }
		
		//RelationshipsPattern
		public RuleCall getRelationshipsPatternParserRuleCall_20() { return cRelationshipsPatternParserRuleCall_20; }
		
		//ParenthesizedExpression
		public RuleCall getParenthesizedExpressionParserRuleCall_21() { return cParenthesizedExpressionParserRuleCall_21; }
		
		//FunctionInvocation
		public RuleCall getFunctionInvocationParserRuleCall_22() { return cFunctionInvocationParserRuleCall_22; }
		
		//{VariableRef} variableRef=[VariableDeclaration|SYMBOLIC_NAME_X]
		public Group getGroup_23() { return cGroup_23; }
		
		//{VariableRef}
		public Action getVariableRefAction_23_0() { return cVariableRefAction_23_0; }
		
		//variableRef=[VariableDeclaration|SYMBOLIC_NAME_X]
		public Assignment getVariableRefAssignment_23_1() { return cVariableRefAssignment_23_1; }
		
		//[VariableDeclaration|SYMBOLIC_NAME_X]
		public CrossReference getVariableRefVariableDeclarationCrossReference_23_1_0() { return cVariableRefVariableDeclarationCrossReference_23_1_0; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getVariableRefVariableDeclarationSYMBOLIC_NAME_XParserRuleCall_23_1_0_1() { return cVariableRefVariableDeclarationSYMBOLIC_NAME_XParserRuleCall_23_1_0_1; }
	}
	public class ReduceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Reduce");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cREDUCEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAccumulatorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAccumulatorVariableDeclarationParserRuleCall_2_0 = (RuleCall)cAccumulatorAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAccumulatorExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAccumulatorExpressionExpressionParserRuleCall_4_0 = (RuleCall)cAccumulatorExpressionAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cIdInCollAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cIdInCollIdInCollParserRuleCall_6_0 = (RuleCall)cIdInCollAssignment_6.eContents().get(0);
		private final Keyword cVerticalLineKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cExpressionAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cExpressionExpressionParserRuleCall_8_0 = (RuleCall)cExpressionAssignment_8.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//Reduce: /*
		// * reduce : REDUCE ws '(' variable '=' expression ',' idInColl '|' expression ')' ;
		// */ 'REDUCE' '(' accumulator=VariableDeclaration '=' accumulatorExpression=Expression ',' idInColl=IdInColl '|'
		//	expression=Expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * reduce : REDUCE ws '(' variable '=' expression ',' idInColl '|' expression ')' ;
		// */ 'REDUCE' '(' accumulator=VariableDeclaration '=' accumulatorExpression=Expression ',' idInColl=IdInColl '|'
		//expression=Expression ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * reduce : REDUCE ws '(' variable '=' expression ',' idInColl '|' expression ')' ;
		// */ 'REDUCE'
		public Keyword getREDUCEKeyword_0() { return cREDUCEKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//accumulator=VariableDeclaration
		public Assignment getAccumulatorAssignment_2() { return cAccumulatorAssignment_2; }
		
		//VariableDeclaration
		public RuleCall getAccumulatorVariableDeclarationParserRuleCall_2_0() { return cAccumulatorVariableDeclarationParserRuleCall_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//accumulatorExpression=Expression
		public Assignment getAccumulatorExpressionAssignment_4() { return cAccumulatorExpressionAssignment_4; }
		
		//Expression
		public RuleCall getAccumulatorExpressionExpressionParserRuleCall_4_0() { return cAccumulatorExpressionExpressionParserRuleCall_4_0; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//idInColl=IdInColl
		public Assignment getIdInCollAssignment_6() { return cIdInCollAssignment_6; }
		
		//IdInColl
		public RuleCall getIdInCollIdInCollParserRuleCall_6_0() { return cIdInCollIdInCollParserRuleCall_6_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_7() { return cVerticalLineKeyword_7; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_8() { return cExpressionAssignment_8; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_8_0() { return cExpressionExpressionParserRuleCall_8_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }
	}
	public class ParenthesizedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ParenthesizedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesizedExpression: /*
		// * parenthesizedExpression : '(' ws expression ws ')' ;
		// */ '(' expression=Expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * parenthesizedExpression : '(' ws expression ws ')' ;
		// */ '(' expression=Expression ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * parenthesizedExpression : '(' ws expression ws ')' ;
		// */ '('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class RelationshipsPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RelationshipsPattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodePatternAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNodePatternNodePatternParserRuleCall_0_0 = (RuleCall)cNodePatternAssignment_0.eContents().get(0);
		private final Assignment cChainAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cChainPatternElementChainParserRuleCall_1_0 = (RuleCall)cChainAssignment_1.eContents().get(0);
		
		//RelationshipsPattern:
		//	nodePattern=NodePattern chain+=PatternElementChain+;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * relationshipsPattern : nodePattern ( ws patternElementChain )+ ;
		// */ nodePattern=NodePattern chain+=PatternElementChain+
		public Group getGroup() { return cGroup; }
		
		///*
		// * relationshipsPattern : nodePattern ( ws patternElementChain )+ ;
		// */ nodePattern=NodePattern
		public Assignment getNodePatternAssignment_0() { return cNodePatternAssignment_0; }
		
		//NodePattern
		public RuleCall getNodePatternNodePatternParserRuleCall_0_0() { return cNodePatternNodePatternParserRuleCall_0_0; }
		
		//chain+=PatternElementChain+
		public Assignment getChainAssignment_1() { return cChainAssignment_1; }
		
		//PatternElementChain
		public RuleCall getChainPatternElementChainParserRuleCall_1_0() { return cChainPatternElementChainParserRuleCall_1_0; }
	}
	public class FilterExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.FilterExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdInCollAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdInCollIdInCollParserRuleCall_0_0 = (RuleCall)cIdInCollAssignment_0.eContents().get(0);
		private final Assignment cWhereAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhereWhereParserRuleCall_1_0 = (RuleCall)cWhereAssignment_1.eContents().get(0);
		
		//FilterExpression:
		//	idInColl=IdInColl where=Where?;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * filterExpression : idInColl ( ws where )? ;
		// */ idInColl=IdInColl where=Where?
		public Group getGroup() { return cGroup; }
		
		///*
		// * filterExpression : idInColl ( ws where )? ;
		// */ idInColl=IdInColl
		public Assignment getIdInCollAssignment_0() { return cIdInCollAssignment_0; }
		
		//IdInColl
		public RuleCall getIdInCollIdInCollParserRuleCall_0_0() { return cIdInCollIdInCollParserRuleCall_0_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_1() { return cWhereAssignment_1; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_1_0() { return cWhereWhereParserRuleCall_1_0; }
	}
	public class IdInCollElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.IdInColl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Keyword cINKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//IdInColl:
		//	variable=VariableDeclaration 'IN' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * idInColl : variable sp IN sp expression ;
		// */ variable=VariableDeclaration 'IN' expression=Expression
		public Group getGroup() { return cGroup; }
		
		///*
		// * idInColl : variable sp IN sp expression ;
		// */ variable=VariableDeclaration
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_0_0() { return cVariableVariableDeclarationParserRuleCall_0_0; }
		
		//'IN'
		public Keyword getINKeyword_1() { return cINKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class FunctionInvocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.FunctionInvocation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctionNameFunctionNameParserRuleCall_0_0 = (RuleCall)cFunctionNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDistinctAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cDistinctDISTINCTKeyword_2_0 = (Keyword)cDistinctAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParameterAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParameterExpressionParserRuleCall_3_0_0 = (RuleCall)cParameterAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParameterAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParameterExpressionParserRuleCall_3_1_1_0 = (RuleCall)cParameterAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionInvocation:
		//	functionName=FunctionName '(' distinct?='DISTINCT'? (parameter+=Expression (',' parameter+=Expression)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * functionInvocation : functionName ws '(' ws DISTINCT? ( expression ( ',' ws expression )* )? ws ')' ;
		// */ functionName=FunctionName '(' distinct?='DISTINCT'? (parameter+=Expression (',' parameter+=Expression)*)? ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * functionInvocation : functionName ws '(' ws DISTINCT? ( expression ( ',' ws expression )* )? ws ')' ;
		// */ functionName=FunctionName
		public Assignment getFunctionNameAssignment_0() { return cFunctionNameAssignment_0; }
		
		//FunctionName
		public RuleCall getFunctionNameFunctionNameParserRuleCall_0_0() { return cFunctionNameFunctionNameParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//distinct?='DISTINCT'?
		public Assignment getDistinctAssignment_2() { return cDistinctAssignment_2; }
		
		//'DISTINCT'
		public Keyword getDistinctDISTINCTKeyword_2_0() { return cDistinctDISTINCTKeyword_2_0; }
		
		//(parameter+=Expression (',' parameter+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//parameter+=Expression
		public Assignment getParameterAssignment_3_0() { return cParameterAssignment_3_0; }
		
		//Expression
		public RuleCall getParameterExpressionParserRuleCall_3_0_0() { return cParameterExpressionParserRuleCall_3_0_0; }
		
		//(',' parameter+=Expression)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//parameter+=Expression
		public Assignment getParameterAssignment_3_1_1() { return cParameterAssignment_3_1_1; }
		
		//Expression
		public RuleCall getParameterExpressionParserRuleCall_3_1_1_0() { return cParameterExpressionParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.FunctionName");
		private final RuleCall cSYMBOLIC_NAME_XParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//FunctionName:
		//	SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * functionName : symbolicName ;
		// */ SYMBOLIC_NAME_X
		public RuleCall getSYMBOLIC_NAME_XParserRuleCall() { return cSYMBOLIC_NAME_XParserRuleCall; }
	}
	public class ExplicitProcedureInvocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ExplicitProcedureInvocation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cProcedureNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cProcedureNameProcedureNameParserRuleCall_0_0 = (RuleCall)cProcedureNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterExpressionParserRuleCall_2_0_0 = (RuleCall)cParameterAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterExpressionParserRuleCall_2_1_1_0 = (RuleCall)cParameterAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ExplicitProcedureInvocation:
		//	procedureName=ProcedureName '(' (parameter+=Expression (',' parameter+=Expression)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * ExplicitProcedureInvocation : ProcedureName '(' ( Expression ( ',' Expression )* )? ')' ;
		// */ procedureName=ProcedureName '(' (parameter+=Expression (',' parameter+=Expression)*)? ')'
		public Group getGroup() { return cGroup; }
		
		///*
		// * ExplicitProcedureInvocation : ProcedureName '(' ( Expression ( ',' Expression )* )? ')' ;
		// */ procedureName=ProcedureName
		public Assignment getProcedureNameAssignment_0() { return cProcedureNameAssignment_0; }
		
		//ProcedureName
		public RuleCall getProcedureNameProcedureNameParserRuleCall_0_0() { return cProcedureNameProcedureNameParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(parameter+=Expression (',' parameter+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//parameter+=Expression
		public Assignment getParameterAssignment_2_0() { return cParameterAssignment_2_0; }
		
		//Expression
		public RuleCall getParameterExpressionParserRuleCall_2_0_0() { return cParameterExpressionParserRuleCall_2_0_0; }
		
		//(',' parameter+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//parameter+=Expression
		public Assignment getParameterAssignment_2_1_1() { return cParameterAssignment_2_1_1; }
		
		//Expression
		public RuleCall getParameterExpressionParserRuleCall_2_1_1_0() { return cParameterExpressionParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ProcedureResultFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ProcedureResultField");
		private final RuleCall cSYMBOLIC_NAME_XParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ProcedureResultField:
		//	SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * ProcedureResultField : SymbolicName ;
		// */ SYMBOLIC_NAME_X
		public RuleCall getSYMBOLIC_NAME_XParserRuleCall() { return cSYMBOLIC_NAME_XParserRuleCall; }
	}
	public class ImplicitProcedureInvocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ImplicitProcedureInvocation");
		private final RuleCall cProcedureNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ImplicitProcedureInvocation:
		//	ProcedureName;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * ImplicitProcedureInvocation : ProcedureName ;
		// */ ProcedureName
		public RuleCall getProcedureNameParserRuleCall() { return cProcedureNameParserRuleCall; }
	}
	public class ProcedureNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ProcedureName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamespaceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamespaceNamespaceParserRuleCall_0_0 = (RuleCall)cNamespaceAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSYMBOLIC_NAME_XParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ProcedureName:
		//	namespace=Namespace name=SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * ProcedureName : Namespace SymbolicName ;
		// */ namespace=Namespace name=SYMBOLIC_NAME_X
		public Group getGroup() { return cGroup; }
		
		///*
		// * ProcedureName : Namespace SymbolicName ;
		// */ namespace=Namespace
		public Assignment getNamespaceAssignment_0() { return cNamespaceAssignment_0; }
		
		//Namespace
		public RuleCall getNamespaceNamespaceParserRuleCall_0_0() { return cNamespaceNamespaceParserRuleCall_0_0; }
		
		//name=SYMBOLIC_NAME_X
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getNameSYMBOLIC_NAME_XParserRuleCall_1_0() { return cNameSYMBOLIC_NAME_XParserRuleCall_1_0; }
	}
	public class NamespaceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Namespace");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSYMBOLIC_NAME_XParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Namespace:
		//	(SYMBOLIC_NAME_X '.')*;
		@Override public ParserRule getRule() { return rule; }
		
		//(SYMBOLIC_NAME_X '.')*
		public Group getGroup() { return cGroup; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getSYMBOLIC_NAME_XParserRuleCall_0() { return cSYMBOLIC_NAME_XParserRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
	}
	public class ListComprehensionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ListComprehension");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFilterExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFilterExpressionFilterExpressionParserRuleCall_1_0 = (RuleCall)cFilterExpressionAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cVerticalLineKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ListComprehension: /*
		// * listComprehension : '[' filterExpression ( ws '|' expression )? ']' ;
		// */ '[' filterExpression=FilterExpression ('|' expression=Expression)? ']';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * listComprehension : '[' filterExpression ( ws '|' expression )? ']' ;
		// */ '[' filterExpression=FilterExpression ('|' expression=Expression)? ']'
		public Group getGroup() { return cGroup; }
		
		///*
		// * listComprehension : '[' filterExpression ( ws '|' expression )? ']' ;
		// */ '['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//filterExpression=FilterExpression
		public Assignment getFilterExpressionAssignment_1() { return cFilterExpressionAssignment_1; }
		
		//FilterExpression
		public RuleCall getFilterExpressionFilterExpressionParserRuleCall_1_0() { return cFilterExpressionFilterExpressionParserRuleCall_1_0; }
		
		//('|' expression=Expression)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'|'
		public Keyword getVerticalLineKeyword_2_0() { return cVerticalLineKeyword_2_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class PatternComprehensionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PatternComprehension");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cPathVariableAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cPathVariableVariableDeclarationParserRuleCall_1_0_0 = (RuleCall)cPathVariableAssignment_1_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cPatternAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternRelationshipsPatternParserRuleCall_2_0 = (RuleCall)cPatternAssignment_2.eContents().get(0);
		private final Assignment cWhereAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWhereWhereParserRuleCall_3_0 = (RuleCall)cWhereAssignment_3.eContents().get(0);
		private final Keyword cVerticalLineKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpressionExpressionParserRuleCall_5_0 = (RuleCall)cExpressionAssignment_5.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//PatternComprehension: /*
		// * patternComprehension : '['  ( variable '=' )? relationshipsPattern ( WHERE expression )? '|' expression ']' ;
		// */ '[' (pathVariable=VariableDeclaration '=')? pattern=RelationshipsPattern where=Where? '|' expression=Expression ']';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * patternComprehension : '['  ( variable '=' )? relationshipsPattern ( WHERE expression )? '|' expression ']' ;
		// */ '[' (pathVariable=VariableDeclaration '=')? pattern=RelationshipsPattern where=Where? '|' expression=Expression ']'
		public Group getGroup() { return cGroup; }
		
		///*
		// * patternComprehension : '['  ( variable '=' )? relationshipsPattern ( WHERE expression )? '|' expression ']' ;
		// */ '['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//(pathVariable=VariableDeclaration '=')?
		public Group getGroup_1() { return cGroup_1; }
		
		//pathVariable=VariableDeclaration
		public Assignment getPathVariableAssignment_1_0() { return cPathVariableAssignment_1_0; }
		
		//VariableDeclaration
		public RuleCall getPathVariableVariableDeclarationParserRuleCall_1_0_0() { return cPathVariableVariableDeclarationParserRuleCall_1_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//pattern=RelationshipsPattern
		public Assignment getPatternAssignment_2() { return cPatternAssignment_2; }
		
		//RelationshipsPattern
		public RuleCall getPatternRelationshipsPatternParserRuleCall_2_0() { return cPatternRelationshipsPatternParserRuleCall_2_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_3() { return cWhereAssignment_3; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_3_0() { return cWhereWhereParserRuleCall_3_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_4() { return cVerticalLineKeyword_4; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_5() { return cExpressionAssignment_5; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_5_0() { return cExpressionExpressionParserRuleCall_5_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }
	}
	public class PropertyLookupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PropertyLookup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cPropertyKeyNameAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cPropertyKeyNamePropertyKeyNameParserRuleCall_1_0_0_0 = (RuleCall)cPropertyKeyNameAssignment_1_0_0.eContents().get(0);
		private final Assignment cPropertyOperatorAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cPropertyOperatorAlternatives_1_0_1_0 = (Alternatives)cPropertyOperatorAssignment_1_0_1.eContents().get(0);
		private final Keyword cPropertyOperatorQuestionMarkKeyword_1_0_1_0_0 = (Keyword)cPropertyOperatorAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cPropertyOperatorExclamationMarkKeyword_1_0_1_0_1 = (Keyword)cPropertyOperatorAlternatives_1_0_1_0.eContents().get(1);
		private final Assignment cPropertyKeyNameAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cPropertyKeyNamePropertyKeyNameParserRuleCall_1_1_0 = (RuleCall)cPropertyKeyNameAssignment_1_1.eContents().get(0);
		
		//PropertyLookup: /*
		// * propertyLookup : ws '.' ws ( ( propertyKeyName ( '?' | '!' ) ) | propertyKeyName ) ;
		// */ '.' (propertyKeyName=PropertyKeyName propertyOperator=('?' | '!') | propertyKeyName=PropertyKeyName);
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * propertyLookup : ws '.' ws ( ( propertyKeyName ( '?' | '!' ) ) | propertyKeyName ) ;
		// */ '.' (propertyKeyName=PropertyKeyName propertyOperator=('?' | '!') | propertyKeyName=PropertyKeyName)
		public Group getGroup() { return cGroup; }
		
		///*
		// * propertyLookup : ws '.' ws ( ( propertyKeyName ( '?' | '!' ) ) | propertyKeyName ) ;
		// */ '.'
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//propertyKeyName=PropertyKeyName propertyOperator=('?' | '!') | propertyKeyName=PropertyKeyName
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//propertyKeyName=PropertyKeyName propertyOperator=('?' | '!')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//propertyKeyName=PropertyKeyName
		public Assignment getPropertyKeyNameAssignment_1_0_0() { return cPropertyKeyNameAssignment_1_0_0; }
		
		//PropertyKeyName
		public RuleCall getPropertyKeyNamePropertyKeyNameParserRuleCall_1_0_0_0() { return cPropertyKeyNamePropertyKeyNameParserRuleCall_1_0_0_0; }
		
		//propertyOperator=('?' | '!')
		public Assignment getPropertyOperatorAssignment_1_0_1() { return cPropertyOperatorAssignment_1_0_1; }
		
		//('?' | '!')
		public Alternatives getPropertyOperatorAlternatives_1_0_1_0() { return cPropertyOperatorAlternatives_1_0_1_0; }
		
		//'?'
		public Keyword getPropertyOperatorQuestionMarkKeyword_1_0_1_0_0() { return cPropertyOperatorQuestionMarkKeyword_1_0_1_0_0; }
		
		//'!'
		public Keyword getPropertyOperatorExclamationMarkKeyword_1_0_1_0_1() { return cPropertyOperatorExclamationMarkKeyword_1_0_1_0_1; }
		
		//propertyKeyName=PropertyKeyName
		public Assignment getPropertyKeyNameAssignment_1_1() { return cPropertyKeyNameAssignment_1_1; }
		
		//PropertyKeyName
		public RuleCall getPropertyKeyNamePropertyKeyNameParserRuleCall_1_1_0() { return cPropertyKeyNamePropertyKeyNameParserRuleCall_1_1_0; }
	}
	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.CaseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cCASEKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cCaseAlternativesAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cCaseAlternativesCaseAlternativesParserRuleCall_0_0_1_0 = (RuleCall)cCaseAlternativesAssignment_0_0_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cCASEKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cCaseExpressionAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cCaseExpressionExpressionParserRuleCall_0_1_1_0 = (RuleCall)cCaseExpressionAssignment_0_1_1.eContents().get(0);
		private final Assignment cCaseAlternativesAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cCaseAlternativesCaseAlternativesParserRuleCall_0_1_2_0 = (RuleCall)cCaseAlternativesAssignment_0_1_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cELSEKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cElseExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cElseExpressionExpressionParserRuleCall_1_1_0 = (RuleCall)cElseExpressionAssignment_1_1.eContents().get(0);
		private final Keyword cENDKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//CaseExpression:
		//	('CASE' caseAlternatives+=CaseAlternatives+ | 'CASE' caseExpression=Expression
		//	caseAlternatives+=CaseAlternatives+) ('ELSE' elseExpression=Expression)? 'END';
		@Override public ParserRule getRule() { return rule; }
		
		//('CASE' caseAlternatives+=CaseAlternatives+ | 'CASE' caseExpression=Expression caseAlternatives+=CaseAlternatives+)
		//('ELSE' elseExpression=Expression)? 'END'
		public Group getGroup() { return cGroup; }
		
		///*
		// * caseExpression : ( ( CASE ( ws caseAlternatives )+ ) | ( CASE expression ( ws caseAlternatives )+ ) ) ( ws ELSE ws expression )? ws END ;
		// */ 'CASE' caseAlternatives+=CaseAlternatives+ | 'CASE' caseExpression=Expression caseAlternatives+=CaseAlternatives+
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'CASE' caseAlternatives+=CaseAlternatives+
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//'CASE'
		public Keyword getCASEKeyword_0_0_0() { return cCASEKeyword_0_0_0; }
		
		//caseAlternatives+=CaseAlternatives+
		public Assignment getCaseAlternativesAssignment_0_0_1() { return cCaseAlternativesAssignment_0_0_1; }
		
		//CaseAlternatives
		public RuleCall getCaseAlternativesCaseAlternativesParserRuleCall_0_0_1_0() { return cCaseAlternativesCaseAlternativesParserRuleCall_0_0_1_0; }
		
		//'CASE' caseExpression=Expression caseAlternatives+=CaseAlternatives+
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'CASE'
		public Keyword getCASEKeyword_0_1_0() { return cCASEKeyword_0_1_0; }
		
		//caseExpression=Expression
		public Assignment getCaseExpressionAssignment_0_1_1() { return cCaseExpressionAssignment_0_1_1; }
		
		//Expression
		public RuleCall getCaseExpressionExpressionParserRuleCall_0_1_1_0() { return cCaseExpressionExpressionParserRuleCall_0_1_1_0; }
		
		//caseAlternatives+=CaseAlternatives+
		public Assignment getCaseAlternativesAssignment_0_1_2() { return cCaseAlternativesAssignment_0_1_2; }
		
		//CaseAlternatives
		public RuleCall getCaseAlternativesCaseAlternativesParserRuleCall_0_1_2_0() { return cCaseAlternativesCaseAlternativesParserRuleCall_0_1_2_0; }
		
		//('ELSE' elseExpression=Expression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'ELSE'
		public Keyword getELSEKeyword_1_0() { return cELSEKeyword_1_0; }
		
		//elseExpression=Expression
		public Assignment getElseExpressionAssignment_1_1() { return cElseExpressionAssignment_1_1; }
		
		//Expression
		public RuleCall getElseExpressionExpressionParserRuleCall_1_1_0() { return cElseExpressionExpressionParserRuleCall_1_1_0; }
		
		//'END'
		public Keyword getENDKeyword_2() { return cENDKeyword_2; }
	}
	public class CaseAlternativesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.CaseAlternatives");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWHENKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cWhenAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhenExpressionParserRuleCall_1_0 = (RuleCall)cWhenAssignment_1.eContents().get(0);
		private final Keyword cTHENKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenExpressionParserRuleCall_3_0 = (RuleCall)cThenAssignment_3.eContents().get(0);
		
		//CaseAlternatives: /*
		// * caseAlternatives : WHEN ws expression ws THEN ws expression ;
		// */ 'WHEN' when=Expression 'THEN' then=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * caseAlternatives : WHEN ws expression ws THEN ws expression ;
		// */ 'WHEN' when=Expression 'THEN' then=Expression
		public Group getGroup() { return cGroup; }
		
		///*
		// * caseAlternatives : WHEN ws expression ws THEN ws expression ;
		// */ 'WHEN'
		public Keyword getWHENKeyword_0() { return cWHENKeyword_0; }
		
		//when=Expression
		public Assignment getWhenAssignment_1() { return cWhenAssignment_1; }
		
		//Expression
		public RuleCall getWhenExpressionParserRuleCall_1_0() { return cWhenExpressionParserRuleCall_1_0; }
		
		//'THEN'
		public Keyword getTHENKeyword_2() { return cTHENKeyword_2; }
		
		//then=Expression
		public Assignment getThenAssignment_3() { return cThenAssignment_3; }
		
		//Expression
		public RuleCall getThenExpressionParserRuleCall_3_0() { return cThenExpressionParserRuleCall_3_0; }
	}
	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSYMBOLIC_NAME_XParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//VariableDeclaration:
		//	{VariableDeclaration} name=SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		//{VariableDeclaration} name=SYMBOLIC_NAME_X
		public Group getGroup() { return cGroup; }
		
		//{VariableDeclaration}
		public Action getVariableDeclarationAction_0() { return cVariableDeclarationAction_0; }
		
		//name=SYMBOLIC_NAME_X
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getNameSYMBOLIC_NAME_XParserRuleCall_1_0() { return cNameSYMBOLIC_NAME_XParserRuleCall_1_0; }
	}
	public class MapLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.MapLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMapLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cEntriesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cEntriesMapLiteralEntryParserRuleCall_2_0_0 = (RuleCall)cEntriesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cEntriesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cEntriesMapLiteralEntryParserRuleCall_2_1_1_0 = (RuleCall)cEntriesAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MapLiteral:
		//	{MapLiteral} '{' (entries+=MapLiteralEntry (',' entries+=MapLiteralEntry)*)? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{MapLiteral} '{' (entries+=MapLiteralEntry (',' entries+=MapLiteralEntry)*)? '}'
		public Group getGroup() { return cGroup; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_0() { return cMapLiteralAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(entries+=MapLiteralEntry (',' entries+=MapLiteralEntry)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//entries+=MapLiteralEntry
		public Assignment getEntriesAssignment_2_0() { return cEntriesAssignment_2_0; }
		
		//MapLiteralEntry
		public RuleCall getEntriesMapLiteralEntryParserRuleCall_2_0_0() { return cEntriesMapLiteralEntryParserRuleCall_2_0_0; }
		
		//(',' entries+=MapLiteralEntry)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//entries+=MapLiteralEntry
		public Assignment getEntriesAssignment_2_1_1() { return cEntriesAssignment_2_1_1; }
		
		//MapLiteralEntry
		public RuleCall getEntriesMapLiteralEntryParserRuleCall_2_1_1_0() { return cEntriesMapLiteralEntryParserRuleCall_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class MapLiteralEntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.MapLiteralEntry");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyPropertyKeyNameParserRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//MapLiteralEntry:
		//	key=PropertyKeyName ':' value=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//key=PropertyKeyName ':' value=Expression
		public Group getGroup() { return cGroup; }
		
		//key=PropertyKeyName
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }
		
		//PropertyKeyName
		public RuleCall getKeyPropertyKeyNameParserRuleCall_0_0() { return cKeyPropertyKeyNameParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
	}
	public class LegacyParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.LegacyParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cParameterAlternatives_1_0 = (Alternatives)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterSYMBOLIC_NAME_XParserRuleCall_1_0_0 = (RuleCall)cParameterAlternatives_1_0.eContents().get(0);
		private final RuleCall cParameterNumberParserRuleCall_1_0_1 = (RuleCall)cParameterAlternatives_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//LegacyParameter: /*
		// * legacyParameter : '{' ws ( symbolicName | DecimalInteger ) ws '}' ;
		// * 
		// * Comment: Format of DecimalInteger is checked via 
		// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkLegacyParameterFormat(LegacyParameter)
		// */ '{' parameter=(SYMBOLIC_NAME_X | Number) '}';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * legacyParameter : '{' ws ( symbolicName | DecimalInteger ) ws '}' ;
		// * 
		// * Comment: Format of DecimalInteger is checked via 
		// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkLegacyParameterFormat(LegacyParameter)
		// */ '{' parameter=(SYMBOLIC_NAME_X | Number) '}'
		public Group getGroup() { return cGroup; }
		
		///*
		// * legacyParameter : '{' ws ( symbolicName | DecimalInteger ) ws '}' ;
		// * 
		// * Comment: Format of DecimalInteger is checked via 
		// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkLegacyParameterFormat(LegacyParameter)
		// */ '{'
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }
		
		//parameter=(SYMBOLIC_NAME_X | Number)
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }
		
		//(SYMBOLIC_NAME_X | Number)
		public Alternatives getParameterAlternatives_1_0() { return cParameterAlternatives_1_0; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getParameterSYMBOLIC_NAME_XParserRuleCall_1_0_0() { return cParameterSYMBOLIC_NAME_XParserRuleCall_1_0_0; }
		
		//Number
		public RuleCall getParameterNumberParserRuleCall_1_0_1() { return cParameterNumberParserRuleCall_1_0_1; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cParameterAlternatives_1_0 = (Alternatives)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterSYMBOLIC_NAME_XParserRuleCall_1_0_0 = (RuleCall)cParameterAlternatives_1_0.eContents().get(0);
		private final RuleCall cParameterNumberParserRuleCall_1_0_1 = (RuleCall)cParameterAlternatives_1_0.eContents().get(1);
		
		//Parameter: /*
		// * parameter : '$' ( symbolicName | DecimalInteger ) ;
		// * 
		// * Comment: Format of DecimalInteger is checked via 
		// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkParameterFormat(Parameter)
		// */ '$' parameter=(SYMBOLIC_NAME_X | Number);
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * parameter : '$' ( symbolicName | DecimalInteger ) ;
		// * 
		// * Comment: Format of DecimalInteger is checked via 
		// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkParameterFormat(Parameter)
		// */ '$' parameter=(SYMBOLIC_NAME_X | Number)
		public Group getGroup() { return cGroup; }
		
		///*
		// * parameter : '$' ( symbolicName | DecimalInteger ) ;
		// * 
		// * Comment: Format of DecimalInteger is checked via 
		// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkParameterFormat(Parameter)
		// */ '$'
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }
		
		//parameter=(SYMBOLIC_NAME_X | Number)
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }
		
		//(SYMBOLIC_NAME_X | Number)
		public Alternatives getParameterAlternatives_1_0() { return cParameterAlternatives_1_0; }
		
		//SYMBOLIC_NAME_X
		public RuleCall getParameterSYMBOLIC_NAME_XParserRuleCall_1_0_0() { return cParameterSYMBOLIC_NAME_XParserRuleCall_1_0_0; }
		
		//Number
		public RuleCall getParameterNumberParserRuleCall_1_0_1() { return cParameterNumberParserRuleCall_1_0_1; }
	}
	public class PropertyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PropertyExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftAtomParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Assignment cPropertyLookupsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPropertyLookupsPropertyLookupParserRuleCall_1_0 = (RuleCall)cPropertyLookupsAssignment_1.eContents().get(0);
		
		//PropertyExpression:
		//	left=Atom propertyLookups+=PropertyLookup+;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * propertyExpression : atom ( ws propertyLookup )+ ;
		// */ left=Atom propertyLookups+=PropertyLookup+
		public Group getGroup() { return cGroup; }
		
		///*
		// * propertyExpression : atom ( ws propertyLookup )+ ;
		// */ left=Atom
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//Atom
		public RuleCall getLeftAtomParserRuleCall_0_0() { return cLeftAtomParserRuleCall_0_0; }
		
		//propertyLookups+=PropertyLookup+
		public Assignment getPropertyLookupsAssignment_1() { return cPropertyLookupsAssignment_1; }
		
		//PropertyLookup
		public RuleCall getPropertyLookupsPropertyLookupParserRuleCall_1_0() { return cPropertyLookupsPropertyLookupParserRuleCall_1_0; }
	}
	public class PropertyKeyNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.PropertyKeyName");
		private final RuleCall cSYMBOLIC_NAME_XParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PropertyKeyName:
		//	SYMBOLIC_NAME_X;
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * propertyKeyName : symbolicName ;
		// */ SYMBOLIC_NAME_X
		public RuleCall getSYMBOLIC_NAME_XParserRuleCall() { return cSYMBOLIC_NAME_XParserRuleCall; }
	}
	public class LeftArrowHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.LeftArrowHead");
		private final Keyword cLessThanSignKeyword = (Keyword)rule.eContents().get(1);
		
		//LeftArrowHead: /*
		// * Comment: reduced character set
		// */ '<';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * Comment: reduced character set
		// */ '<'
		public Keyword getLessThanSignKeyword() { return cLessThanSignKeyword; }
	}
	public class RightArrowHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.RightArrowHead");
		private final Keyword cGreaterThanSignKeyword = (Keyword)rule.eContents().get(1);
		
		//RightArrowHead: /*
		// * Comment: reduced character set
		// */ '>';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * Comment: reduced character set
		// */ '>'
		public Keyword getGreaterThanSignKeyword() { return cGreaterThanSignKeyword; }
	}
	public class DashElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Dash");
		private final Keyword cHyphenMinusKeyword = (Keyword)rule.eContents().get(1);
		
		//Dash: /*
		// * Comment: reduced character set
		// */ '-';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * Comment: reduced character set
		// */ '-'
		public Keyword getHyphenMinusKeyword() { return cHyphenMinusKeyword; }
	}
	public class DecimalIntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.DecimalInteger");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDecimalIntegerAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueNumberParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//DecimalInteger:
		//	{DecimalInteger} value=Number;
		@Override public ParserRule getRule() { return rule; }
		
		//{DecimalInteger} value=Number
		public Group getGroup() { return cGroup; }
		
		//{DecimalInteger}
		public Action getDecimalIntegerAction_0() { return cDecimalIntegerAction_0; }
		
		//value=Number
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Number
		public RuleCall getValueNumberParserRuleCall_1_0() { return cValueNumberParserRuleCall_1_0; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.Number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cHEXTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_0_0 = (RuleCall)cAlternatives_1_0.eContents().get(0);
		private final RuleCall cDECIMALTerminalRuleCall_1_0_1 = (RuleCall)cAlternatives_1_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cFullStopKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1 = (Alternatives)cGroup_1_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_1_0 = (RuleCall)cAlternatives_1_1_1.eContents().get(0);
		private final RuleCall cDECIMALTerminalRuleCall_1_1_1_1 = (RuleCall)cAlternatives_1_1_1.eContents().get(1);
		
		//Number hidden():
		//	HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;
		@Override public ParserRule getRule() { return rule; }
		
		//HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//HEX
		public RuleCall getHEXTerminalRuleCall_0() { return cHEXTerminalRuleCall_0; }
		
		//(INT | DECIMAL) ('.' (INT | DECIMAL))?
		public Group getGroup_1() { return cGroup_1; }
		
		//INT | DECIMAL
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_0_0() { return cINTTerminalRuleCall_1_0_0; }
		
		//DECIMAL
		public RuleCall getDECIMALTerminalRuleCall_1_0_1() { return cDECIMALTerminalRuleCall_1_0_1; }
		
		//('.' (INT | DECIMAL))?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_1_0() { return cFullStopKeyword_1_1_0; }
		
		//INT | DECIMAL
		public Alternatives getAlternatives_1_1_1() { return cAlternatives_1_1_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1_0() { return cINTTerminalRuleCall_1_1_1_0; }
		
		//DECIMAL
		public RuleCall getDECIMALTerminalRuleCall_1_1_1_1() { return cDECIMALTerminalRuleCall_1_1_1_1; }
	}
	public class SYMBOLIC_NAME_XElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.SYMBOLIC_NAME_X");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cCYPHERKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEXPLAINKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPROFILEKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cUSINGKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPERIODICKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cCOMMITKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cUNIONKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cALLKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cCREATEKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cINDEXKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cONKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cDROPKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cCONSTRAINTKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cASSERTKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cISKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cUNIQUEKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cEXISTSKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cLOADKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cCSVKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cWITHKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cHEADERSKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cFROMKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cASKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cFIELDTERMINATORKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cOPTIONALKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cMATCHKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cUNWINDKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cMERGEKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cSETKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cDELETEKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cDETACHKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Keyword cREMOVEKeyword_32 = (Keyword)cAlternatives.eContents().get(32);
		private final Keyword cFOREACHKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cINKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cDISTINCTKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		private final Keyword cRETURNKeyword_36 = (Keyword)cAlternatives.eContents().get(36);
		private final Keyword cORDERKeyword_37 = (Keyword)cAlternatives.eContents().get(37);
		private final Keyword cBYKeyword_38 = (Keyword)cAlternatives.eContents().get(38);
		private final Keyword cSKIPKeyword_39 = (Keyword)cAlternatives.eContents().get(39);
		private final Keyword cLIMITKeyword_40 = (Keyword)cAlternatives.eContents().get(40);
		private final Keyword cDESCENDINGKeyword_41 = (Keyword)cAlternatives.eContents().get(41);
		private final Keyword cDESCKeyword_42 = (Keyword)cAlternatives.eContents().get(42);
		private final Keyword cASCENDINGKeyword_43 = (Keyword)cAlternatives.eContents().get(43);
		private final Keyword cASCKeyword_44 = (Keyword)cAlternatives.eContents().get(44);
		private final Keyword cJOINKeyword_45 = (Keyword)cAlternatives.eContents().get(45);
		private final Keyword cSCANKeyword_46 = (Keyword)cAlternatives.eContents().get(46);
		private final Keyword cSTARTKeyword_47 = (Keyword)cAlternatives.eContents().get(47);
		private final Keyword cNODEKeyword_48 = (Keyword)cAlternatives.eContents().get(48);
		private final Keyword cRELATIONSHIPKeyword_49 = (Keyword)cAlternatives.eContents().get(49);
		private final Keyword cRELKeyword_50 = (Keyword)cAlternatives.eContents().get(50);
		private final Keyword cWHEREKeyword_51 = (Keyword)cAlternatives.eContents().get(51);
		private final Keyword cSHORTESTPATHKeyword_52 = (Keyword)cAlternatives.eContents().get(52);
		private final Keyword cALLSHORTESTPATHSKeyword_53 = (Keyword)cAlternatives.eContents().get(53);
		private final Keyword cORKeyword_54 = (Keyword)cAlternatives.eContents().get(54);
		private final Keyword cXORKeyword_55 = (Keyword)cAlternatives.eContents().get(55);
		private final Keyword cANDKeyword_56 = (Keyword)cAlternatives.eContents().get(56);
		private final Keyword cNOTKeyword_57 = (Keyword)cAlternatives.eContents().get(57);
		private final Keyword cSTARTSKeyword_58 = (Keyword)cAlternatives.eContents().get(58);
		private final Keyword cENDSKeyword_59 = (Keyword)cAlternatives.eContents().get(59);
		private final Keyword cCONTAINSKeyword_60 = (Keyword)cAlternatives.eContents().get(60);
		private final Keyword cNULLKeyword_61 = (Keyword)cAlternatives.eContents().get(61);
		private final Keyword cTRUEKeyword_62 = (Keyword)cAlternatives.eContents().get(62);
		private final Keyword cFALSEKeyword_63 = (Keyword)cAlternatives.eContents().get(63);
		private final Keyword cCOUNTKeyword_64 = (Keyword)cAlternatives.eContents().get(64);
		private final Keyword cFILTERKeyword_65 = (Keyword)cAlternatives.eContents().get(65);
		private final Keyword cEXTRACTKeyword_66 = (Keyword)cAlternatives.eContents().get(66);
		private final Keyword cANYKeyword_67 = (Keyword)cAlternatives.eContents().get(67);
		private final Keyword cNONEKeyword_68 = (Keyword)cAlternatives.eContents().get(68);
		private final Keyword cSINGLEKeyword_69 = (Keyword)cAlternatives.eContents().get(69);
		private final Keyword cREDUCEKeyword_70 = (Keyword)cAlternatives.eContents().get(70);
		private final Keyword cCASEKeyword_71 = (Keyword)cAlternatives.eContents().get(71);
		private final Keyword cELSEKeyword_72 = (Keyword)cAlternatives.eContents().get(72);
		private final Keyword cENDKeyword_73 = (Keyword)cAlternatives.eContents().get(73);
		private final Keyword cWHENKeyword_74 = (Keyword)cAlternatives.eContents().get(74);
		private final Keyword cTHENKeyword_75 = (Keyword)cAlternatives.eContents().get(75);
		
		//SYMBOLIC_NAME_X:
		//	ID | 'CYPHER' | 'EXPLAIN' | 'PROFILE' | 'USING' | 'PERIODIC' | 'COMMIT' | 'UNION' | 'ALL' | 'CREATE' |
		//	'INDEX' | 'ON' | 'DROP' | 'CONSTRAINT' | 'ASSERT' | 'IS' | 'UNIQUE' | 'EXISTS' | 'LOAD' | 'CSV' | 'WITH' | 'HEADERS'
		//	| 'FROM' | 'AS' | 'FIELDTERMINATOR' | 'OPTIONAL' | 'MATCH' | 'UNWIND' | 'MERGE' | 'SET' | 'DELETE' | 'DETACH' |
		//	'REMOVE' | 'FOREACH' | 'IN' | 'DISTINCT' | 'RETURN' | 'ORDER' | 'BY' | 'SKIP' | 'LIMIT' | 'DESCENDING' | 'DESC' |
		//	'ASCENDING' | 'ASC' | 'JOIN' | 'SCAN' | 'START' | 'NODE' | 'RELATIONSHIP' | 'REL' | 'WHERE' | 'SHORTESTPATH' |
		//	'ALLSHORTESTPATHS' | 'OR' | 'XOR' | 'AND' | 'NOT' | 'STARTS' | 'ENDS' | 'CONTAINS' | 'NULL' | 'TRUE' | 'FALSE' |
		//	'COUNT' | 'FILTER' | 'EXTRACT' | 'ANY' | 'NONE' | 'SINGLE' | 'REDUCE' | 'CASE' | 'ELSE' | 'END' | 'WHEN' | 'THEN';
		@Override public ParserRule getRule() { return rule; }
		
		///*
		// * symbolicNameString : UnescapedSymbolicNameString
		// *                  | EscapedSymbolicNameString
		// *                  | CYPHER
		// *                  | EXPLAIN
		// *                  | PROFILE
		// *                  | USING
		// *                  | PERIODIC
		// *                  | COMMIT
		// *                  | UNION
		// *                  | ALL
		// *                  | CREATE
		// *                  | INDEX
		// *                  | ON
		// *                  | DROP
		// *                  | CONSTRAINT
		// *                  | ASSERT
		// *                  | IS
		// *                  | UNIQUE
		// *                  | EXISTS
		// *                  | LOAD
		// *                  | CSV
		// *                  | WITH
		// *                  | HEADERS
		// *                  | FROM
		// *                  | AS
		// *                  | FIELDTERMINATOR
		// *                  | OPTIONAL
		// *                  | MATCH
		// *                  | UNWIND
		// *                  | MERGE
		// *                  | SET
		// *                  | DELETE
		// *                  | DETACH
		// *                  | REMOVE
		// *                  | FOREACH
		// *                  | IN
		// *                  | DISTINCT
		// *                  | RETURN
		// *                  | ORDER
		// *                  | BY
		// *                  | L_SKIP
		// *                  | LIMIT
		// *                  | DESCENDING
		// *                  | DESC
		// *                  | ASCENDING
		// *                  | ASC
		// *                  | JOIN
		// *                  | SCAN
		// *                  | START
		// *                  | NODE
		// *                  | RELATIONSHIP
		// *                  | REL
		// *                  | WHERE
		// *                  | SHORTESTPATH
		// *                  | ALLSHORTESTPATHS
		// *                  | OR
		// *                  | XOR
		// *                  | AND
		// *                  | NOT
		// *                  | STARTS
		// *                  | ENDS
		// *                  | CONTAINS
		// *                  | NULL
		// *                  | TRUE
		// *                  | FALSE
		// *                  | COUNT
		// *                  | FILTER
		// *                  | EXTRACT
		// *                  | ANY
		// *                  | NONE
		// *                  | SINGLE
		// *                  | REDUCE
		// *                  | CASE
		// *                  | ELSE
		// *                  | END
		// *                  | WHEN
		// *                  | THEN
		// *                  | L_0X
		// *                   ;
		// */ ID | 'CYPHER' | 'EXPLAIN' | 'PROFILE' | 'USING' | 'PERIODIC' | 'COMMIT' | 'UNION' | 'ALL' | 'CREATE' | 'INDEX' |
		//'ON' | 'DROP' | 'CONSTRAINT' | 'ASSERT' | 'IS' | 'UNIQUE' | 'EXISTS' | 'LOAD' | 'CSV' | 'WITH' | 'HEADERS' | 'FROM' |
		//'AS' | 'FIELDTERMINATOR' | 'OPTIONAL' | 'MATCH' | 'UNWIND' | 'MERGE' | 'SET' | 'DELETE' | 'DETACH' | 'REMOVE' |
		//'FOREACH' | 'IN' | 'DISTINCT' | 'RETURN' | 'ORDER' | 'BY' | 'SKIP' | 'LIMIT' | 'DESCENDING' | 'DESC' | 'ASCENDING' |
		//'ASC' | 'JOIN' | 'SCAN' | 'START' | 'NODE' | 'RELATIONSHIP' | 'REL' | 'WHERE' | 'SHORTESTPATH' | 'ALLSHORTESTPATHS' |
		//'OR' | 'XOR' | 'AND' | 'NOT' | 'STARTS' | 'ENDS' | 'CONTAINS' | 'NULL' | 'TRUE' | 'FALSE' | 'COUNT' | 'FILTER' |
		//'EXTRACT' | 'ANY' | 'NONE' | 'SINGLE' | 'REDUCE' | 'CASE' | 'ELSE' | 'END' | 'WHEN' | 'THEN'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*
		// * symbolicNameString : UnescapedSymbolicNameString
		// *                  | EscapedSymbolicNameString
		// *                  | CYPHER
		// *                  | EXPLAIN
		// *                  | PROFILE
		// *                  | USING
		// *                  | PERIODIC
		// *                  | COMMIT
		// *                  | UNION
		// *                  | ALL
		// *                  | CREATE
		// *                  | INDEX
		// *                  | ON
		// *                  | DROP
		// *                  | CONSTRAINT
		// *                  | ASSERT
		// *                  | IS
		// *                  | UNIQUE
		// *                  | EXISTS
		// *                  | LOAD
		// *                  | CSV
		// *                  | WITH
		// *                  | HEADERS
		// *                  | FROM
		// *                  | AS
		// *                  | FIELDTERMINATOR
		// *                  | OPTIONAL
		// *                  | MATCH
		// *                  | UNWIND
		// *                  | MERGE
		// *                  | SET
		// *                  | DELETE
		// *                  | DETACH
		// *                  | REMOVE
		// *                  | FOREACH
		// *                  | IN
		// *                  | DISTINCT
		// *                  | RETURN
		// *                  | ORDER
		// *                  | BY
		// *                  | L_SKIP
		// *                  | LIMIT
		// *                  | DESCENDING
		// *                  | DESC
		// *                  | ASCENDING
		// *                  | ASC
		// *                  | JOIN
		// *                  | SCAN
		// *                  | START
		// *                  | NODE
		// *                  | RELATIONSHIP
		// *                  | REL
		// *                  | WHERE
		// *                  | SHORTESTPATH
		// *                  | ALLSHORTESTPATHS
		// *                  | OR
		// *                  | XOR
		// *                  | AND
		// *                  | NOT
		// *                  | STARTS
		// *                  | ENDS
		// *                  | CONTAINS
		// *                  | NULL
		// *                  | TRUE
		// *                  | FALSE
		// *                  | COUNT
		// *                  | FILTER
		// *                  | EXTRACT
		// *                  | ANY
		// *                  | NONE
		// *                  | SINGLE
		// *                  | REDUCE
		// *                  | CASE
		// *                  | ELSE
		// *                  | END
		// *                  | WHEN
		// *                  | THEN
		// *                  | L_0X
		// *                   ;
		// */ ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//'CYPHER'
		public Keyword getCYPHERKeyword_1() { return cCYPHERKeyword_1; }
		
		//'EXPLAIN'
		public Keyword getEXPLAINKeyword_2() { return cEXPLAINKeyword_2; }
		
		//'PROFILE'
		public Keyword getPROFILEKeyword_3() { return cPROFILEKeyword_3; }
		
		//'USING'
		public Keyword getUSINGKeyword_4() { return cUSINGKeyword_4; }
		
		//'PERIODIC'
		public Keyword getPERIODICKeyword_5() { return cPERIODICKeyword_5; }
		
		//'COMMIT'
		public Keyword getCOMMITKeyword_6() { return cCOMMITKeyword_6; }
		
		//'UNION'
		public Keyword getUNIONKeyword_7() { return cUNIONKeyword_7; }
		
		//'ALL'
		public Keyword getALLKeyword_8() { return cALLKeyword_8; }
		
		//'CREATE'
		public Keyword getCREATEKeyword_9() { return cCREATEKeyword_9; }
		
		//'INDEX'
		public Keyword getINDEXKeyword_10() { return cINDEXKeyword_10; }
		
		//'ON'
		public Keyword getONKeyword_11() { return cONKeyword_11; }
		
		//'DROP'
		public Keyword getDROPKeyword_12() { return cDROPKeyword_12; }
		
		//'CONSTRAINT'
		public Keyword getCONSTRAINTKeyword_13() { return cCONSTRAINTKeyword_13; }
		
		//'ASSERT'
		public Keyword getASSERTKeyword_14() { return cASSERTKeyword_14; }
		
		//'IS'
		public Keyword getISKeyword_15() { return cISKeyword_15; }
		
		//'UNIQUE'
		public Keyword getUNIQUEKeyword_16() { return cUNIQUEKeyword_16; }
		
		//'EXISTS'
		public Keyword getEXISTSKeyword_17() { return cEXISTSKeyword_17; }
		
		//'LOAD'
		public Keyword getLOADKeyword_18() { return cLOADKeyword_18; }
		
		//'CSV'
		public Keyword getCSVKeyword_19() { return cCSVKeyword_19; }
		
		//'WITH'
		public Keyword getWITHKeyword_20() { return cWITHKeyword_20; }
		
		//'HEADERS'
		public Keyword getHEADERSKeyword_21() { return cHEADERSKeyword_21; }
		
		//'FROM'
		public Keyword getFROMKeyword_22() { return cFROMKeyword_22; }
		
		//'AS'
		public Keyword getASKeyword_23() { return cASKeyword_23; }
		
		//'FIELDTERMINATOR'
		public Keyword getFIELDTERMINATORKeyword_24() { return cFIELDTERMINATORKeyword_24; }
		
		//'OPTIONAL'
		public Keyword getOPTIONALKeyword_25() { return cOPTIONALKeyword_25; }
		
		//'MATCH'
		public Keyword getMATCHKeyword_26() { return cMATCHKeyword_26; }
		
		//'UNWIND'
		public Keyword getUNWINDKeyword_27() { return cUNWINDKeyword_27; }
		
		//'MERGE'
		public Keyword getMERGEKeyword_28() { return cMERGEKeyword_28; }
		
		//'SET'
		public Keyword getSETKeyword_29() { return cSETKeyword_29; }
		
		//'DELETE'
		public Keyword getDELETEKeyword_30() { return cDELETEKeyword_30; }
		
		//'DETACH'
		public Keyword getDETACHKeyword_31() { return cDETACHKeyword_31; }
		
		//'REMOVE'
		public Keyword getREMOVEKeyword_32() { return cREMOVEKeyword_32; }
		
		//'FOREACH'
		public Keyword getFOREACHKeyword_33() { return cFOREACHKeyword_33; }
		
		//'IN'
		public Keyword getINKeyword_34() { return cINKeyword_34; }
		
		//'DISTINCT'
		public Keyword getDISTINCTKeyword_35() { return cDISTINCTKeyword_35; }
		
		//'RETURN'
		public Keyword getRETURNKeyword_36() { return cRETURNKeyword_36; }
		
		//'ORDER'
		public Keyword getORDERKeyword_37() { return cORDERKeyword_37; }
		
		//'BY'
		public Keyword getBYKeyword_38() { return cBYKeyword_38; }
		
		//'SKIP'
		public Keyword getSKIPKeyword_39() { return cSKIPKeyword_39; }
		
		//'LIMIT'
		public Keyword getLIMITKeyword_40() { return cLIMITKeyword_40; }
		
		//'DESCENDING'
		public Keyword getDESCENDINGKeyword_41() { return cDESCENDINGKeyword_41; }
		
		//'DESC'
		public Keyword getDESCKeyword_42() { return cDESCKeyword_42; }
		
		//'ASCENDING'
		public Keyword getASCENDINGKeyword_43() { return cASCENDINGKeyword_43; }
		
		//'ASC'
		public Keyword getASCKeyword_44() { return cASCKeyword_44; }
		
		//'JOIN'
		public Keyword getJOINKeyword_45() { return cJOINKeyword_45; }
		
		//'SCAN'
		public Keyword getSCANKeyword_46() { return cSCANKeyword_46; }
		
		//'START'
		public Keyword getSTARTKeyword_47() { return cSTARTKeyword_47; }
		
		//'NODE'
		public Keyword getNODEKeyword_48() { return cNODEKeyword_48; }
		
		//'RELATIONSHIP'
		public Keyword getRELATIONSHIPKeyword_49() { return cRELATIONSHIPKeyword_49; }
		
		//'REL'
		public Keyword getRELKeyword_50() { return cRELKeyword_50; }
		
		//'WHERE'
		public Keyword getWHEREKeyword_51() { return cWHEREKeyword_51; }
		
		//'SHORTESTPATH'
		public Keyword getSHORTESTPATHKeyword_52() { return cSHORTESTPATHKeyword_52; }
		
		//'ALLSHORTESTPATHS'
		public Keyword getALLSHORTESTPATHSKeyword_53() { return cALLSHORTESTPATHSKeyword_53; }
		
		//'OR'
		public Keyword getORKeyword_54() { return cORKeyword_54; }
		
		//'XOR'
		public Keyword getXORKeyword_55() { return cXORKeyword_55; }
		
		//'AND'
		public Keyword getANDKeyword_56() { return cANDKeyword_56; }
		
		//'NOT'
		public Keyword getNOTKeyword_57() { return cNOTKeyword_57; }
		
		//'STARTS'
		public Keyword getSTARTSKeyword_58() { return cSTARTSKeyword_58; }
		
		//'ENDS'
		public Keyword getENDSKeyword_59() { return cENDSKeyword_59; }
		
		//'CONTAINS'
		public Keyword getCONTAINSKeyword_60() { return cCONTAINSKeyword_60; }
		
		//'NULL'
		public Keyword getNULLKeyword_61() { return cNULLKeyword_61; }
		
		//'TRUE'
		public Keyword getTRUEKeyword_62() { return cTRUEKeyword_62; }
		
		//'FALSE'
		public Keyword getFALSEKeyword_63() { return cFALSEKeyword_63; }
		
		//'COUNT'
		public Keyword getCOUNTKeyword_64() { return cCOUNTKeyword_64; }
		
		//'FILTER'
		public Keyword getFILTERKeyword_65() { return cFILTERKeyword_65; }
		
		//'EXTRACT'
		public Keyword getEXTRACTKeyword_66() { return cEXTRACTKeyword_66; }
		
		//'ANY'
		public Keyword getANYKeyword_67() { return cANYKeyword_67; }
		
		//'NONE'
		public Keyword getNONEKeyword_68() { return cNONEKeyword_68; }
		
		//'SINGLE'
		public Keyword getSINGLEKeyword_69() { return cSINGLEKeyword_69; }
		
		//'REDUCE'
		public Keyword getREDUCEKeyword_70() { return cREDUCEKeyword_70; }
		
		//'CASE'
		public Keyword getCASEKeyword_71() { return cCASEKeyword_71; }
		
		//'ELSE'
		public Keyword getELSEKeyword_72() { return cELSEKeyword_72; }
		
		//'END'
		public Keyword getENDKeyword_73() { return cENDKeyword_73; }
		
		//'WHEN'
		public Keyword getWHENKeyword_74() { return cWHENKeyword_74; }
		
		//'THEN'
		public Keyword getTHENKeyword_75() { return cTHENKeyword_75; }
	}
	
	
	private final CypherElements pCypher;
	private final QueryOptionsElements pQueryOptions;
	private final CypherOptionElements pCypherOption;
	private final VersionNumberElements pVersionNumber;
	private final ConfigurationOptionElements pConfigurationOption;
	private final StatementElements pStatement;
	private final QueryElements pQuery;
	private final RegularQueryElements pRegularQuery;
	private final BulkImportQueryElements pBulkImportQuery;
	private final SingleQueryElements pSingleQuery;
	private final PeriodicCommitHintElements pPeriodicCommitHint;
	private final LoadCSVQueryElements pLoadCSVQuery;
	private final UnionElements pUnion;
	private final ClauseElements pClause;
	private final CommandElements pCommand;
	private final CreateUniqueConstraintElements pCreateUniqueConstraint;
	private final CreateNodePropertyExistenceConstraintElements pCreateNodePropertyExistenceConstraint;
	private final CreateRelationshipPropertyExistenceConstraintElements pCreateRelationshipPropertyExistenceConstraint;
	private final CreateIndexElements pCreateIndex;
	private final DropUniqueConstraintElements pDropUniqueConstraint;
	private final DropNodePropertyExistenceConstraintElements pDropNodePropertyExistenceConstraint;
	private final DropRelationshipPropertyExistenceConstraintElements pDropRelationshipPropertyExistenceConstraint;
	private final DropIndexElements pDropIndex;
	private final IndexElements pIndex;
	private final UniqueConstraintElements pUniqueConstraint;
	private final NodePropertyExistenceConstraintElements pNodePropertyExistenceConstraint;
	private final RelationshipPropertyExistenceConstraintElements pRelationshipPropertyExistenceConstraint;
	private final RelationshipPatternSyntaxElements pRelationshipPatternSyntax;
	private final LoadCSVElements pLoadCSV;
	private final LoadCSVWithHeadersElements pLoadCSVWithHeaders;
	private final MatchElements pMatch;
	private final UnwindElements pUnwind;
	private final MergeElements pMerge;
	private final MergeActionElements pMergeAction;
	private final CreateElements pCreate;
	private final SetElements pSet;
	private final SetItemElements pSetItem;
	private final DeleteElements pDelete;
	private final RemoveElements pRemove;
	private final RemoveItemElements pRemoveItem;
	private final ForeachElements pForeach;
	private final InQueryCallElements pInQueryCall;
	private final StandaloneCallElements pStandaloneCall;
	private final YieldItemsElements pYieldItems;
	private final YieldItemElements pYieldItem;
	private final WithElements pWith;
	private final ReturnElements pReturn;
	private final ReturnBodyElements pReturnBody;
	private final ReturnItemsElements pReturnItems;
	private final ReturnItemElements pReturnItem;
	private final OrderElements pOrder;
	private final SkipElements pSkip;
	private final LimitElements pLimit;
	private final SortItemElements pSortItem;
	private final HintElements pHint;
	private final StartElements pStart;
	private final StartPointElements pStartPoint;
	private final LookupElements pLookup;
	private final NodeLookupElements pNodeLookup;
	private final RelationshipLookupElements pRelationshipLookup;
	private final IdentifiedIndexLookupElements pIdentifiedIndexLookup;
	private final IndexQueryElements pIndexQuery;
	private final IdLookupElements pIdLookup;
	private final LiteralIdsElements pLiteralIds;
	private final WhereElements pWhere;
	private final PatternElements pPattern;
	private final PatternPartElements pPatternPart;
	private final AnonymousPatternPartElements pAnonymousPatternPart;
	private final ShortestPathPatternElements pShortestPathPattern;
	private final PatternElementElements pPatternElement;
	private final NodePatternElements pNodePattern;
	private final PatternElementChainElements pPatternElementChain;
	private final RelationshipPatternElements pRelationshipPattern;
	private final RelationshipDetailElements pRelationshipDetail;
	private final PropertiesElements pProperties;
	private final RelTypeElements pRelType;
	private final RelationshipTypesElements pRelationshipTypes;
	private final NodeLabelsElements pNodeLabels;
	private final NodeLabelElements pNodeLabel;
	private final RangeLiteralElements pRangeLiteral;
	private final LabelNameElements pLabelName;
	private final RelTypeNameElements pRelTypeName;
	private final ExpressionElements pExpression;
	private final ExpressionOrElements pExpressionOr;
	private final ExpressionXorElements pExpressionXor;
	private final ExpressionAndElements pExpressionAnd;
	private final ExpressionNotElements pExpressionNot;
	private final ExpressionComparisonElements pExpressionComparison;
	private final ExpressionPlusMinusElements pExpressionPlusMinus;
	private final ExpressionMulDivElements pExpressionMulDiv;
	private final ExpressionPowerElements pExpressionPower;
	private final ExpressionUnaryPlusMinusElements pExpressionUnaryPlusMinus;
	private final Expression3Elements pExpression3;
	private final ExpressionNodeLabelsAndPropertyLookupElements pExpressionNodeLabelsAndPropertyLookup;
	private final AtomElements pAtom;
	private final ReduceElements pReduce;
	private final ParenthesizedExpressionElements pParenthesizedExpression;
	private final RelationshipsPatternElements pRelationshipsPattern;
	private final FilterExpressionElements pFilterExpression;
	private final IdInCollElements pIdInColl;
	private final FunctionInvocationElements pFunctionInvocation;
	private final FunctionNameElements pFunctionName;
	private final ExplicitProcedureInvocationElements pExplicitProcedureInvocation;
	private final ProcedureResultFieldElements pProcedureResultField;
	private final ImplicitProcedureInvocationElements pImplicitProcedureInvocation;
	private final ProcedureNameElements pProcedureName;
	private final NamespaceElements pNamespace;
	private final ListComprehensionElements pListComprehension;
	private final PatternComprehensionElements pPatternComprehension;
	private final PropertyLookupElements pPropertyLookup;
	private final CaseExpressionElements pCaseExpression;
	private final CaseAlternativesElements pCaseAlternatives;
	private final VariableDeclarationElements pVariableDeclaration;
	private final MapLiteralElements pMapLiteral;
	private final MapLiteralEntryElements pMapLiteralEntry;
	private final LegacyParameterElements pLegacyParameter;
	private final ParameterElements pParameter;
	private final PropertyExpressionElements pPropertyExpression;
	private final PropertyKeyNameElements pPropertyKeyName;
	private final LeftArrowHeadElements pLeftArrowHead;
	private final RightArrowHeadElements pRightArrowHead;
	private final DashElements pDash;
	private final DecimalIntegerElements pDecimalInteger;
	private final NumberElements pNumber;
	private final SYMBOLIC_NAME_XElements pSYMBOLIC_NAME_X;
	private final TerminalRule tID;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tSTRING_LITERAL;
	private final TerminalRule tHEX;
	private final TerminalRule tINT;
	private final TerminalRule tDECIMAL;
	
	private final Grammar grammar;

	@Inject
	public OpenCypherGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pCypher = new CypherElements();
		this.pQueryOptions = new QueryOptionsElements();
		this.pCypherOption = new CypherOptionElements();
		this.pVersionNumber = new VersionNumberElements();
		this.pConfigurationOption = new ConfigurationOptionElements();
		this.pStatement = new StatementElements();
		this.pQuery = new QueryElements();
		this.pRegularQuery = new RegularQueryElements();
		this.pBulkImportQuery = new BulkImportQueryElements();
		this.pSingleQuery = new SingleQueryElements();
		this.pPeriodicCommitHint = new PeriodicCommitHintElements();
		this.pLoadCSVQuery = new LoadCSVQueryElements();
		this.pUnion = new UnionElements();
		this.pClause = new ClauseElements();
		this.pCommand = new CommandElements();
		this.pCreateUniqueConstraint = new CreateUniqueConstraintElements();
		this.pCreateNodePropertyExistenceConstraint = new CreateNodePropertyExistenceConstraintElements();
		this.pCreateRelationshipPropertyExistenceConstraint = new CreateRelationshipPropertyExistenceConstraintElements();
		this.pCreateIndex = new CreateIndexElements();
		this.pDropUniqueConstraint = new DropUniqueConstraintElements();
		this.pDropNodePropertyExistenceConstraint = new DropNodePropertyExistenceConstraintElements();
		this.pDropRelationshipPropertyExistenceConstraint = new DropRelationshipPropertyExistenceConstraintElements();
		this.pDropIndex = new DropIndexElements();
		this.pIndex = new IndexElements();
		this.pUniqueConstraint = new UniqueConstraintElements();
		this.pNodePropertyExistenceConstraint = new NodePropertyExistenceConstraintElements();
		this.pRelationshipPropertyExistenceConstraint = new RelationshipPropertyExistenceConstraintElements();
		this.pRelationshipPatternSyntax = new RelationshipPatternSyntaxElements();
		this.pLoadCSV = new LoadCSVElements();
		this.pLoadCSVWithHeaders = new LoadCSVWithHeadersElements();
		this.pMatch = new MatchElements();
		this.pUnwind = new UnwindElements();
		this.pMerge = new MergeElements();
		this.pMergeAction = new MergeActionElements();
		this.pCreate = new CreateElements();
		this.pSet = new SetElements();
		this.pSetItem = new SetItemElements();
		this.pDelete = new DeleteElements();
		this.pRemove = new RemoveElements();
		this.pRemoveItem = new RemoveItemElements();
		this.pForeach = new ForeachElements();
		this.pInQueryCall = new InQueryCallElements();
		this.pStandaloneCall = new StandaloneCallElements();
		this.pYieldItems = new YieldItemsElements();
		this.pYieldItem = new YieldItemElements();
		this.pWith = new WithElements();
		this.pReturn = new ReturnElements();
		this.pReturnBody = new ReturnBodyElements();
		this.pReturnItems = new ReturnItemsElements();
		this.pReturnItem = new ReturnItemElements();
		this.pOrder = new OrderElements();
		this.pSkip = new SkipElements();
		this.pLimit = new LimitElements();
		this.pSortItem = new SortItemElements();
		this.pHint = new HintElements();
		this.pStart = new StartElements();
		this.pStartPoint = new StartPointElements();
		this.pLookup = new LookupElements();
		this.pNodeLookup = new NodeLookupElements();
		this.pRelationshipLookup = new RelationshipLookupElements();
		this.pIdentifiedIndexLookup = new IdentifiedIndexLookupElements();
		this.pIndexQuery = new IndexQueryElements();
		this.pIdLookup = new IdLookupElements();
		this.pLiteralIds = new LiteralIdsElements();
		this.pWhere = new WhereElements();
		this.pPattern = new PatternElements();
		this.pPatternPart = new PatternPartElements();
		this.pAnonymousPatternPart = new AnonymousPatternPartElements();
		this.pShortestPathPattern = new ShortestPathPatternElements();
		this.pPatternElement = new PatternElementElements();
		this.pNodePattern = new NodePatternElements();
		this.pPatternElementChain = new PatternElementChainElements();
		this.pRelationshipPattern = new RelationshipPatternElements();
		this.pRelationshipDetail = new RelationshipDetailElements();
		this.pProperties = new PropertiesElements();
		this.pRelType = new RelTypeElements();
		this.pRelationshipTypes = new RelationshipTypesElements();
		this.pNodeLabels = new NodeLabelsElements();
		this.pNodeLabel = new NodeLabelElements();
		this.pRangeLiteral = new RangeLiteralElements();
		this.pLabelName = new LabelNameElements();
		this.pRelTypeName = new RelTypeNameElements();
		this.pExpression = new ExpressionElements();
		this.pExpressionOr = new ExpressionOrElements();
		this.pExpressionXor = new ExpressionXorElements();
		this.pExpressionAnd = new ExpressionAndElements();
		this.pExpressionNot = new ExpressionNotElements();
		this.pExpressionComparison = new ExpressionComparisonElements();
		this.pExpressionPlusMinus = new ExpressionPlusMinusElements();
		this.pExpressionMulDiv = new ExpressionMulDivElements();
		this.pExpressionPower = new ExpressionPowerElements();
		this.pExpressionUnaryPlusMinus = new ExpressionUnaryPlusMinusElements();
		this.pExpression3 = new Expression3Elements();
		this.pExpressionNodeLabelsAndPropertyLookup = new ExpressionNodeLabelsAndPropertyLookupElements();
		this.pAtom = new AtomElements();
		this.pReduce = new ReduceElements();
		this.pParenthesizedExpression = new ParenthesizedExpressionElements();
		this.pRelationshipsPattern = new RelationshipsPatternElements();
		this.pFilterExpression = new FilterExpressionElements();
		this.pIdInColl = new IdInCollElements();
		this.pFunctionInvocation = new FunctionInvocationElements();
		this.pFunctionName = new FunctionNameElements();
		this.pExplicitProcedureInvocation = new ExplicitProcedureInvocationElements();
		this.pProcedureResultField = new ProcedureResultFieldElements();
		this.pImplicitProcedureInvocation = new ImplicitProcedureInvocationElements();
		this.pProcedureName = new ProcedureNameElements();
		this.pNamespace = new NamespaceElements();
		this.pListComprehension = new ListComprehensionElements();
		this.pPatternComprehension = new PatternComprehensionElements();
		this.pPropertyLookup = new PropertyLookupElements();
		this.pCaseExpression = new CaseExpressionElements();
		this.pCaseAlternatives = new CaseAlternativesElements();
		this.pVariableDeclaration = new VariableDeclarationElements();
		this.pMapLiteral = new MapLiteralElements();
		this.pMapLiteralEntry = new MapLiteralEntryElements();
		this.pLegacyParameter = new LegacyParameterElements();
		this.pParameter = new ParameterElements();
		this.pPropertyExpression = new PropertyExpressionElements();
		this.pPropertyKeyName = new PropertyKeyNameElements();
		this.pLeftArrowHead = new LeftArrowHeadElements();
		this.pRightArrowHead = new RightArrowHeadElements();
		this.pDash = new DashElements();
		this.pDecimalInteger = new DecimalIntegerElements();
		this.pNumber = new NumberElements();
		this.pSYMBOLIC_NAME_X = new SYMBOLIC_NAME_XElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ID");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.WS");
		this.tSTRING_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.STRING_LITERAL");
		this.tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.HEX");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.INT");
		this.tDECIMAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.slizaa.neo4j.opencypher.OpenCypher.DECIMAL");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.slizaa.neo4j.opencypher.OpenCypher".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Cypher:
	//	{Cypher} queryOptions=QueryOptions statement=Statement ';'?;
	public CypherElements getCypherAccess() {
		return pCypher;
	}
	
	public ParserRule getCypherRule() {
		return getCypherAccess().getRule();
	}
	
	//QueryOptions:
	//	{AllOptions} (explain?='EXPLAIN'? & profile?='PROFILE'? & cypherOption+=CypherOption*);
	public QueryOptionsElements getQueryOptionsAccess() {
		return pQueryOptions;
	}
	
	public ParserRule getQueryOptionsRule() {
		return getQueryOptionsAccess().getRule();
	}
	
	//CypherOption:
	//	{CypherOption} 'CYPHER' versionNumber=VersionNumber? configurationOption+=ConfigurationOption*;
	public CypherOptionElements getCypherOptionAccess() {
		return pCypherOption;
	}
	
	public ParserRule getCypherOptionRule() {
		return getCypherOptionAccess().getRule();
	}
	
	//VersionNumber:
	//	versionNumber=Number;
	public VersionNumberElements getVersionNumberAccess() {
		return pVersionNumber;
	}
	
	public ParserRule getVersionNumberRule() {
		return getVersionNumberAccess().getRule();
	}
	
	//ConfigurationOption:
	//	key=SYMBOLIC_NAME_X '=' value=SYMBOLIC_NAME_X;
	public ConfigurationOptionElements getConfigurationOptionAccess() {
		return pConfigurationOption;
	}
	
	public ParserRule getConfigurationOptionRule() {
		return getConfigurationOptionAccess().getRule();
	}
	
	//Statement:
	//	Command | Query;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//Query:
	//	RegularQuery | StandaloneCall | BulkImportQuery;
	public QueryElements getQueryAccess() {
		return pQuery;
	}
	
	public ParserRule getQueryRule() {
		return getQueryAccess().getRule();
	}
	
	//RegularQuery:
	//	SingleQuery ({CombinedQuery.singleQuery=current} union+=Union+)?;
	public RegularQueryElements getRegularQueryAccess() {
		return pRegularQuery;
	}
	
	public ParserRule getRegularQueryRule() {
		return getRegularQueryAccess().getRule();
	}
	
	//BulkImportQuery:
	//	periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery;
	public BulkImportQueryElements getBulkImportQueryAccess() {
		return pBulkImportQuery;
	}
	
	public ParserRule getBulkImportQueryRule() {
		return getBulkImportQueryAccess().getRule();
	}
	
	//SingleQuery:
	//	clauses+=Clause clauses+=Clause*;
	public SingleQueryElements getSingleQueryAccess() {
		return pSingleQuery;
	}
	
	public ParserRule getSingleQueryRule() {
		return getSingleQueryAccess().getRule();
	}
	
	//PeriodicCommitHint:
	//	{PeriodicCommitHint} 'USING' 'PERIODIC' 'COMMIT' numberOfRowsPerCommit=DecimalInteger?;
	public PeriodicCommitHintElements getPeriodicCommitHintAccess() {
		return pPeriodicCommitHint;
	}
	
	public ParserRule getPeriodicCommitHintRule() {
		return getPeriodicCommitHintAccess().getRule();
	}
	
	//LoadCSVQuery:
	//	loadCSV=LoadCSV clauses+=Clause*;
	public LoadCSVQueryElements getLoadCSVQueryAccess() {
		return pLoadCSVQuery;
	}
	
	public ParserRule getLoadCSVQueryRule() {
		return getLoadCSVQueryAccess().getRule();
	}
	
	//Union:
	//	'UNION' all?='ALL'? singleQuery=SingleQuery;
	public UnionElements getUnionAccess() {
		return pUnion;
	}
	
	public ParserRule getUnionRule() {
		return getUnionAccess().getRule();
	}
	
	//Clause:
	//	LoadCSV | Start | Match | Unwind | Merge | Create | Set | Delete | Remove | Foreach | With | Return | InQueryCall;
	public ClauseElements getClauseAccess() {
		return pClause;
	}
	
	public ParserRule getClauseRule() {
		return getClauseAccess().getRule();
	}
	
	//Command:
	//	CreateIndex | DropIndex | CreateUniqueConstraint | DropUniqueConstraint | CreateNodePropertyExistenceConstraint |
	//	DropNodePropertyExistenceConstraint | CreateRelationshipPropertyExistenceConstraint |
	//	DropRelationshipPropertyExistenceConstraint;
	public CommandElements getCommandAccess() {
		return pCommand;
	}
	
	public ParserRule getCommandRule() {
		return getCommandAccess().getRule();
	}
	
	//CreateUniqueConstraint: /*
	// * createUniqueConstraint : CREATE sp uniqueConstraint ;
	// */ 'CREATE' UniqueConstraint;
	public CreateUniqueConstraintElements getCreateUniqueConstraintAccess() {
		return pCreateUniqueConstraint;
	}
	
	public ParserRule getCreateUniqueConstraintRule() {
		return getCreateUniqueConstraintAccess().getRule();
	}
	
	//CreateNodePropertyExistenceConstraint: /*
	// * createNodePropertyExistenceConstraint : CREATE sp nodePropertyExistenceConstraint ;
	// */ 'CREATE' NodePropertyExistenceConstraint;
	public CreateNodePropertyExistenceConstraintElements getCreateNodePropertyExistenceConstraintAccess() {
		return pCreateNodePropertyExistenceConstraint;
	}
	
	public ParserRule getCreateNodePropertyExistenceConstraintRule() {
		return getCreateNodePropertyExistenceConstraintAccess().getRule();
	}
	
	//CreateRelationshipPropertyExistenceConstraint: /*
	// * createRelationshipPropertyExistenceConstraint : CREATE sp relationshipPropertyExistenceConstraint ;
	// */ 'CREATE' RelationshipPropertyExistenceConstraint;
	public CreateRelationshipPropertyExistenceConstraintElements getCreateRelationshipPropertyExistenceConstraintAccess() {
		return pCreateRelationshipPropertyExistenceConstraint;
	}
	
	public ParserRule getCreateRelationshipPropertyExistenceConstraintRule() {
		return getCreateRelationshipPropertyExistenceConstraintAccess().getRule();
	}
	
	//CreateIndex: /*
	// * createIndex : CREATE sp index ;
	// */ 'CREATE' index=Index;
	public CreateIndexElements getCreateIndexAccess() {
		return pCreateIndex;
	}
	
	public ParserRule getCreateIndexRule() {
		return getCreateIndexAccess().getRule();
	}
	
	//DropUniqueConstraint: /*
	// * dropUniqueConstraint : DROP sp uniqueConstraint ;
	// */ 'DROP' uniqueConstraint=UniqueConstraint;
	public DropUniqueConstraintElements getDropUniqueConstraintAccess() {
		return pDropUniqueConstraint;
	}
	
	public ParserRule getDropUniqueConstraintRule() {
		return getDropUniqueConstraintAccess().getRule();
	}
	
	//DropNodePropertyExistenceConstraint: /*
	// * dropNodePropertyExistenceConstraint : DROP sp nodePropertyExistenceConstraint ;
	// */ 'DROP' nodePropertyExistenceConstraint=NodePropertyExistenceConstraint;
	public DropNodePropertyExistenceConstraintElements getDropNodePropertyExistenceConstraintAccess() {
		return pDropNodePropertyExistenceConstraint;
	}
	
	public ParserRule getDropNodePropertyExistenceConstraintRule() {
		return getDropNodePropertyExistenceConstraintAccess().getRule();
	}
	
	//DropRelationshipPropertyExistenceConstraint: /*
	// * dropRelationshipPropertyExistenceConstraint : DROP sp relationshipPropertyExistenceConstraint ;
	// */ 'DROP' relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint;
	public DropRelationshipPropertyExistenceConstraintElements getDropRelationshipPropertyExistenceConstraintAccess() {
		return pDropRelationshipPropertyExistenceConstraint;
	}
	
	public ParserRule getDropRelationshipPropertyExistenceConstraintRule() {
		return getDropRelationshipPropertyExistenceConstraintAccess().getRule();
	}
	
	//DropIndex: /*
	// * dropIndex : DROP sp index ;
	// */ 'DROP' index=Index;
	public DropIndexElements getDropIndexAccess() {
		return pDropIndex;
	}
	
	public ParserRule getDropIndexRule() {
		return getDropIndexAccess().getRule();
	}
	
	//Index: /*
	// * index : INDEX sp ON ws nodeLabel '(' propertyKeyName ')' ;
	// */ 'INDEX' 'ON' nodeLabel=NodeLabel '(' propertyKeyName=PropertyKeyName ')';
	public IndexElements getIndexAccess() {
		return pIndex;
	}
	
	public ParserRule getIndexRule() {
		return getIndexAccess().getRule();
	}
	
	//UniqueConstraint: /*
	// * uniqueConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp propertyExpression sp IS sp UNIQUE ;
	// */ 'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT'
	//	propertyExpression=PropertyExpression 'IS' 'UNIQUE';
	public UniqueConstraintElements getUniqueConstraintAccess() {
		return pUniqueConstraint;
	}
	
	public ParserRule getUniqueConstraintRule() {
		return getUniqueConstraintAccess().getRule();
	}
	
	//NodePropertyExistenceConstraint: /*
	// * nodePropertyExistenceConstraint : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
	// */ 'CONSTRAINT' 'ON' '(' variable=VariableDeclaration nodeLabel=NodeLabel ')' 'ASSERT' 'EXISTS' '('
	//	propertyExpression=PropertyExpression ')';
	public NodePropertyExistenceConstraintElements getNodePropertyExistenceConstraintAccess() {
		return pNodePropertyExistenceConstraint;
	}
	
	public ParserRule getNodePropertyExistenceConstraintRule() {
		return getNodePropertyExistenceConstraintAccess().getRule();
	}
	
	//RelationshipPropertyExistenceConstraint: /*
	// * relationshipPropertyExistenceConstraint : CONSTRAINT sp ON ws relationshipPatternSyntax ws ASSERT sp EXISTS ws '(' propertyExpression ')' ;
	// */ 'CONSTRAINT' 'ON' relationshipPattern=RelationshipPatternSyntax 'ASSERT' 'EXISTS' '('
	//	propertyExpression=PropertyExpression ')';
	public RelationshipPropertyExistenceConstraintElements getRelationshipPropertyExistenceConstraintAccess() {
		return pRelationshipPropertyExistenceConstraint;
	}
	
	public ParserRule getRelationshipPropertyExistenceConstraintRule() {
		return getRelationshipPropertyExistenceConstraintAccess().getRule();
	}
	
	//RelationshipPatternSyntax:
	//	'(' ')' incoming?=LeftArrowHead? Dash '[' variable=VariableDeclaration relType=RelType ']' Dash
	//	outgoing?=RightArrowHead? '('
	//	')';
	public RelationshipPatternSyntaxElements getRelationshipPatternSyntaxAccess() {
		return pRelationshipPatternSyntax;
	}
	
	public ParserRule getRelationshipPatternSyntaxRule() {
		return getRelationshipPatternSyntaxAccess().getRule();
	}
	
	//LoadCSV:
	//	{LoadCSV} 'LOAD' 'CSV' withHeaders?=LoadCSVWithHeaders? 'FROM' expression=Expression 'AS' variable=VariableDeclaration
	//	('FIELDTERMINATOR' fieldterminator=STRING_LITERAL)?;
	public LoadCSVElements getLoadCSVAccess() {
		return pLoadCSV;
	}
	
	public ParserRule getLoadCSVRule() {
		return getLoadCSVAccess().getRule();
	}
	
	//LoadCSVWithHeaders:
	//	'WITH' 'HEADERS';
	public LoadCSVWithHeadersElements getLoadCSVWithHeadersAccess() {
		return pLoadCSVWithHeaders;
	}
	
	public ParserRule getLoadCSVWithHeadersRule() {
		return getLoadCSVWithHeadersAccess().getRule();
	}
	
	//Match:
	//	optional?='OPTIONAL'? 'MATCH' pattern=Pattern hints+=Hint* where=Where?;
	public MatchElements getMatchAccess() {
		return pMatch;
	}
	
	public ParserRule getMatchRule() {
		return getMatchAccess().getRule();
	}
	
	//Unwind: /*
	// * unwind : UNWIND ws expression sp AS sp variable ;
	// */ 'UNWIND' expression=Expression 'AS' variable=VariableDeclaration;
	public UnwindElements getUnwindAccess() {
		return pUnwind;
	}
	
	public ParserRule getUnwindRule() {
		return getUnwindAccess().getRule();
	}
	
	//Merge: /*
	// * merge : MERGE ws patternPart ( sp mergeAction )* ;
	// */ 'MERGE' patternPart=PatternPart mergeActions+=MergeAction*;
	public MergeElements getMergeAccess() {
		return pMerge;
	}
	
	public ParserRule getMergeRule() {
		return getMergeAccess().getRule();
	}
	
	//MergeAction: /*
	// * mergeAction : ( ON sp MATCH sp set )
	// *             | ( ON sp CREATE sp set )
	// *             ;
	// */ 'ON' action=('MATCH' | 'CREATE') set=Set;
	public MergeActionElements getMergeActionAccess() {
		return pMergeAction;
	}
	
	public ParserRule getMergeActionRule() {
		return getMergeActionAccess().getRule();
	}
	
	//Create: /*
	// * create : CREATE ws pattern ;
	// * createUnique : CREATE sp UNIQUE ws pattern ;
	// * 
	// * Comment: We handle 'create' and 'createUnqiue' in the same clause
	// */ 'CREATE' unique?='UNIQUE'? pattern=Pattern;
	public CreateElements getCreateAccess() {
		return pCreate;
	}
	
	public ParserRule getCreateRule() {
		return getCreateAccess().getRule();
	}
	
	//Set: /*
	// * set : SET setItem ( ',' setItem )* ;
	// */ 'SET' setItems+=SetItem (',' setItems+=SetItem)*;
	public SetElements getSetAccess() {
		return pSet;
	}
	
	public ParserRule getSetRule() {
		return getSetAccess().getRule();
	}
	
	//SetItem:
	//	propertyExpression=PropertyExpression '=' expression=Expression | variable=VariableDeclaration '='
	//	expression=Expression | variable=VariableDeclaration '+=' expression=Expression | variable=VariableDeclaration
	//	nodeLabels=NodeLabels;
	public SetItemElements getSetItemAccess() {
		return pSetItem;
	}
	
	public ParserRule getSetItemRule() {
		return getSetItemAccess().getRule();
	}
	
	//Delete:
	//	detach?='DETACH'? 'DELETE' expressions+=Expression (',' expressions+=Expression)*;
	public DeleteElements getDeleteAccess() {
		return pDelete;
	}
	
	public ParserRule getDeleteRule() {
		return getDeleteAccess().getRule();
	}
	
	//Remove: /*
	// * remove : REMOVE sp removeItem ( ws ',' ws removeItem )* ;
	// */ 'REMOVE' removeItems+=RemoveItem (',' removeItems+=RemoveItem)*;
	public RemoveElements getRemoveAccess() {
		return pRemove;
	}
	
	public ParserRule getRemoveRule() {
		return getRemoveAccess().getRule();
	}
	
	//RemoveItem:
	//	{RemoveItemLabel} variable=VariableDeclaration nodeLabels=NodeLabels | {RemoveItemProperty}
	//	propertyExpression=PropertyExpression;
	public RemoveItemElements getRemoveItemAccess() {
		return pRemoveItem;
	}
	
	public ParserRule getRemoveItemRule() {
		return getRemoveItemAccess().getRule();
	}
	
	//Foreach: /*
	// * foreach : FOREACH ws '(' ws variable sp IN sp expression ws '|' ( sp clause )+ ws ')' ;
	// */ 'FOREACH' '(' variable=VariableDeclaration 'IN' expression=Expression '|' clauses+=Clause+ ')';
	public ForeachElements getForeachAccess() {
		return pForeach;
	}
	
	public ParserRule getForeachRule() {
		return getForeachAccess().getRule();
	}
	
	//InQueryCall: /*
	// * inQueryCall : CALL sp explicitProcedureInvocation ( YIELD sp yieldItems )? ;
	// */ 'CALL' invocation=ExplicitProcedureInvocation ('YIELD' yieldItems=YieldItems)?;
	public InQueryCallElements getInQueryCallAccess() {
		return pInQueryCall;
	}
	
	public ParserRule getInQueryCallRule() {
		return getInQueryCallAccess().getRule();
	}
	
	//StandaloneCall: /*
	// * standaloneCall: 'CALL' sp ( ExplicitProcedureInvocation | ImplicitProcedureInvocation ) ( sp YIELD sp YieldItems )? ;
	// */ 'CALL' invocation=(ExplicitProcedureInvocation | ImplicitProcedureInvocation) ('YIELD' yieldItems=YieldItems)?;
	public StandaloneCallElements getStandaloneCallAccess() {
		return pStandaloneCall;
	}
	
	public ParserRule getStandaloneCallRule() {
		return getStandaloneCallAccess().getRule();
	}
	
	//YieldItems:
	//	{YieldItems} (items+=YieldItem (',' items+=YieldItem)* | '-');
	public YieldItemsElements getYieldItemsAccess() {
		return pYieldItems;
	}
	
	public ParserRule getYieldItemsRule() {
		return getYieldItemsAccess().getRule();
	}
	
	//YieldItem:
	//	(field=ProcedureResultField 'AS')? variable=VariableDeclaration;
	public YieldItemElements getYieldItemAccess() {
		return pYieldItem;
	}
	
	public ParserRule getYieldItemRule() {
		return getYieldItemAccess().getRule();
	}
	
	//With: /*
	// * with : ( WITH DISTINCT sp returnBody where? )
	// *      | ( WITH sp returnBody where? );
	// */ 'WITH' distint?='DISTINCT'? returnBody=ReturnBody where=Where?;
	public WithElements getWithAccess() {
		return pWith;
	}
	
	public ParserRule getWithRule() {
		return getWithAccess().getRule();
	}
	
	//Return:
	//	return='RETURN' distinct?='DISTINCT'? body=ReturnBody;
	public ReturnElements getReturnAccess() {
		return pReturn;
	}
	
	public ParserRule getReturnRule() {
		return getReturnAccess().getRule();
	}
	
	//ReturnBody:
	//	returnItems=ReturnItems order=Order? skip=Skip? limit=Limit?;
	public ReturnBodyElements getReturnBodyAccess() {
		return pReturnBody;
	}
	
	public ParserRule getReturnBodyRule() {
		return getReturnBodyAccess().getRule();
	}
	
	//ReturnItems:
	//	{ReturnItems} (all='*' (',' items+=ReturnItem)*) | items+=ReturnItem (',' items+=ReturnItem)*;
	public ReturnItemsElements getReturnItemsAccess() {
		return pReturnItems;
	}
	
	public ParserRule getReturnItemsRule() {
		return getReturnItemsAccess().getRule();
	}
	
	//ReturnItem:
	//	expression=Expression ('AS' alias=VariableDeclaration)?;
	public ReturnItemElements getReturnItemAccess() {
		return pReturnItem;
	}
	
	public ParserRule getReturnItemRule() {
		return getReturnItemAccess().getRule();
	}
	
	//Order: /*
	// * order : ORDER sp BY sp sortItem ( ',' ws sortItem )* ;
	// */ 'ORDER' 'BY' orderBy+=SortItem (',' orderBy+=SortItem)*;
	public OrderElements getOrderAccess() {
		return pOrder;
	}
	
	public ParserRule getOrderRule() {
		return getOrderAccess().getRule();
	}
	
	//Skip: /*
	// * skip: L_SKIP sp expression;
	// */ 'SKIP' skip=Expression;
	public SkipElements getSkipAccess() {
		return pSkip;
	}
	
	public ParserRule getSkipRule() {
		return getSkipAccess().getRule();
	}
	
	//Limit: /*
	// * limit: LIMIT sp expression;
	// */ 'LIMIT' limit=Expression;
	public LimitElements getLimitAccess() {
		return pLimit;
	}
	
	public ParserRule getLimitRule() {
		return getLimitAccess().getRule();
	}
	
	//SortItem:
	//	expression=Expression sort=('DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC')?;
	public SortItemElements getSortItemAccess() {
		return pSortItem;
	}
	
	public ParserRule getSortItemRule() {
		return getSortItemAccess().getRule();
	}
	
	//Hint hidden():
	//	{IndexHint} 'USING' WS 'INDEX' WS variable=VariableDeclaration nodeLabel=NodeLabel WS '('
	//	propertyKeyName=PropertyKeyName ')' | {JoinHint} ('USING' WS 'JOIN' WS 'ON' variables+=VariableDeclaration (','
	//	variables+=VariableDeclaration)*) | {ScanHint} ('USING' WS 'SCAN'
	//	WS variable=VariableDeclaration nodeLabel=NodeLabel);
	public HintElements getHintAccess() {
		return pHint;
	}
	
	public ParserRule getHintRule() {
		return getHintAccess().getRule();
	}
	
	//Start: /*
	// * start : START sp startPoint ( ws ',' ws startPoint )* where? ;
	// */ 'START' startPoint+=StartPoint (',' startPoint+=StartPoint)* where=Where?;
	public StartElements getStartAccess() {
		return pStart;
	}
	
	public ParserRule getStartRule() {
		return getStartAccess().getRule();
	}
	
	//StartPoint:
	//	variable=VariableDeclaration '=' lookup=Lookup;
	public StartPointElements getStartPointAccess() {
		return pStartPoint;
	}
	
	public ParserRule getStartPointRule() {
		return getStartPointAccess().getRule();
	}
	
	//Lookup:
	//	NodeLookup | RelationshipLookup;
	public LookupElements getLookupAccess() {
		return pLookup;
	}
	
	public ParserRule getLookupRule() {
		return getLookupAccess().getRule();
	}
	
	//NodeLookup: /*
	// * nodeLookup : NODE ( identifiedIndexLookup | indexQuery | idLookup ) ;
	// */ 'NODE' (IdentifiedIndexLookup | IndexQuery | IdLookup);
	public NodeLookupElements getNodeLookupAccess() {
		return pNodeLookup;
	}
	
	public ParserRule getNodeLookupRule() {
		return getNodeLookupAccess().getRule();
	}
	
	//RelationshipLookup:
	//	('RELATIONSHIP' | 'REL') (IdentifiedIndexLookup | IndexQuery | IdLookup);
	public RelationshipLookupElements getRelationshipLookupAccess() {
		return pRelationshipLookup;
	}
	
	public ParserRule getRelationshipLookupRule() {
		return getRelationshipLookupAccess().getRule();
	}
	
	//IdentifiedIndexLookup: /*
	// * identifiedIndexLookup : ':' symbolicName '(' symbolicName '=' ( StringLiteral | legacyParameter ) ')' ;
	// */ ':' indexName=SYMBOLIC_NAME_X '(' key=SYMBOLIC_NAME_X '=' (value=STRING_LITERAL | legacyParameter=LegacyParameter)
	//	')';
	public IdentifiedIndexLookupElements getIdentifiedIndexLookupAccess() {
		return pIdentifiedIndexLookup;
	}
	
	public ParserRule getIdentifiedIndexLookupRule() {
		return getIdentifiedIndexLookupAccess().getRule();
	}
	
	//IndexQuery: /*
	// * indexQuery : ':' symbolicName '(' ( StringLiteral | legacyParameter ) ')' ;
	// */ ':' indexName=SYMBOLIC_NAME_X '(' (query=STRING_LITERAL | parameter=Parameter) ')';
	public IndexQueryElements getIndexQueryAccess() {
		return pIndexQuery;
	}
	
	public ParserRule getIndexQueryRule() {
		return getIndexQueryAccess().getRule();
	}
	
	//IdLookup: /*
	// * idLookup : '(' ( literalIds | legacyParameter | '*' ) ')' ;
	// */ '(' (ids=LiteralIds | legacyParameter=Parameter | wildcard='*') ')';
	public IdLookupElements getIdLookupAccess() {
		return pIdLookup;
	}
	
	public ParserRule getIdLookupRule() {
		return getIdLookupAccess().getRule();
	}
	
	//LiteralIds:
	//	ids+=DecimalInteger (',' ids+=DecimalInteger)*;
	public LiteralIdsElements getLiteralIdsAccess() {
		return pLiteralIds;
	}
	
	public ParserRule getLiteralIdsRule() {
		return getLiteralIdsAccess().getRule();
	}
	
	//Where: /*
	// * where : WHERE sp expression;
	// */ 'WHERE' expression=Expression;
	public WhereElements getWhereAccess() {
		return pWhere;
	}
	
	public ParserRule getWhereRule() {
		return getWhereAccess().getRule();
	}
	
	//Pattern:
	//	patterns+=PatternPart (',' patterns+=PatternPart)*;
	public PatternElements getPatternAccess() {
		return pPattern;
	}
	
	public ParserRule getPatternRule() {
		return getPatternAccess().getRule();
	}
	
	//PatternPart:
	//	var=VariableDeclaration '=' part=AnonymousPatternPart | AnonymousPatternPart;
	public PatternPartElements getPatternPartAccess() {
		return pPatternPart;
	}
	
	public ParserRule getPatternPartRule() {
		return getPatternPartAccess().getRule();
	}
	
	//AnonymousPatternPart:
	//	ShortestPathPattern | PatternElement;
	public AnonymousPatternPartElements getAnonymousPatternPartAccess() {
		return pAnonymousPatternPart;
	}
	
	public ParserRule getAnonymousPatternPartRule() {
		return getAnonymousPatternPartAccess().getRule();
	}
	
	//ShortestPathPattern:
	//	{ShortestPath} 'SHORTESTPATH' '(' patternElement=PatternElement ')' | {AllShortestPaths} 'ALLSHORTESTPATHS' '('
	//	patternElement=PatternElement ')';
	public ShortestPathPatternElements getShortestPathPatternAccess() {
		return pShortestPathPattern;
	}
	
	public ParserRule getShortestPathPatternRule() {
		return getShortestPathPatternAccess().getRule();
	}
	
	//PatternElement:
	//	nodepattern=NodePattern chain+=PatternElementChain* | '(' PatternElement ')';
	public PatternElementElements getPatternElementAccess() {
		return pPatternElement;
	}
	
	public ParserRule getPatternElementRule() {
		return getPatternElementAccess().getRule();
	}
	
	//NodePattern:
	//	{NodePattern} '(' variable=VariableDeclaration? nodeLabels=NodeLabels? properties=Properties? ')';
	public NodePatternElements getNodePatternAccess() {
		return pNodePattern;
	}
	
	public ParserRule getNodePatternRule() {
		return getNodePatternAccess().getRule();
	}
	
	//PatternElementChain:
	//	relationshipPattern=RelationshipPattern nodePattern=NodePattern;
	public PatternElementChainElements getPatternElementChainAccess() {
		return pPatternElementChain;
	}
	
	public ParserRule getPatternElementChainRule() {
		return getPatternElementChainAccess().getRule();
	}
	
	//RelationshipPattern:
	//	{RelationshipPattern} (incoming?=LeftArrowHead? Dash detail=RelationshipDetail? Dash outgoing?=RightArrowHead?);
	public RelationshipPatternElements getRelationshipPatternAccess() {
		return pRelationshipPattern;
	}
	
	public ParserRule getRelationshipPatternRule() {
		return getRelationshipPatternAccess().getRule();
	}
	
	//RelationshipDetail:
	//	{RelationshipDetail} '[' variable=VariableDeclaration? optional?='?'? types=RelationshipTypes? range=RangeLiteral?
	//	properties=Properties? ']';
	public RelationshipDetailElements getRelationshipDetailAccess() {
		return pRelationshipDetail;
	}
	
	public ParserRule getRelationshipDetailRule() {
		return getRelationshipDetailAccess().getRule();
	}
	
	//Properties:
	//	MapLiteral | Parameter | LegacyParameter;
	public PropertiesElements getPropertiesAccess() {
		return pProperties;
	}
	
	public ParserRule getPropertiesRule() {
		return getPropertiesAccess().getRule();
	}
	
	//RelType: /*
	// * relType : ':' relTypeName ;
	// */ ':' RelTypeName;
	public RelTypeElements getRelTypeAccess() {
		return pRelType;
	}
	
	public ParserRule getRelTypeRule() {
		return getRelTypeAccess().getRule();
	}
	
	//RelationshipTypes: /*
	// * relationshipTypes : ':' relTypeName ( ws '|' ':'? ws relTypeName )* ;
	// */ ':' relTypeName+=RelTypeName ('|' ':'? relTypeName+=RelTypeName)*;
	public RelationshipTypesElements getRelationshipTypesAccess() {
		return pRelationshipTypes;
	}
	
	public ParserRule getRelationshipTypesRule() {
		return getRelationshipTypesAccess().getRule();
	}
	
	//NodeLabels:
	//	nodeLabels+=NodeLabel nodeLabels+=NodeLabel*;
	public NodeLabelsElements getNodeLabelsAccess() {
		return pNodeLabels;
	}
	
	public ParserRule getNodeLabelsRule() {
		return getNodeLabelsAccess().getRule();
	}
	
	//NodeLabel: /*
	// * nodeLabel : ':' labelName ;
	// */ ':' labelName=LabelName;
	public NodeLabelElements getNodeLabelAccess() {
		return pNodeLabel;
	}
	
	public ParserRule getNodeLabelRule() {
		return getNodeLabelAccess().getRule();
	}
	
	//RangeLiteral:
	//	{RangeLiteral} '*' (lower=Number? ('..' upper=Number?)?)?;
	public RangeLiteralElements getRangeLiteralAccess() {
		return pRangeLiteral;
	}
	
	public ParserRule getRangeLiteralRule() {
		return getRangeLiteralAccess().getRule();
	}
	
	//LabelName:
	//	SYMBOLIC_NAME_X;
	public LabelNameElements getLabelNameAccess() {
		return pLabelName;
	}
	
	public ParserRule getLabelNameRule() {
		return getLabelNameAccess().getRule();
	}
	
	//RelTypeName:
	//	SYMBOLIC_NAME_X;
	public RelTypeNameElements getRelTypeNameAccess() {
		return pRelTypeName;
	}
	
	public ParserRule getRelTypeNameRule() {
		return getRelTypeNameAccess().getRule();
	}
	
	//Expression:
	//	ExpressionOr;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//ExpressionOr Expression:
	//	ExpressionXor ({ExpressionOr.left=current} operator='OR' right=ExpressionXor)*;
	public ExpressionOrElements getExpressionOrAccess() {
		return pExpressionOr;
	}
	
	public ParserRule getExpressionOrRule() {
		return getExpressionOrAccess().getRule();
	}
	
	//ExpressionXor Expression:
	//	ExpressionAnd ({ExpressionXor.left=current} operator='XOR' right=ExpressionAnd)*;
	public ExpressionXorElements getExpressionXorAccess() {
		return pExpressionXor;
	}
	
	public ParserRule getExpressionXorRule() {
		return getExpressionXorAccess().getRule();
	}
	
	//ExpressionAnd Expression:
	//	ExpressionNot ({ExpressionAnd.left=current} operator='AND' right=ExpressionNot)*;
	public ExpressionAndElements getExpressionAndAccess() {
		return pExpressionAnd;
	}
	
	public ParserRule getExpressionAndRule() {
		return getExpressionAndAccess().getRule();
	}
	
	//ExpressionNot Expression:
	//	{ExpressionNot} operator='NOT' left=ExpressionNot | ExpressionComparison;
	public ExpressionNotElements getExpressionNotAccess() {
		return pExpressionNot;
	}
	
	public ParserRule getExpressionNotRule() {
		return getExpressionNotAccess().getRule();
	}
	
	//ExpressionComparison Expression:
	//	ExpressionPlusMinus ({ExpressionComparison.left=current} operator=('=' | '<>' | '<' | '>' | '<=' | '>=')
	//	right=ExpressionPlusMinus)*;
	public ExpressionComparisonElements getExpressionComparisonAccess() {
		return pExpressionComparison;
	}
	
	public ParserRule getExpressionComparisonRule() {
		return getExpressionComparisonAccess().getRule();
	}
	
	//ExpressionPlusMinus Expression:
	//	ExpressionMulDiv ({ExpressionPlusMinus.left=current} operator=('+' | '-') right=ExpressionMulDiv)*;
	public ExpressionPlusMinusElements getExpressionPlusMinusAccess() {
		return pExpressionPlusMinus;
	}
	
	public ParserRule getExpressionPlusMinusRule() {
		return getExpressionPlusMinusAccess().getRule();
	}
	
	//ExpressionMulDiv Expression:
	//	ExpressionPower ({ExpressionMulDiv.left=current} operator=('*' | '/' | '%') right=ExpressionPower)*;
	public ExpressionMulDivElements getExpressionMulDivAccess() {
		return pExpressionMulDiv;
	}
	
	public ParserRule getExpressionMulDivRule() {
		return getExpressionMulDivAccess().getRule();
	}
	
	//ExpressionPower Expression:
	//	ExpressionUnaryPlusMinus ({ExpressionPower.left=current} operator='^' right=ExpressionUnaryPlusMinus)*;
	public ExpressionPowerElements getExpressionPowerAccess() {
		return pExpressionPower;
	}
	
	public ParserRule getExpressionPowerRule() {
		return getExpressionPowerAccess().getRule();
	}
	
	//ExpressionUnaryPlusMinus Expression:
	//	Expression3 | {ExpressionUnaryPlusMinus} operator=('+' | '-') left=ExpressionUnaryPlusMinus;
	public ExpressionUnaryPlusMinusElements getExpressionUnaryPlusMinusAccess() {
		return pExpressionUnaryPlusMinus;
	}
	
	public ParserRule getExpressionUnaryPlusMinusRule() {
		return getExpressionUnaryPlusMinusAccess().getRule();
	}
	
	//Expression3 Expression:
	//	ExpressionNodeLabelsAndPropertyLookup ({IndexExpression.left=current} '[' expression=Expression ('..'
	//	upper=Expression)? ']' | {RegExpMatchingExpression.left=current} '=~'
	//	right=ExpressionNodeLabelsAndPropertyLookup | {InCollectionExpression.left=current} 'IN'
	//	right=ExpressionNodeLabelsAndPropertyLookup | {StartsWithExpression.left=current} 'STARTS' 'WITH'
	//	right=ExpressionNodeLabelsAndPropertyLookup | {EndsWithExpression.left=current} 'ENDS' 'WITH'
	//	right=ExpressionNodeLabelsAndPropertyLookup | {ContainsExpression.left=current} 'CONTAINS'
	//	right=ExpressionNodeLabelsAndPropertyLookup | {IsNullExpression.left=current} 'IS' 'NULL' |
	//	{IsNotNullExpression.left=current} 'IS' 'NOT' 'NULL')*;
	public Expression3Elements getExpression3Access() {
		return pExpression3;
	}
	
	public ParserRule getExpression3Rule() {
		return getExpression3Access().getRule();
	}
	
	//ExpressionNodeLabelsAndPropertyLookup Expression:
	//	Atom ({ExpressionPropertyLookup.left=current} propertyLookups+=PropertyLookup+)? ({ExpressionNodeLabels.left=current}
	//	nodeLabels+=NodeLabel+)?;
	public ExpressionNodeLabelsAndPropertyLookupElements getExpressionNodeLabelsAndPropertyLookupAccess() {
		return pExpressionNodeLabelsAndPropertyLookup;
	}
	
	public ParserRule getExpressionNodeLabelsAndPropertyLookupRule() {
		return getExpressionNodeLabelsAndPropertyLookupAccess().getRule();
	}
	
	///* Expression1 */ Atom Expression:
	//	{NumberConstant} value=Number | {StringConstant} value=STRING_LITERAL | Parameter | LegacyParameter | {BoolConstant}
	//	value=('TRUE' | 'FALSE') | {NullConstant} 'NULL' | CaseExpression | {Count} 'COUNT' '(' '*' ')' | MapLiteral |
	//	ListComprehension | PatternComprehension | {ExpressionList} ('[' (expressions+=Expression (','
	//	expressions+=Expression)*)? ']') | {Extract} 'EXTRACT' '(' filterExpression=FilterExpression ('|'
	//	expression=Expression)? ')' | Reduce | {Filter} 'FILTER' '(' filterExpression=FilterExpression ')' | {All} 'ALL' '('
	//	filterExpression=FilterExpression ')' | {Any} 'ANY' '(' filterExpression=FilterExpression ')' | {None} 'NONE' '('
	//	filterExpression=FilterExpression ')' | {Single} 'SINGLE' '(' filterExpression=FilterExpression ')' |
	//	ShortestPathPattern | RelationshipsPattern | ParenthesizedExpression | FunctionInvocation | {VariableRef}
	//	variableRef=[VariableDeclaration|SYMBOLIC_NAME_X];
	public AtomElements getAtomAccess() {
		return pAtom;
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}
	
	//Reduce: /*
	// * reduce : REDUCE ws '(' variable '=' expression ',' idInColl '|' expression ')' ;
	// */ 'REDUCE' '(' accumulator=VariableDeclaration '=' accumulatorExpression=Expression ',' idInColl=IdInColl '|'
	//	expression=Expression ')';
	public ReduceElements getReduceAccess() {
		return pReduce;
	}
	
	public ParserRule getReduceRule() {
		return getReduceAccess().getRule();
	}
	
	//ParenthesizedExpression: /*
	// * parenthesizedExpression : '(' ws expression ws ')' ;
	// */ '(' expression=Expression ')';
	public ParenthesizedExpressionElements getParenthesizedExpressionAccess() {
		return pParenthesizedExpression;
	}
	
	public ParserRule getParenthesizedExpressionRule() {
		return getParenthesizedExpressionAccess().getRule();
	}
	
	//RelationshipsPattern:
	//	nodePattern=NodePattern chain+=PatternElementChain+;
	public RelationshipsPatternElements getRelationshipsPatternAccess() {
		return pRelationshipsPattern;
	}
	
	public ParserRule getRelationshipsPatternRule() {
		return getRelationshipsPatternAccess().getRule();
	}
	
	//FilterExpression:
	//	idInColl=IdInColl where=Where?;
	public FilterExpressionElements getFilterExpressionAccess() {
		return pFilterExpression;
	}
	
	public ParserRule getFilterExpressionRule() {
		return getFilterExpressionAccess().getRule();
	}
	
	//IdInColl:
	//	variable=VariableDeclaration 'IN' expression=Expression;
	public IdInCollElements getIdInCollAccess() {
		return pIdInColl;
	}
	
	public ParserRule getIdInCollRule() {
		return getIdInCollAccess().getRule();
	}
	
	//FunctionInvocation:
	//	functionName=FunctionName '(' distinct?='DISTINCT'? (parameter+=Expression (',' parameter+=Expression)*)? ')';
	public FunctionInvocationElements getFunctionInvocationAccess() {
		return pFunctionInvocation;
	}
	
	public ParserRule getFunctionInvocationRule() {
		return getFunctionInvocationAccess().getRule();
	}
	
	//FunctionName:
	//	SYMBOLIC_NAME_X;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//ExplicitProcedureInvocation:
	//	procedureName=ProcedureName '(' (parameter+=Expression (',' parameter+=Expression)*)? ')';
	public ExplicitProcedureInvocationElements getExplicitProcedureInvocationAccess() {
		return pExplicitProcedureInvocation;
	}
	
	public ParserRule getExplicitProcedureInvocationRule() {
		return getExplicitProcedureInvocationAccess().getRule();
	}
	
	//ProcedureResultField:
	//	SYMBOLIC_NAME_X;
	public ProcedureResultFieldElements getProcedureResultFieldAccess() {
		return pProcedureResultField;
	}
	
	public ParserRule getProcedureResultFieldRule() {
		return getProcedureResultFieldAccess().getRule();
	}
	
	//ImplicitProcedureInvocation:
	//	ProcedureName;
	public ImplicitProcedureInvocationElements getImplicitProcedureInvocationAccess() {
		return pImplicitProcedureInvocation;
	}
	
	public ParserRule getImplicitProcedureInvocationRule() {
		return getImplicitProcedureInvocationAccess().getRule();
	}
	
	//ProcedureName:
	//	namespace=Namespace name=SYMBOLIC_NAME_X;
	public ProcedureNameElements getProcedureNameAccess() {
		return pProcedureName;
	}
	
	public ParserRule getProcedureNameRule() {
		return getProcedureNameAccess().getRule();
	}
	
	//Namespace:
	//	(SYMBOLIC_NAME_X '.')*;
	public NamespaceElements getNamespaceAccess() {
		return pNamespace;
	}
	
	public ParserRule getNamespaceRule() {
		return getNamespaceAccess().getRule();
	}
	
	//ListComprehension: /*
	// * listComprehension : '[' filterExpression ( ws '|' expression )? ']' ;
	// */ '[' filterExpression=FilterExpression ('|' expression=Expression)? ']';
	public ListComprehensionElements getListComprehensionAccess() {
		return pListComprehension;
	}
	
	public ParserRule getListComprehensionRule() {
		return getListComprehensionAccess().getRule();
	}
	
	//PatternComprehension: /*
	// * patternComprehension : '['  ( variable '=' )? relationshipsPattern ( WHERE expression )? '|' expression ']' ;
	// */ '[' (pathVariable=VariableDeclaration '=')? pattern=RelationshipsPattern where=Where? '|' expression=Expression ']';
	public PatternComprehensionElements getPatternComprehensionAccess() {
		return pPatternComprehension;
	}
	
	public ParserRule getPatternComprehensionRule() {
		return getPatternComprehensionAccess().getRule();
	}
	
	//PropertyLookup: /*
	// * propertyLookup : ws '.' ws ( ( propertyKeyName ( '?' | '!' ) ) | propertyKeyName ) ;
	// */ '.' (propertyKeyName=PropertyKeyName propertyOperator=('?' | '!') | propertyKeyName=PropertyKeyName);
	public PropertyLookupElements getPropertyLookupAccess() {
		return pPropertyLookup;
	}
	
	public ParserRule getPropertyLookupRule() {
		return getPropertyLookupAccess().getRule();
	}
	
	//CaseExpression:
	//	('CASE' caseAlternatives+=CaseAlternatives+ | 'CASE' caseExpression=Expression
	//	caseAlternatives+=CaseAlternatives+) ('ELSE' elseExpression=Expression)? 'END';
	public CaseExpressionElements getCaseExpressionAccess() {
		return pCaseExpression;
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}
	
	//CaseAlternatives: /*
	// * caseAlternatives : WHEN ws expression ws THEN ws expression ;
	// */ 'WHEN' when=Expression 'THEN' then=Expression;
	public CaseAlternativesElements getCaseAlternativesAccess() {
		return pCaseAlternatives;
	}
	
	public ParserRule getCaseAlternativesRule() {
		return getCaseAlternativesAccess().getRule();
	}
	
	//VariableDeclaration:
	//	{VariableDeclaration} name=SYMBOLIC_NAME_X;
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return pVariableDeclaration;
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}
	
	//MapLiteral:
	//	{MapLiteral} '{' (entries+=MapLiteralEntry (',' entries+=MapLiteralEntry)*)? '}';
	public MapLiteralElements getMapLiteralAccess() {
		return pMapLiteral;
	}
	
	public ParserRule getMapLiteralRule() {
		return getMapLiteralAccess().getRule();
	}
	
	//MapLiteralEntry:
	//	key=PropertyKeyName ':' value=Expression;
	public MapLiteralEntryElements getMapLiteralEntryAccess() {
		return pMapLiteralEntry;
	}
	
	public ParserRule getMapLiteralEntryRule() {
		return getMapLiteralEntryAccess().getRule();
	}
	
	//LegacyParameter: /*
	// * legacyParameter : '{' ws ( symbolicName | DecimalInteger ) ws '}' ;
	// * 
	// * Comment: Format of DecimalInteger is checked via 
	// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkLegacyParameterFormat(LegacyParameter)
	// */ '{' parameter=(SYMBOLIC_NAME_X | Number) '}';
	public LegacyParameterElements getLegacyParameterAccess() {
		return pLegacyParameter;
	}
	
	public ParserRule getLegacyParameterRule() {
		return getLegacyParameterAccess().getRule();
	}
	
	//Parameter: /*
	// * parameter : '$' ( symbolicName | DecimalInteger ) ;
	// * 
	// * Comment: Format of DecimalInteger is checked via 
	// * org.slizaa.neo4j.opencypher.validation.OpenCypherValidator.checkParameterFormat(Parameter)
	// */ '$' parameter=(SYMBOLIC_NAME_X | Number);
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//PropertyExpression:
	//	left=Atom propertyLookups+=PropertyLookup+;
	public PropertyExpressionElements getPropertyExpressionAccess() {
		return pPropertyExpression;
	}
	
	public ParserRule getPropertyExpressionRule() {
		return getPropertyExpressionAccess().getRule();
	}
	
	//PropertyKeyName:
	//	SYMBOLIC_NAME_X;
	public PropertyKeyNameElements getPropertyKeyNameAccess() {
		return pPropertyKeyName;
	}
	
	public ParserRule getPropertyKeyNameRule() {
		return getPropertyKeyNameAccess().getRule();
	}
	
	//LeftArrowHead: /*
	// * Comment: reduced character set
	// */ '<';
	public LeftArrowHeadElements getLeftArrowHeadAccess() {
		return pLeftArrowHead;
	}
	
	public ParserRule getLeftArrowHeadRule() {
		return getLeftArrowHeadAccess().getRule();
	}
	
	//RightArrowHead: /*
	// * Comment: reduced character set
	// */ '>';
	public RightArrowHeadElements getRightArrowHeadAccess() {
		return pRightArrowHead;
	}
	
	public ParserRule getRightArrowHeadRule() {
		return getRightArrowHeadAccess().getRule();
	}
	
	//Dash: /*
	// * Comment: reduced character set
	// */ '-';
	public DashElements getDashAccess() {
		return pDash;
	}
	
	public ParserRule getDashRule() {
		return getDashAccess().getRule();
	}
	
	//DecimalInteger:
	//	{DecimalInteger} value=Number;
	public DecimalIntegerElements getDecimalIntegerAccess() {
		return pDecimalInteger;
	}
	
	public ParserRule getDecimalIntegerRule() {
		return getDecimalIntegerAccess().getRule();
	}
	
	//Number hidden():
	//	HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//SYMBOLIC_NAME_X:
	//	ID | 'CYPHER' | 'EXPLAIN' | 'PROFILE' | 'USING' | 'PERIODIC' | 'COMMIT' | 'UNION' | 'ALL' | 'CREATE' |
	//	'INDEX' | 'ON' | 'DROP' | 'CONSTRAINT' | 'ASSERT' | 'IS' | 'UNIQUE' | 'EXISTS' | 'LOAD' | 'CSV' | 'WITH' | 'HEADERS'
	//	| 'FROM' | 'AS' | 'FIELDTERMINATOR' | 'OPTIONAL' | 'MATCH' | 'UNWIND' | 'MERGE' | 'SET' | 'DELETE' | 'DETACH' |
	//	'REMOVE' | 'FOREACH' | 'IN' | 'DISTINCT' | 'RETURN' | 'ORDER' | 'BY' | 'SKIP' | 'LIMIT' | 'DESCENDING' | 'DESC' |
	//	'ASCENDING' | 'ASC' | 'JOIN' | 'SCAN' | 'START' | 'NODE' | 'RELATIONSHIP' | 'REL' | 'WHERE' | 'SHORTESTPATH' |
	//	'ALLSHORTESTPATHS' | 'OR' | 'XOR' | 'AND' | 'NOT' | 'STARTS' | 'ENDS' | 'CONTAINS' | 'NULL' | 'TRUE' | 'FALSE' |
	//	'COUNT' | 'FILTER' | 'EXTRACT' | 'ANY' | 'NONE' | 'SINGLE' | 'REDUCE' | 'CASE' | 'ELSE' | 'END' | 'WHEN' | 'THEN';
	public SYMBOLIC_NAME_XElements getSYMBOLIC_NAME_XAccess() {
		return pSYMBOLIC_NAME_X;
	}
	
	public ParserRule getSYMBOLIC_NAME_XRule() {
		return getSYMBOLIC_NAME_XAccess().getRule();
	}
	
	//terminal ID:
	//	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* | '`'->'`';
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal STRING_LITERAL:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRING_LITERALRule() {
		return tSTRING_LITERAL;
	}
	
	//terminal HEX:
	//	('0x' | '0X') ('0'..'9' | 'A'..'F')+;
	public TerminalRule getHEXRule() {
		return tHEX;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9' '0'..'9'*;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal DECIMAL:
	//	INT ('e' ('+' | '-')? INT)?;
	public TerminalRule getDECIMALRule() {
		return tDECIMAL;
	}
}
