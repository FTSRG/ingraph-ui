/*
 * generated by Xtext 2.13.0
 */
package org.slizaa.neo4j.opencypher.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.slizaa.neo4j.opencypher.openCypher.All;
import org.slizaa.neo4j.opencypher.openCypher.AllOptions;
import org.slizaa.neo4j.opencypher.openCypher.AllShortestPaths;
import org.slizaa.neo4j.opencypher.openCypher.Any;
import org.slizaa.neo4j.opencypher.openCypher.BoolConstant;
import org.slizaa.neo4j.opencypher.openCypher.BulkImportQuery;
import org.slizaa.neo4j.opencypher.openCypher.CaseAlternatives;
import org.slizaa.neo4j.opencypher.openCypher.CaseExpression;
import org.slizaa.neo4j.opencypher.openCypher.CombinedQuery;
import org.slizaa.neo4j.opencypher.openCypher.ConfigurationOption;
import org.slizaa.neo4j.opencypher.openCypher.ContainsExpression;
import org.slizaa.neo4j.opencypher.openCypher.Count;
import org.slizaa.neo4j.opencypher.openCypher.Create;
import org.slizaa.neo4j.opencypher.openCypher.CreateIndex;
import org.slizaa.neo4j.opencypher.openCypher.Cypher;
import org.slizaa.neo4j.opencypher.openCypher.CypherOption;
import org.slizaa.neo4j.opencypher.openCypher.DecimalInteger;
import org.slizaa.neo4j.opencypher.openCypher.Delete;
import org.slizaa.neo4j.opencypher.openCypher.DropIndex;
import org.slizaa.neo4j.opencypher.openCypher.DropNodePropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.DropRelationshipPropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.DropUniqueConstraint;
import org.slizaa.neo4j.opencypher.openCypher.EndsWithExpression;
import org.slizaa.neo4j.opencypher.openCypher.ExplicitProcedureInvocation;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionAnd;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionComparison;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionList;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionMulDiv;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionNodeLabels;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionNot;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionOr;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionPlusMinus;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionPower;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionPropertyLookup;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionUnaryPlusMinus;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionXor;
import org.slizaa.neo4j.opencypher.openCypher.Extract;
import org.slizaa.neo4j.opencypher.openCypher.Filter;
import org.slizaa.neo4j.opencypher.openCypher.FilterExpression;
import org.slizaa.neo4j.opencypher.openCypher.Foreach;
import org.slizaa.neo4j.opencypher.openCypher.FunctionInvocation;
import org.slizaa.neo4j.opencypher.openCypher.IdInColl;
import org.slizaa.neo4j.opencypher.openCypher.IdLookup;
import org.slizaa.neo4j.opencypher.openCypher.IdentifiedIndexLookup;
import org.slizaa.neo4j.opencypher.openCypher.InCollectionExpression;
import org.slizaa.neo4j.opencypher.openCypher.InQueryCall;
import org.slizaa.neo4j.opencypher.openCypher.Index;
import org.slizaa.neo4j.opencypher.openCypher.IndexExpression;
import org.slizaa.neo4j.opencypher.openCypher.IndexHint;
import org.slizaa.neo4j.opencypher.openCypher.IndexQuery;
import org.slizaa.neo4j.opencypher.openCypher.IsNotNullExpression;
import org.slizaa.neo4j.opencypher.openCypher.IsNullExpression;
import org.slizaa.neo4j.opencypher.openCypher.JoinHint;
import org.slizaa.neo4j.opencypher.openCypher.LegacyParameter;
import org.slizaa.neo4j.opencypher.openCypher.Limit;
import org.slizaa.neo4j.opencypher.openCypher.ListComprehension;
import org.slizaa.neo4j.opencypher.openCypher.LiteralIds;
import org.slizaa.neo4j.opencypher.openCypher.LoadCSV;
import org.slizaa.neo4j.opencypher.openCypher.LoadCSVQuery;
import org.slizaa.neo4j.opencypher.openCypher.MapLiteral;
import org.slizaa.neo4j.opencypher.openCypher.MapLiteralEntry;
import org.slizaa.neo4j.opencypher.openCypher.Match;
import org.slizaa.neo4j.opencypher.openCypher.Merge;
import org.slizaa.neo4j.opencypher.openCypher.MergeAction;
import org.slizaa.neo4j.opencypher.openCypher.NodeLabel;
import org.slizaa.neo4j.opencypher.openCypher.NodeLabels;
import org.slizaa.neo4j.opencypher.openCypher.NodePattern;
import org.slizaa.neo4j.opencypher.openCypher.NodePropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.None;
import org.slizaa.neo4j.opencypher.openCypher.NullConstant;
import org.slizaa.neo4j.opencypher.openCypher.NumberConstant;
import org.slizaa.neo4j.opencypher.openCypher.OpenCypherPackage;
import org.slizaa.neo4j.opencypher.openCypher.Order;
import org.slizaa.neo4j.opencypher.openCypher.ParenthesizedExpression;
import org.slizaa.neo4j.opencypher.openCypher.Pattern;
import org.slizaa.neo4j.opencypher.openCypher.PatternComprehension;
import org.slizaa.neo4j.opencypher.openCypher.PatternElement;
import org.slizaa.neo4j.opencypher.openCypher.PatternElementChain;
import org.slizaa.neo4j.opencypher.openCypher.PatternPart;
import org.slizaa.neo4j.opencypher.openCypher.PeriodicCommitHint;
import org.slizaa.neo4j.opencypher.openCypher.ProcedureName;
import org.slizaa.neo4j.opencypher.openCypher.PropertyExpression;
import org.slizaa.neo4j.opencypher.openCypher.PropertyLookup;
import org.slizaa.neo4j.opencypher.openCypher.RangeLiteral;
import org.slizaa.neo4j.opencypher.openCypher.Reduce;
import org.slizaa.neo4j.opencypher.openCypher.RegExpMatchingExpression;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipDetail;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipPattern;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipPatternSyntax;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipPropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipTypes;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipsPattern;
import org.slizaa.neo4j.opencypher.openCypher.Remove;
import org.slizaa.neo4j.opencypher.openCypher.RemoveItemLabel;
import org.slizaa.neo4j.opencypher.openCypher.RemoveItemProperty;
import org.slizaa.neo4j.opencypher.openCypher.Return;
import org.slizaa.neo4j.opencypher.openCypher.ReturnBody;
import org.slizaa.neo4j.opencypher.openCypher.ReturnItem;
import org.slizaa.neo4j.opencypher.openCypher.ReturnItems;
import org.slizaa.neo4j.opencypher.openCypher.ScanHint;
import org.slizaa.neo4j.opencypher.openCypher.SetItem;
import org.slizaa.neo4j.opencypher.openCypher.ShortestPath;
import org.slizaa.neo4j.opencypher.openCypher.Single;
import org.slizaa.neo4j.opencypher.openCypher.SingleQuery;
import org.slizaa.neo4j.opencypher.openCypher.Skip;
import org.slizaa.neo4j.opencypher.openCypher.SortItem;
import org.slizaa.neo4j.opencypher.openCypher.StandaloneCall;
import org.slizaa.neo4j.opencypher.openCypher.Start;
import org.slizaa.neo4j.opencypher.openCypher.StartPoint;
import org.slizaa.neo4j.opencypher.openCypher.StartsWithExpression;
import org.slizaa.neo4j.opencypher.openCypher.StringConstant;
import org.slizaa.neo4j.opencypher.openCypher.Union;
import org.slizaa.neo4j.opencypher.openCypher.UniqueConstraint;
import org.slizaa.neo4j.opencypher.openCypher.Unwind;
import org.slizaa.neo4j.opencypher.openCypher.VariableDeclaration;
import org.slizaa.neo4j.opencypher.openCypher.VariableRef;
import org.slizaa.neo4j.opencypher.openCypher.VersionNumber;
import org.slizaa.neo4j.opencypher.openCypher.Where;
import org.slizaa.neo4j.opencypher.openCypher.With;
import org.slizaa.neo4j.opencypher.openCypher.YieldItem;
import org.slizaa.neo4j.opencypher.openCypher.YieldItems;
import org.slizaa.neo4j.opencypher.services.OpenCypherGrammarAccess;

@SuppressWarnings("all")
public class OpenCypherSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OpenCypherGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OpenCypherPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OpenCypherPackage.ALL:
				sequence_Atom(context, (All) semanticObject); 
				return; 
			case OpenCypherPackage.ALL_OPTIONS:
				sequence_QueryOptions(context, (AllOptions) semanticObject); 
				return; 
			case OpenCypherPackage.ALL_SHORTEST_PATHS:
				sequence_ShortestPathPattern(context, (AllShortestPaths) semanticObject); 
				return; 
			case OpenCypherPackage.ANY:
				sequence_Atom(context, (Any) semanticObject); 
				return; 
			case OpenCypherPackage.BOOL_CONSTANT:
				sequence_Atom(context, (BoolConstant) semanticObject); 
				return; 
			case OpenCypherPackage.BULK_IMPORT_QUERY:
				sequence_BulkImportQuery(context, (BulkImportQuery) semanticObject); 
				return; 
			case OpenCypherPackage.CASE_ALTERNATIVES:
				sequence_CaseAlternatives(context, (CaseAlternatives) semanticObject); 
				return; 
			case OpenCypherPackage.CASE_EXPRESSION:
				sequence_CaseExpression(context, (CaseExpression) semanticObject); 
				return; 
			case OpenCypherPackage.COMBINED_QUERY:
				sequence_RegularQuery(context, (CombinedQuery) semanticObject); 
				return; 
			case OpenCypherPackage.CONFIGURATION_OPTION:
				sequence_ConfigurationOption(context, (ConfigurationOption) semanticObject); 
				return; 
			case OpenCypherPackage.CONTAINS_EXPRESSION:
				sequence_Expression3(context, (ContainsExpression) semanticObject); 
				return; 
			case OpenCypherPackage.COUNT:
				sequence_Atom(context, (Count) semanticObject); 
				return; 
			case OpenCypherPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case OpenCypherPackage.CREATE_INDEX:
				sequence_CreateIndex(context, (CreateIndex) semanticObject); 
				return; 
			case OpenCypherPackage.CYPHER:
				sequence_Cypher(context, (Cypher) semanticObject); 
				return; 
			case OpenCypherPackage.CYPHER_OPTION:
				sequence_CypherOption(context, (CypherOption) semanticObject); 
				return; 
			case OpenCypherPackage.DECIMAL_INTEGER:
				sequence_DecimalInteger(context, (DecimalInteger) semanticObject); 
				return; 
			case OpenCypherPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_INDEX:
				sequence_DropIndex(context, (DropIndex) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_DropNodePropertyExistenceConstraint(context, (DropNodePropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_DropRelationshipPropertyExistenceConstraint(context, (DropRelationshipPropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_UNIQUE_CONSTRAINT:
				sequence_DropUniqueConstraint(context, (DropUniqueConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.ENDS_WITH_EXPRESSION:
				sequence_Expression3(context, (EndsWithExpression) semanticObject); 
				return; 
			case OpenCypherPackage.EXPLICIT_PROCEDURE_INVOCATION:
				sequence_ExplicitProcedureInvocation(context, (ExplicitProcedureInvocation) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_AND:
				sequence_ExpressionAnd(context, (ExpressionAnd) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_COMPARISON:
				sequence_ExpressionComparison(context, (ExpressionComparison) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_LIST:
				sequence_Atom(context, (ExpressionList) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_MUL_DIV:
				sequence_ExpressionMulDiv(context, (ExpressionMulDiv) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_NODE_LABELS:
				sequence_ExpressionNodeLabelsAndPropertyLookup(context, (ExpressionNodeLabels) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_NOT:
				sequence_ExpressionNot(context, (ExpressionNot) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_OR:
				sequence_ExpressionOr(context, (ExpressionOr) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_PLUS_MINUS:
				sequence_ExpressionPlusMinus(context, (ExpressionPlusMinus) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_POWER:
				sequence_ExpressionPower(context, (ExpressionPower) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_PROPERTY_LOOKUP:
				sequence_ExpressionNodeLabelsAndPropertyLookup(context, (ExpressionPropertyLookup) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_UNARY_PLUS_MINUS:
				sequence_ExpressionUnaryPlusMinus(context, (ExpressionUnaryPlusMinus) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_XOR:
				sequence_ExpressionXor(context, (ExpressionXor) semanticObject); 
				return; 
			case OpenCypherPackage.EXTRACT:
				sequence_Atom(context, (Extract) semanticObject); 
				return; 
			case OpenCypherPackage.FILTER:
				sequence_Atom(context, (Filter) semanticObject); 
				return; 
			case OpenCypherPackage.FILTER_EXPRESSION:
				sequence_FilterExpression(context, (FilterExpression) semanticObject); 
				return; 
			case OpenCypherPackage.FOREACH:
				sequence_Foreach(context, (Foreach) semanticObject); 
				return; 
			case OpenCypherPackage.FUNCTION_INVOCATION:
				sequence_FunctionInvocation(context, (FunctionInvocation) semanticObject); 
				return; 
			case OpenCypherPackage.ID_IN_COLL:
				sequence_IdInColl(context, (IdInColl) semanticObject); 
				return; 
			case OpenCypherPackage.ID_LOOKUP:
				sequence_IdLookup(context, (IdLookup) semanticObject); 
				return; 
			case OpenCypherPackage.IDENTIFIED_INDEX_LOOKUP:
				sequence_IdentifiedIndexLookup(context, (IdentifiedIndexLookup) semanticObject); 
				return; 
			case OpenCypherPackage.IN_COLLECTION_EXPRESSION:
				sequence_Expression3(context, (InCollectionExpression) semanticObject); 
				return; 
			case OpenCypherPackage.IN_QUERY_CALL:
				sequence_InQueryCall(context, (InQueryCall) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX:
				sequence_Index(context, (Index) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_EXPRESSION:
				sequence_Expression3(context, (IndexExpression) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_HINT:
				sequence_Hint(context, (IndexHint) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_QUERY:
				sequence_IndexQuery(context, (IndexQuery) semanticObject); 
				return; 
			case OpenCypherPackage.IS_NOT_NULL_EXPRESSION:
				sequence_Expression3(context, (IsNotNullExpression) semanticObject); 
				return; 
			case OpenCypherPackage.IS_NULL_EXPRESSION:
				sequence_Expression3(context, (IsNullExpression) semanticObject); 
				return; 
			case OpenCypherPackage.JOIN_HINT:
				sequence_Hint(context, (JoinHint) semanticObject); 
				return; 
			case OpenCypherPackage.LEGACY_PARAMETER:
				sequence_LegacyParameter(context, (LegacyParameter) semanticObject); 
				return; 
			case OpenCypherPackage.LIMIT:
				sequence_Limit(context, (Limit) semanticObject); 
				return; 
			case OpenCypherPackage.LIST_COMPREHENSION:
				sequence_ListComprehension(context, (ListComprehension) semanticObject); 
				return; 
			case OpenCypherPackage.LITERAL_IDS:
				sequence_LiteralIds(context, (LiteralIds) semanticObject); 
				return; 
			case OpenCypherPackage.LOAD_CSV:
				sequence_LoadCSV(context, (LoadCSV) semanticObject); 
				return; 
			case OpenCypherPackage.LOAD_CSV_QUERY:
				sequence_LoadCSVQuery(context, (LoadCSVQuery) semanticObject); 
				return; 
			case OpenCypherPackage.MAP_LITERAL:
				sequence_MapLiteral(context, (MapLiteral) semanticObject); 
				return; 
			case OpenCypherPackage.MAP_LITERAL_ENTRY:
				sequence_MapLiteralEntry(context, (MapLiteralEntry) semanticObject); 
				return; 
			case OpenCypherPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case OpenCypherPackage.MERGE:
				sequence_Merge(context, (Merge) semanticObject); 
				return; 
			case OpenCypherPackage.MERGE_ACTION:
				sequence_MergeAction(context, (MergeAction) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_LABEL:
				sequence_NodeLabel(context, (NodeLabel) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_LABELS:
				sequence_NodeLabels(context, (NodeLabels) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_PATTERN:
				sequence_NodePattern(context, (NodePattern) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_NodePropertyExistenceConstraint(context, (NodePropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.NONE:
				sequence_Atom(context, (None) semanticObject); 
				return; 
			case OpenCypherPackage.NULL_CONSTANT:
				sequence_Atom(context, (NullConstant) semanticObject); 
				return; 
			case OpenCypherPackage.NUMBER_CONSTANT:
				sequence_Atom(context, (NumberConstant) semanticObject); 
				return; 
			case OpenCypherPackage.ORDER:
				sequence_Order(context, (Order) semanticObject); 
				return; 
			case OpenCypherPackage.PARAMETER:
				sequence_Parameter(context, (org.slizaa.neo4j.opencypher.openCypher.Parameter) semanticObject); 
				return; 
			case OpenCypherPackage.PARENTHESIZED_EXPRESSION:
				sequence_ParenthesizedExpression(context, (ParenthesizedExpression) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_COMPREHENSION:
				sequence_PatternComprehension(context, (PatternComprehension) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_ELEMENT:
				sequence_PatternElement(context, (PatternElement) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_ELEMENT_CHAIN:
				sequence_PatternElementChain(context, (PatternElementChain) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_PART:
				sequence_PatternPart(context, (PatternPart) semanticObject); 
				return; 
			case OpenCypherPackage.PERIODIC_COMMIT_HINT:
				sequence_PeriodicCommitHint(context, (PeriodicCommitHint) semanticObject); 
				return; 
			case OpenCypherPackage.PROCEDURE_NAME:
				sequence_ProcedureName(context, (ProcedureName) semanticObject); 
				return; 
			case OpenCypherPackage.PROPERTY_EXPRESSION:
				sequence_PropertyExpression(context, (PropertyExpression) semanticObject); 
				return; 
			case OpenCypherPackage.PROPERTY_LOOKUP:
				sequence_PropertyLookup(context, (PropertyLookup) semanticObject); 
				return; 
			case OpenCypherPackage.RANGE_LITERAL:
				sequence_RangeLiteral(context, (RangeLiteral) semanticObject); 
				return; 
			case OpenCypherPackage.REDUCE:
				sequence_Reduce(context, (Reduce) semanticObject); 
				return; 
			case OpenCypherPackage.REG_EXP_MATCHING_EXPRESSION:
				sequence_Expression3(context, (RegExpMatchingExpression) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_DETAIL:
				sequence_RelationshipDetail(context, (RelationshipDetail) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PATTERN:
				sequence_RelationshipPattern(context, (RelationshipPattern) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PATTERN_SYNTAX:
				sequence_RelationshipPatternSyntax(context, (RelationshipPatternSyntax) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_RelationshipPropertyExistenceConstraint(context, (RelationshipPropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_TYPES:
				sequence_RelationshipTypes(context, (RelationshipTypes) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIPS_PATTERN:
				sequence_RelationshipsPattern(context, (RelationshipsPattern) semanticObject); 
				return; 
			case OpenCypherPackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case OpenCypherPackage.REMOVE_ITEM_LABEL:
				sequence_RemoveItem(context, (RemoveItemLabel) semanticObject); 
				return; 
			case OpenCypherPackage.REMOVE_ITEM_PROPERTY:
				sequence_RemoveItem(context, (RemoveItemProperty) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_BODY:
				sequence_ReturnBody(context, (ReturnBody) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_ITEM:
				sequence_ReturnItem(context, (ReturnItem) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_ITEMS:
				sequence_ReturnItems(context, (ReturnItems) semanticObject); 
				return; 
			case OpenCypherPackage.SCAN_HINT:
				sequence_Hint(context, (ScanHint) semanticObject); 
				return; 
			case OpenCypherPackage.SET:
				sequence_Set(context, (org.slizaa.neo4j.opencypher.openCypher.Set) semanticObject); 
				return; 
			case OpenCypherPackage.SET_ITEM:
				sequence_SetItem(context, (SetItem) semanticObject); 
				return; 
			case OpenCypherPackage.SHORTEST_PATH:
				sequence_ShortestPathPattern(context, (ShortestPath) semanticObject); 
				return; 
			case OpenCypherPackage.SINGLE:
				sequence_Atom(context, (Single) semanticObject); 
				return; 
			case OpenCypherPackage.SINGLE_QUERY:
				sequence_SingleQuery(context, (SingleQuery) semanticObject); 
				return; 
			case OpenCypherPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case OpenCypherPackage.SORT_ITEM:
				sequence_SortItem(context, (SortItem) semanticObject); 
				return; 
			case OpenCypherPackage.STANDALONE_CALL:
				sequence_StandaloneCall(context, (StandaloneCall) semanticObject); 
				return; 
			case OpenCypherPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case OpenCypherPackage.START_POINT:
				sequence_StartPoint(context, (StartPoint) semanticObject); 
				return; 
			case OpenCypherPackage.STARTS_WITH_EXPRESSION:
				sequence_Expression3(context, (StartsWithExpression) semanticObject); 
				return; 
			case OpenCypherPackage.STRING_CONSTANT:
				sequence_Atom(context, (StringConstant) semanticObject); 
				return; 
			case OpenCypherPackage.UNION:
				sequence_Union(context, (Union) semanticObject); 
				return; 
			case OpenCypherPackage.UNIQUE_CONSTRAINT:
				sequence_UniqueConstraint(context, (UniqueConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.UNWIND:
				sequence_Unwind(context, (Unwind) semanticObject); 
				return; 
			case OpenCypherPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case OpenCypherPackage.VARIABLE_REF:
				sequence_Atom(context, (VariableRef) semanticObject); 
				return; 
			case OpenCypherPackage.VERSION_NUMBER:
				sequence_VersionNumber(context, (VersionNumber) semanticObject); 
				return; 
			case OpenCypherPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			case OpenCypherPackage.WITH:
				sequence_With(context, (With) semanticObject); 
				return; 
			case OpenCypherPackage.YIELD_ITEM:
				sequence_YieldItem(context, (YieldItem) semanticObject); 
				return; 
			case OpenCypherPackage.YIELD_ITEMS:
				sequence_YieldItems(context, (YieldItems) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns All
	 *     ExpressionOr returns All
	 *     ExpressionOr.ExpressionOr_1_0 returns All
	 *     ExpressionXor returns All
	 *     ExpressionXor.ExpressionXor_1_0 returns All
	 *     ExpressionAnd returns All
	 *     ExpressionAnd.ExpressionAnd_1_0 returns All
	 *     ExpressionNot returns All
	 *     ExpressionComparison returns All
	 *     ExpressionComparison.ExpressionComparison_1_0 returns All
	 *     ExpressionPlusMinus returns All
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns All
	 *     ExpressionMulDiv returns All
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns All
	 *     ExpressionPower returns All
	 *     ExpressionPower.ExpressionPower_1_0 returns All
	 *     ExpressionUnaryPlusMinus returns All
	 *     Expression3 returns All
	 *     Expression3.IndexExpression_1_0_0 returns All
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns All
	 *     Expression3.InCollectionExpression_1_2_0 returns All
	 *     Expression3.StartsWithExpression_1_3_0 returns All
	 *     Expression3.EndsWithExpression_1_4_0 returns All
	 *     Expression3.ContainsExpression_1_5_0 returns All
	 *     Expression3.IsNullExpression_1_6_0 returns All
	 *     Expression3.IsNotNullExpression_1_7_0 returns All
	 *     ExpressionNodeLabelsAndPropertyLookup returns All
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns All
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns All
	 *     Atom returns All
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, All semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ALL__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ALL__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_15_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Any
	 *     ExpressionOr returns Any
	 *     ExpressionOr.ExpressionOr_1_0 returns Any
	 *     ExpressionXor returns Any
	 *     ExpressionXor.ExpressionXor_1_0 returns Any
	 *     ExpressionAnd returns Any
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Any
	 *     ExpressionNot returns Any
	 *     ExpressionComparison returns Any
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Any
	 *     ExpressionPlusMinus returns Any
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Any
	 *     ExpressionMulDiv returns Any
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Any
	 *     ExpressionPower returns Any
	 *     ExpressionPower.ExpressionPower_1_0 returns Any
	 *     ExpressionUnaryPlusMinus returns Any
	 *     Expression3 returns Any
	 *     Expression3.IndexExpression_1_0_0 returns Any
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns Any
	 *     Expression3.InCollectionExpression_1_2_0 returns Any
	 *     Expression3.StartsWithExpression_1_3_0 returns Any
	 *     Expression3.EndsWithExpression_1_4_0 returns Any
	 *     Expression3.ContainsExpression_1_5_0 returns Any
	 *     Expression3.IsNullExpression_1_6_0 returns Any
	 *     Expression3.IsNotNullExpression_1_7_0 returns Any
	 *     ExpressionNodeLabelsAndPropertyLookup returns Any
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns Any
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns Any
	 *     Atom returns Any
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Any semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ANY__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ANY__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_16_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     ExpressionOr returns BoolConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns BoolConstant
	 *     ExpressionXor returns BoolConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns BoolConstant
	 *     ExpressionAnd returns BoolConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns BoolConstant
	 *     ExpressionNot returns BoolConstant
	 *     ExpressionComparison returns BoolConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns BoolConstant
	 *     ExpressionPlusMinus returns BoolConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns BoolConstant
	 *     ExpressionMulDiv returns BoolConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns BoolConstant
	 *     ExpressionPower returns BoolConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns BoolConstant
	 *     ExpressionUnaryPlusMinus returns BoolConstant
	 *     Expression3 returns BoolConstant
	 *     Expression3.IndexExpression_1_0_0 returns BoolConstant
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns BoolConstant
	 *     Expression3.InCollectionExpression_1_2_0 returns BoolConstant
	 *     Expression3.StartsWithExpression_1_3_0 returns BoolConstant
	 *     Expression3.EndsWithExpression_1_4_0 returns BoolConstant
	 *     Expression3.ContainsExpression_1_5_0 returns BoolConstant
	 *     Expression3.IsNullExpression_1_6_0 returns BoolConstant
	 *     Expression3.IsNotNullExpression_1_7_0 returns BoolConstant
	 *     ExpressionNodeLabelsAndPropertyLookup returns BoolConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns BoolConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns BoolConstant
	 *     Atom returns BoolConstant
	 *
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 */
	protected void sequence_Atom(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Count
	 *     ExpressionOr returns Count
	 *     ExpressionOr.ExpressionOr_1_0 returns Count
	 *     ExpressionXor returns Count
	 *     ExpressionXor.ExpressionXor_1_0 returns Count
	 *     ExpressionAnd returns Count
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Count
	 *     ExpressionNot returns Count
	 *     ExpressionComparison returns Count
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Count
	 *     ExpressionPlusMinus returns Count
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Count
	 *     ExpressionMulDiv returns Count
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Count
	 *     ExpressionPower returns Count
	 *     ExpressionPower.ExpressionPower_1_0 returns Count
	 *     ExpressionUnaryPlusMinus returns Count
	 *     Expression3 returns Count
	 *     Expression3.IndexExpression_1_0_0 returns Count
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns Count
	 *     Expression3.InCollectionExpression_1_2_0 returns Count
	 *     Expression3.StartsWithExpression_1_3_0 returns Count
	 *     Expression3.EndsWithExpression_1_4_0 returns Count
	 *     Expression3.ContainsExpression_1_5_0 returns Count
	 *     Expression3.IsNullExpression_1_6_0 returns Count
	 *     Expression3.IsNotNullExpression_1_7_0 returns Count
	 *     ExpressionNodeLabelsAndPropertyLookup returns Count
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns Count
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns Count
	 *     Atom returns Count
	 *
	 * Constraint:
	 *     {Count}
	 */
	protected void sequence_Atom(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionList
	 *     ExpressionOr returns ExpressionList
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionList
	 *     ExpressionXor returns ExpressionList
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionList
	 *     ExpressionAnd returns ExpressionList
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionList
	 *     ExpressionNot returns ExpressionList
	 *     ExpressionComparison returns ExpressionList
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionList
	 *     ExpressionPlusMinus returns ExpressionList
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionList
	 *     ExpressionMulDiv returns ExpressionList
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionList
	 *     ExpressionPower returns ExpressionList
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionList
	 *     ExpressionUnaryPlusMinus returns ExpressionList
	 *     Expression3 returns ExpressionList
	 *     Expression3.IndexExpression_1_0_0 returns ExpressionList
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns ExpressionList
	 *     Expression3.InCollectionExpression_1_2_0 returns ExpressionList
	 *     Expression3.StartsWithExpression_1_3_0 returns ExpressionList
	 *     Expression3.EndsWithExpression_1_4_0 returns ExpressionList
	 *     Expression3.ContainsExpression_1_5_0 returns ExpressionList
	 *     Expression3.IsNullExpression_1_6_0 returns ExpressionList
	 *     Expression3.IsNotNullExpression_1_7_0 returns ExpressionList
	 *     ExpressionNodeLabelsAndPropertyLookup returns ExpressionList
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns ExpressionList
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns ExpressionList
	 *     Atom returns ExpressionList
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)?
	 */
	protected void sequence_Atom(ISerializationContext context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Extract
	 *     ExpressionOr returns Extract
	 *     ExpressionOr.ExpressionOr_1_0 returns Extract
	 *     ExpressionXor returns Extract
	 *     ExpressionXor.ExpressionXor_1_0 returns Extract
	 *     ExpressionAnd returns Extract
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Extract
	 *     ExpressionNot returns Extract
	 *     ExpressionComparison returns Extract
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Extract
	 *     ExpressionPlusMinus returns Extract
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Extract
	 *     ExpressionMulDiv returns Extract
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Extract
	 *     ExpressionPower returns Extract
	 *     ExpressionPower.ExpressionPower_1_0 returns Extract
	 *     ExpressionUnaryPlusMinus returns Extract
	 *     Expression3 returns Extract
	 *     Expression3.IndexExpression_1_0_0 returns Extract
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns Extract
	 *     Expression3.InCollectionExpression_1_2_0 returns Extract
	 *     Expression3.StartsWithExpression_1_3_0 returns Extract
	 *     Expression3.EndsWithExpression_1_4_0 returns Extract
	 *     Expression3.ContainsExpression_1_5_0 returns Extract
	 *     Expression3.IsNullExpression_1_6_0 returns Extract
	 *     Expression3.IsNotNullExpression_1_7_0 returns Extract
	 *     ExpressionNodeLabelsAndPropertyLookup returns Extract
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns Extract
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns Extract
	 *     Atom returns Extract
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression?)
	 */
	protected void sequence_Atom(ISerializationContext context, Extract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Filter
	 *     ExpressionOr returns Filter
	 *     ExpressionOr.ExpressionOr_1_0 returns Filter
	 *     ExpressionXor returns Filter
	 *     ExpressionXor.ExpressionXor_1_0 returns Filter
	 *     ExpressionAnd returns Filter
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Filter
	 *     ExpressionNot returns Filter
	 *     ExpressionComparison returns Filter
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Filter
	 *     ExpressionPlusMinus returns Filter
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Filter
	 *     ExpressionMulDiv returns Filter
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Filter
	 *     ExpressionPower returns Filter
	 *     ExpressionPower.ExpressionPower_1_0 returns Filter
	 *     ExpressionUnaryPlusMinus returns Filter
	 *     Expression3 returns Filter
	 *     Expression3.IndexExpression_1_0_0 returns Filter
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns Filter
	 *     Expression3.InCollectionExpression_1_2_0 returns Filter
	 *     Expression3.StartsWithExpression_1_3_0 returns Filter
	 *     Expression3.EndsWithExpression_1_4_0 returns Filter
	 *     Expression3.ContainsExpression_1_5_0 returns Filter
	 *     Expression3.IsNullExpression_1_6_0 returns Filter
	 *     Expression3.IsNotNullExpression_1_7_0 returns Filter
	 *     ExpressionNodeLabelsAndPropertyLookup returns Filter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns Filter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns Filter
	 *     Atom returns Filter
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Filter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.FILTER__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.FILTER__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_14_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns None
	 *     ExpressionOr returns None
	 *     ExpressionOr.ExpressionOr_1_0 returns None
	 *     ExpressionXor returns None
	 *     ExpressionXor.ExpressionXor_1_0 returns None
	 *     ExpressionAnd returns None
	 *     ExpressionAnd.ExpressionAnd_1_0 returns None
	 *     ExpressionNot returns None
	 *     ExpressionComparison returns None
	 *     ExpressionComparison.ExpressionComparison_1_0 returns None
	 *     ExpressionPlusMinus returns None
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns None
	 *     ExpressionMulDiv returns None
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns None
	 *     ExpressionPower returns None
	 *     ExpressionPower.ExpressionPower_1_0 returns None
	 *     ExpressionUnaryPlusMinus returns None
	 *     Expression3 returns None
	 *     Expression3.IndexExpression_1_0_0 returns None
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns None
	 *     Expression3.InCollectionExpression_1_2_0 returns None
	 *     Expression3.StartsWithExpression_1_3_0 returns None
	 *     Expression3.EndsWithExpression_1_4_0 returns None
	 *     Expression3.ContainsExpression_1_5_0 returns None
	 *     Expression3.IsNullExpression_1_6_0 returns None
	 *     Expression3.IsNotNullExpression_1_7_0 returns None
	 *     ExpressionNodeLabelsAndPropertyLookup returns None
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns None
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns None
	 *     Atom returns None
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, None semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NONE__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NONE__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_17_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullConstant
	 *     ExpressionOr returns NullConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns NullConstant
	 *     ExpressionXor returns NullConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns NullConstant
	 *     ExpressionAnd returns NullConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns NullConstant
	 *     ExpressionNot returns NullConstant
	 *     ExpressionComparison returns NullConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns NullConstant
	 *     ExpressionPlusMinus returns NullConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns NullConstant
	 *     ExpressionMulDiv returns NullConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns NullConstant
	 *     ExpressionPower returns NullConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns NullConstant
	 *     ExpressionUnaryPlusMinus returns NullConstant
	 *     Expression3 returns NullConstant
	 *     Expression3.IndexExpression_1_0_0 returns NullConstant
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns NullConstant
	 *     Expression3.InCollectionExpression_1_2_0 returns NullConstant
	 *     Expression3.StartsWithExpression_1_3_0 returns NullConstant
	 *     Expression3.EndsWithExpression_1_4_0 returns NullConstant
	 *     Expression3.ContainsExpression_1_5_0 returns NullConstant
	 *     Expression3.IsNullExpression_1_6_0 returns NullConstant
	 *     Expression3.IsNotNullExpression_1_7_0 returns NullConstant
	 *     ExpressionNodeLabelsAndPropertyLookup returns NullConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns NullConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns NullConstant
	 *     Atom returns NullConstant
	 *
	 * Constraint:
	 *     {NullConstant}
	 */
	protected void sequence_Atom(ISerializationContext context, NullConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberConstant
	 *     ExpressionOr returns NumberConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns NumberConstant
	 *     ExpressionXor returns NumberConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns NumberConstant
	 *     ExpressionAnd returns NumberConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns NumberConstant
	 *     ExpressionNot returns NumberConstant
	 *     ExpressionComparison returns NumberConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns NumberConstant
	 *     ExpressionPlusMinus returns NumberConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns NumberConstant
	 *     ExpressionMulDiv returns NumberConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns NumberConstant
	 *     ExpressionPower returns NumberConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns NumberConstant
	 *     ExpressionUnaryPlusMinus returns NumberConstant
	 *     Expression3 returns NumberConstant
	 *     Expression3.IndexExpression_1_0_0 returns NumberConstant
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns NumberConstant
	 *     Expression3.InCollectionExpression_1_2_0 returns NumberConstant
	 *     Expression3.StartsWithExpression_1_3_0 returns NumberConstant
	 *     Expression3.EndsWithExpression_1_4_0 returns NumberConstant
	 *     Expression3.ContainsExpression_1_5_0 returns NumberConstant
	 *     Expression3.IsNullExpression_1_6_0 returns NumberConstant
	 *     Expression3.IsNotNullExpression_1_7_0 returns NumberConstant
	 *     ExpressionNodeLabelsAndPropertyLookup returns NumberConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns NumberConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns NumberConstant
	 *     Atom returns NumberConstant
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_Atom(ISerializationContext context, NumberConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NUMBER_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NUMBER_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getValueNumberParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Single
	 *     ExpressionOr returns Single
	 *     ExpressionOr.ExpressionOr_1_0 returns Single
	 *     ExpressionXor returns Single
	 *     ExpressionXor.ExpressionXor_1_0 returns Single
	 *     ExpressionAnd returns Single
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Single
	 *     ExpressionNot returns Single
	 *     ExpressionComparison returns Single
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Single
	 *     ExpressionPlusMinus returns Single
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Single
	 *     ExpressionMulDiv returns Single
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Single
	 *     ExpressionPower returns Single
	 *     ExpressionPower.ExpressionPower_1_0 returns Single
	 *     ExpressionUnaryPlusMinus returns Single
	 *     Expression3 returns Single
	 *     Expression3.IndexExpression_1_0_0 returns Single
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns Single
	 *     Expression3.InCollectionExpression_1_2_0 returns Single
	 *     Expression3.StartsWithExpression_1_3_0 returns Single
	 *     Expression3.EndsWithExpression_1_4_0 returns Single
	 *     Expression3.ContainsExpression_1_5_0 returns Single
	 *     Expression3.IsNullExpression_1_6_0 returns Single
	 *     Expression3.IsNotNullExpression_1_7_0 returns Single
	 *     ExpressionNodeLabelsAndPropertyLookup returns Single
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns Single
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns Single
	 *     Atom returns Single
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Single semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SINGLE__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SINGLE__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_18_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     ExpressionOr returns StringConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns StringConstant
	 *     ExpressionXor returns StringConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns StringConstant
	 *     ExpressionAnd returns StringConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns StringConstant
	 *     ExpressionNot returns StringConstant
	 *     ExpressionComparison returns StringConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns StringConstant
	 *     ExpressionPlusMinus returns StringConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns StringConstant
	 *     ExpressionMulDiv returns StringConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns StringConstant
	 *     ExpressionPower returns StringConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns StringConstant
	 *     ExpressionUnaryPlusMinus returns StringConstant
	 *     Expression3 returns StringConstant
	 *     Expression3.IndexExpression_1_0_0 returns StringConstant
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns StringConstant
	 *     Expression3.InCollectionExpression_1_2_0 returns StringConstant
	 *     Expression3.StartsWithExpression_1_3_0 returns StringConstant
	 *     Expression3.EndsWithExpression_1_4_0 returns StringConstant
	 *     Expression3.ContainsExpression_1_5_0 returns StringConstant
	 *     Expression3.IsNullExpression_1_6_0 returns StringConstant
	 *     Expression3.IsNotNullExpression_1_7_0 returns StringConstant
	 *     ExpressionNodeLabelsAndPropertyLookup returns StringConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns StringConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns StringConstant
	 *     Atom returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING_LITERAL
	 */
	protected void sequence_Atom(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getValueSTRING_LITERALTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableRef
	 *     ExpressionOr returns VariableRef
	 *     ExpressionOr.ExpressionOr_1_0 returns VariableRef
	 *     ExpressionXor returns VariableRef
	 *     ExpressionXor.ExpressionXor_1_0 returns VariableRef
	 *     ExpressionAnd returns VariableRef
	 *     ExpressionAnd.ExpressionAnd_1_0 returns VariableRef
	 *     ExpressionNot returns VariableRef
	 *     ExpressionComparison returns VariableRef
	 *     ExpressionComparison.ExpressionComparison_1_0 returns VariableRef
	 *     ExpressionPlusMinus returns VariableRef
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns VariableRef
	 *     ExpressionMulDiv returns VariableRef
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns VariableRef
	 *     ExpressionPower returns VariableRef
	 *     ExpressionPower.ExpressionPower_1_0 returns VariableRef
	 *     ExpressionUnaryPlusMinus returns VariableRef
	 *     Expression3 returns VariableRef
	 *     Expression3.IndexExpression_1_0_0 returns VariableRef
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns VariableRef
	 *     Expression3.InCollectionExpression_1_2_0 returns VariableRef
	 *     Expression3.StartsWithExpression_1_3_0 returns VariableRef
	 *     Expression3.EndsWithExpression_1_4_0 returns VariableRef
	 *     Expression3.ContainsExpression_1_5_0 returns VariableRef
	 *     Expression3.IsNullExpression_1_6_0 returns VariableRef
	 *     Expression3.IsNotNullExpression_1_7_0 returns VariableRef
	 *     ExpressionNodeLabelsAndPropertyLookup returns VariableRef
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns VariableRef
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns VariableRef
	 *     Atom returns VariableRef
	 *
	 * Constraint:
	 *     variableRef=[VariableDeclaration|SYMBOLIC_NAME_X]
	 */
	protected void sequence_Atom(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getVariableRefVariableDeclarationSYMBOLIC_NAME_XParserRuleCall_23_1_0_1(), semanticObject.eGet(OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BulkImportQuery
	 *     Query returns BulkImportQuery
	 *     BulkImportQuery returns BulkImportQuery
	 *
	 * Constraint:
	 *     (periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery)
	 */
	protected void sequence_BulkImportQuery(ISerializationContext context, BulkImportQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__PERIODIC_COMMIT_HINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__PERIODIC_COMMIT_HINT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__LOAD_CSV_QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__LOAD_CSV_QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBulkImportQueryAccess().getPeriodicCommitHintPeriodicCommitHintParserRuleCall_0_0(), semanticObject.getPeriodicCommitHint());
		feeder.accept(grammarAccess.getBulkImportQueryAccess().getLoadCSVQueryLoadCSVQueryParserRuleCall_1_0(), semanticObject.getLoadCSVQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseAlternatives returns CaseAlternatives
	 *
	 * Constraint:
	 *     (when=Expression then=Expression)
	 */
	protected void sequence_CaseAlternatives(ISerializationContext context, CaseAlternatives semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__WHEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__WHEN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAlternativesAccess().getWhenExpressionParserRuleCall_1_0(), semanticObject.getWhen());
		feeder.accept(grammarAccess.getCaseAlternativesAccess().getThenExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CaseExpression
	 *     ExpressionOr returns CaseExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns CaseExpression
	 *     ExpressionXor returns CaseExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns CaseExpression
	 *     ExpressionAnd returns CaseExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns CaseExpression
	 *     ExpressionNot returns CaseExpression
	 *     ExpressionComparison returns CaseExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns CaseExpression
	 *     ExpressionPlusMinus returns CaseExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns CaseExpression
	 *     ExpressionMulDiv returns CaseExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns CaseExpression
	 *     ExpressionPower returns CaseExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns CaseExpression
	 *     ExpressionUnaryPlusMinus returns CaseExpression
	 *     Expression3 returns CaseExpression
	 *     Expression3.IndexExpression_1_0_0 returns CaseExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns CaseExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns CaseExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns CaseExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns CaseExpression
	 *     Expression3.ContainsExpression_1_5_0 returns CaseExpression
	 *     Expression3.IsNullExpression_1_6_0 returns CaseExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns CaseExpression
	 *     ExpressionNodeLabelsAndPropertyLookup returns CaseExpression
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns CaseExpression
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns CaseExpression
	 *     Atom returns CaseExpression
	 *     CaseExpression returns CaseExpression
	 *
	 * Constraint:
	 *     ((caseAlternatives+=CaseAlternatives+ | (caseExpression=Expression caseAlternatives+=CaseAlternatives+)) elseExpression=Expression?)
	 */
	protected void sequence_CaseExpression(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationOption returns ConfigurationOption
	 *
	 * Constraint:
	 *     (key=SYMBOLIC_NAME_X value=SYMBOLIC_NAME_X)
	 */
	protected void sequence_ConfigurationOption(ISerializationContext context, ConfigurationOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConfigurationOptionAccess().getKeySYMBOLIC_NAME_XParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getConfigurationOptionAccess().getValueSYMBOLIC_NAME_XParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CreateIndex
	 *     Command returns CreateIndex
	 *     CreateIndex returns CreateIndex
	 *
	 * Constraint:
	 *     index=Index
	 */
	protected void sequence_CreateIndex(ISerializationContext context, CreateIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CREATE_INDEX__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CREATE_INDEX__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateIndexAccess().getIndexIndexParserRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Create
	 *     Create returns Create
	 *
	 * Constraint:
	 *     (unique?='UNIQUE'? pattern=Pattern)
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CypherOption returns CypherOption
	 *
	 * Constraint:
	 *     (versionNumber=VersionNumber? configurationOption+=ConfigurationOption*)
	 */
	protected void sequence_CypherOption(ISerializationContext context, CypherOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cypher returns Cypher
	 *
	 * Constraint:
	 *     (queryOptions=QueryOptions statement=Statement)
	 */
	protected void sequence_Cypher(ISerializationContext context, Cypher semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CYPHER__QUERY_OPTIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CYPHER__QUERY_OPTIONS));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CYPHER__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CYPHER__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCypherAccess().getQueryOptionsQueryOptionsParserRuleCall_1_0(), semanticObject.getQueryOptions());
		feeder.accept(grammarAccess.getCypherAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DecimalInteger returns DecimalInteger
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_DecimalInteger(ISerializationContext context, DecimalInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DECIMAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DECIMAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalIntegerAccess().getValueNumberParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     (detach?='DETACH'? expressions+=Expression expressions+=Expression*)
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropIndex
	 *     Command returns DropIndex
	 *     DropIndex returns DropIndex
	 *
	 * Constraint:
	 *     index=Index
	 */
	protected void sequence_DropIndex(ISerializationContext context, DropIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_INDEX__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_INDEX__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropIndexAccess().getIndexIndexParserRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropNodePropertyExistenceConstraint
	 *     Command returns DropNodePropertyExistenceConstraint
	 *     DropNodePropertyExistenceConstraint returns DropNodePropertyExistenceConstraint
	 *
	 * Constraint:
	 *     nodePropertyExistenceConstraint=NodePropertyExistenceConstraint
	 */
	protected void sequence_DropNodePropertyExistenceConstraint(ISerializationContext context, DropNodePropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_PROPERTY_EXISTENCE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_PROPERTY_EXISTENCE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropNodePropertyExistenceConstraintAccess().getNodePropertyExistenceConstraintNodePropertyExistenceConstraintParserRuleCall_1_0(), semanticObject.getNodePropertyExistenceConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropRelationshipPropertyExistenceConstraint
	 *     Command returns DropRelationshipPropertyExistenceConstraint
	 *     DropRelationshipPropertyExistenceConstraint returns DropRelationshipPropertyExistenceConstraint
	 *
	 * Constraint:
	 *     relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint
	 */
	protected void sequence_DropRelationshipPropertyExistenceConstraint(ISerializationContext context, DropRelationshipPropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropRelationshipPropertyExistenceConstraintAccess().getRelationshipPropertyExistenceConstraintRelationshipPropertyExistenceConstraintParserRuleCall_1_0(), semanticObject.getRelationshipPropertyExistenceConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropUniqueConstraint
	 *     Command returns DropUniqueConstraint
	 *     DropUniqueConstraint returns DropUniqueConstraint
	 *
	 * Constraint:
	 *     uniqueConstraint=UniqueConstraint
	 */
	protected void sequence_DropUniqueConstraint(ISerializationContext context, DropUniqueConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_UNIQUE_CONSTRAINT__UNIQUE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_UNIQUE_CONSTRAINT__UNIQUE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropUniqueConstraintAccess().getUniqueConstraintUniqueConstraintParserRuleCall_1_0(), semanticObject.getUniqueConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExplicitProcedureInvocation returns ExplicitProcedureInvocation
	 *
	 * Constraint:
	 *     (procedureName=ProcedureName (parameter+=Expression parameter+=Expression*)?)
	 */
	protected void sequence_ExplicitProcedureInvocation(ISerializationContext context, ExplicitProcedureInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ContainsExpression
	 *     ExpressionOr returns ContainsExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns ContainsExpression
	 *     ExpressionXor returns ContainsExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns ContainsExpression
	 *     ExpressionAnd returns ContainsExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ContainsExpression
	 *     ExpressionNot returns ContainsExpression
	 *     ExpressionComparison returns ContainsExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ContainsExpression
	 *     ExpressionPlusMinus returns ContainsExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ContainsExpression
	 *     ExpressionMulDiv returns ContainsExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ContainsExpression
	 *     ExpressionPower returns ContainsExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns ContainsExpression
	 *     ExpressionUnaryPlusMinus returns ContainsExpression
	 *     Expression3 returns ContainsExpression
	 *     Expression3.IndexExpression_1_0_0 returns ContainsExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns ContainsExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns ContainsExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns ContainsExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns ContainsExpression
	 *     Expression3.ContainsExpression_1_5_0 returns ContainsExpression
	 *     Expression3.IsNullExpression_1_6_0 returns ContainsExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns ContainsExpression
	 *
	 * Constraint:
	 *     (left=Expression3_ContainsExpression_1_5_0 right=ExpressionNodeLabelsAndPropertyLookup)
	 */
	protected void sequence_Expression3(ISerializationContext context, ContainsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONTAINS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONTAINS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONTAINS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONTAINS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3Access().getContainsExpressionLeftAction_1_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression3Access().getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_5_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EndsWithExpression
	 *     ExpressionOr returns EndsWithExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns EndsWithExpression
	 *     ExpressionXor returns EndsWithExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns EndsWithExpression
	 *     ExpressionAnd returns EndsWithExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns EndsWithExpression
	 *     ExpressionNot returns EndsWithExpression
	 *     ExpressionComparison returns EndsWithExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns EndsWithExpression
	 *     ExpressionPlusMinus returns EndsWithExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns EndsWithExpression
	 *     ExpressionMulDiv returns EndsWithExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns EndsWithExpression
	 *     ExpressionPower returns EndsWithExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns EndsWithExpression
	 *     ExpressionUnaryPlusMinus returns EndsWithExpression
	 *     Expression3 returns EndsWithExpression
	 *     Expression3.IndexExpression_1_0_0 returns EndsWithExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns EndsWithExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns EndsWithExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns EndsWithExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns EndsWithExpression
	 *     Expression3.ContainsExpression_1_5_0 returns EndsWithExpression
	 *     Expression3.IsNullExpression_1_6_0 returns EndsWithExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns EndsWithExpression
	 *
	 * Constraint:
	 *     (left=Expression3_EndsWithExpression_1_4_0 right=ExpressionNodeLabelsAndPropertyLookup)
	 */
	protected void sequence_Expression3(ISerializationContext context, EndsWithExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ENDS_WITH_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ENDS_WITH_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ENDS_WITH_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ENDS_WITH_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3Access().getEndsWithExpressionLeftAction_1_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression3Access().getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_4_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InCollectionExpression
	 *     ExpressionOr returns InCollectionExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns InCollectionExpression
	 *     ExpressionXor returns InCollectionExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns InCollectionExpression
	 *     ExpressionAnd returns InCollectionExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns InCollectionExpression
	 *     ExpressionNot returns InCollectionExpression
	 *     ExpressionComparison returns InCollectionExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns InCollectionExpression
	 *     ExpressionPlusMinus returns InCollectionExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns InCollectionExpression
	 *     ExpressionMulDiv returns InCollectionExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns InCollectionExpression
	 *     ExpressionPower returns InCollectionExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns InCollectionExpression
	 *     ExpressionUnaryPlusMinus returns InCollectionExpression
	 *     Expression3 returns InCollectionExpression
	 *     Expression3.IndexExpression_1_0_0 returns InCollectionExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns InCollectionExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns InCollectionExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns InCollectionExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns InCollectionExpression
	 *     Expression3.ContainsExpression_1_5_0 returns InCollectionExpression
	 *     Expression3.IsNullExpression_1_6_0 returns InCollectionExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns InCollectionExpression
	 *
	 * Constraint:
	 *     (left=Expression3_InCollectionExpression_1_2_0 right=ExpressionNodeLabelsAndPropertyLookup)
	 */
	protected void sequence_Expression3(ISerializationContext context, InCollectionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.IN_COLLECTION_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.IN_COLLECTION_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.IN_COLLECTION_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.IN_COLLECTION_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3Access().getInCollectionExpressionLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression3Access().getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IndexExpression
	 *     ExpressionOr returns IndexExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns IndexExpression
	 *     ExpressionXor returns IndexExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns IndexExpression
	 *     ExpressionAnd returns IndexExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns IndexExpression
	 *     ExpressionNot returns IndexExpression
	 *     ExpressionComparison returns IndexExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns IndexExpression
	 *     ExpressionPlusMinus returns IndexExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns IndexExpression
	 *     ExpressionMulDiv returns IndexExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns IndexExpression
	 *     ExpressionPower returns IndexExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns IndexExpression
	 *     ExpressionUnaryPlusMinus returns IndexExpression
	 *     Expression3 returns IndexExpression
	 *     Expression3.IndexExpression_1_0_0 returns IndexExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns IndexExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns IndexExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns IndexExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns IndexExpression
	 *     Expression3.ContainsExpression_1_5_0 returns IndexExpression
	 *     Expression3.IsNullExpression_1_6_0 returns IndexExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns IndexExpression
	 *
	 * Constraint:
	 *     (left=Expression3_IndexExpression_1_0_0 expression=Expression upper=Expression?)
	 */
	protected void sequence_Expression3(ISerializationContext context, IndexExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IsNotNullExpression
	 *     ExpressionOr returns IsNotNullExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns IsNotNullExpression
	 *     ExpressionXor returns IsNotNullExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns IsNotNullExpression
	 *     ExpressionAnd returns IsNotNullExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns IsNotNullExpression
	 *     ExpressionNot returns IsNotNullExpression
	 *     ExpressionComparison returns IsNotNullExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns IsNotNullExpression
	 *     ExpressionPlusMinus returns IsNotNullExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns IsNotNullExpression
	 *     ExpressionMulDiv returns IsNotNullExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns IsNotNullExpression
	 *     ExpressionPower returns IsNotNullExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns IsNotNullExpression
	 *     ExpressionUnaryPlusMinus returns IsNotNullExpression
	 *     Expression3 returns IsNotNullExpression
	 *     Expression3.IndexExpression_1_0_0 returns IsNotNullExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns IsNotNullExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns IsNotNullExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns IsNotNullExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns IsNotNullExpression
	 *     Expression3.ContainsExpression_1_5_0 returns IsNotNullExpression
	 *     Expression3.IsNullExpression_1_6_0 returns IsNotNullExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns IsNotNullExpression
	 *
	 * Constraint:
	 *     left=Expression3_IsNotNullExpression_1_7_0
	 */
	protected void sequence_Expression3(ISerializationContext context, IsNotNullExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.IS_NOT_NULL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.IS_NOT_NULL_EXPRESSION__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3Access().getIsNotNullExpressionLeftAction_1_7_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IsNullExpression
	 *     ExpressionOr returns IsNullExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns IsNullExpression
	 *     ExpressionXor returns IsNullExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns IsNullExpression
	 *     ExpressionAnd returns IsNullExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns IsNullExpression
	 *     ExpressionNot returns IsNullExpression
	 *     ExpressionComparison returns IsNullExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns IsNullExpression
	 *     ExpressionPlusMinus returns IsNullExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns IsNullExpression
	 *     ExpressionMulDiv returns IsNullExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns IsNullExpression
	 *     ExpressionPower returns IsNullExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns IsNullExpression
	 *     ExpressionUnaryPlusMinus returns IsNullExpression
	 *     Expression3 returns IsNullExpression
	 *     Expression3.IndexExpression_1_0_0 returns IsNullExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns IsNullExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns IsNullExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns IsNullExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns IsNullExpression
	 *     Expression3.ContainsExpression_1_5_0 returns IsNullExpression
	 *     Expression3.IsNullExpression_1_6_0 returns IsNullExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns IsNullExpression
	 *
	 * Constraint:
	 *     left=Expression3_IsNullExpression_1_6_0
	 */
	protected void sequence_Expression3(ISerializationContext context, IsNullExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.IS_NULL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.IS_NULL_EXPRESSION__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3Access().getIsNullExpressionLeftAction_1_6_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RegExpMatchingExpression
	 *     ExpressionOr returns RegExpMatchingExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns RegExpMatchingExpression
	 *     ExpressionXor returns RegExpMatchingExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns RegExpMatchingExpression
	 *     ExpressionAnd returns RegExpMatchingExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns RegExpMatchingExpression
	 *     ExpressionNot returns RegExpMatchingExpression
	 *     ExpressionComparison returns RegExpMatchingExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns RegExpMatchingExpression
	 *     ExpressionPlusMinus returns RegExpMatchingExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns RegExpMatchingExpression
	 *     ExpressionMulDiv returns RegExpMatchingExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns RegExpMatchingExpression
	 *     ExpressionPower returns RegExpMatchingExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns RegExpMatchingExpression
	 *     ExpressionUnaryPlusMinus returns RegExpMatchingExpression
	 *     Expression3 returns RegExpMatchingExpression
	 *     Expression3.IndexExpression_1_0_0 returns RegExpMatchingExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns RegExpMatchingExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns RegExpMatchingExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns RegExpMatchingExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns RegExpMatchingExpression
	 *     Expression3.ContainsExpression_1_5_0 returns RegExpMatchingExpression
	 *     Expression3.IsNullExpression_1_6_0 returns RegExpMatchingExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns RegExpMatchingExpression
	 *
	 * Constraint:
	 *     (left=Expression3_RegExpMatchingExpression_1_1_0 right=ExpressionNodeLabelsAndPropertyLookup)
	 */
	protected void sequence_Expression3(ISerializationContext context, RegExpMatchingExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3Access().getRegExpMatchingExpressionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression3Access().getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StartsWithExpression
	 *     ExpressionOr returns StartsWithExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns StartsWithExpression
	 *     ExpressionXor returns StartsWithExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns StartsWithExpression
	 *     ExpressionAnd returns StartsWithExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns StartsWithExpression
	 *     ExpressionNot returns StartsWithExpression
	 *     ExpressionComparison returns StartsWithExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns StartsWithExpression
	 *     ExpressionPlusMinus returns StartsWithExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns StartsWithExpression
	 *     ExpressionMulDiv returns StartsWithExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns StartsWithExpression
	 *     ExpressionPower returns StartsWithExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns StartsWithExpression
	 *     ExpressionUnaryPlusMinus returns StartsWithExpression
	 *     Expression3 returns StartsWithExpression
	 *     Expression3.IndexExpression_1_0_0 returns StartsWithExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns StartsWithExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns StartsWithExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns StartsWithExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns StartsWithExpression
	 *     Expression3.ContainsExpression_1_5_0 returns StartsWithExpression
	 *     Expression3.IsNullExpression_1_6_0 returns StartsWithExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns StartsWithExpression
	 *
	 * Constraint:
	 *     (left=Expression3_StartsWithExpression_1_3_0 right=ExpressionNodeLabelsAndPropertyLookup)
	 */
	protected void sequence_Expression3(ISerializationContext context, StartsWithExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.STARTS_WITH_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.STARTS_WITH_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.STARTS_WITH_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.STARTS_WITH_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3Access().getStartsWithExpressionLeftAction_1_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression3Access().getRightExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_3_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionAnd
	 *     ExpressionOr returns ExpressionAnd
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionAnd
	 *     ExpressionXor returns ExpressionAnd
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionAnd
	 *     ExpressionAnd returns ExpressionAnd
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionAnd
	 *
	 * Constraint:
	 *     (left=ExpressionAnd_ExpressionAnd_1_0 operator='AND' right=ExpressionNot)
	 */
	protected void sequence_ExpressionAnd(ISerializationContext context, ExpressionAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAndAccess().getOperatorANDKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionAndAccess().getRightExpressionNotParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionComparison
	 *     ExpressionOr returns ExpressionComparison
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionComparison
	 *     ExpressionXor returns ExpressionComparison
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionComparison
	 *     ExpressionAnd returns ExpressionComparison
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionComparison
	 *     ExpressionNot returns ExpressionComparison
	 *     ExpressionComparison returns ExpressionComparison
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionComparison
	 *
	 * Constraint:
	 *     (
	 *         left=ExpressionComparison_ExpressionComparison_1_0 
	 *         (
	 *             operator='=' | 
	 *             operator='<>' | 
	 *             operator='<' | 
	 *             operator='>' | 
	 *             operator='<=' | 
	 *             operator='>='
	 *         ) 
	 *         right=ExpressionPlusMinus
	 *     )
	 */
	protected void sequence_ExpressionComparison(ISerializationContext context, ExpressionComparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionMulDiv
	 *     ExpressionOr returns ExpressionMulDiv
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionMulDiv
	 *     ExpressionXor returns ExpressionMulDiv
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionMulDiv
	 *     ExpressionAnd returns ExpressionMulDiv
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionMulDiv
	 *     ExpressionNot returns ExpressionMulDiv
	 *     ExpressionComparison returns ExpressionMulDiv
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionMulDiv
	 *     ExpressionPlusMinus returns ExpressionMulDiv
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionMulDiv
	 *     ExpressionMulDiv returns ExpressionMulDiv
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionMulDiv
	 *
	 * Constraint:
	 *     (left=ExpressionMulDiv_ExpressionMulDiv_1_0 (operator='*' | operator='/' | operator='%') right=ExpressionPower)
	 */
	protected void sequence_ExpressionMulDiv(ISerializationContext context, ExpressionMulDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionNodeLabels
	 *     ExpressionOr returns ExpressionNodeLabels
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionNodeLabels
	 *     ExpressionXor returns ExpressionNodeLabels
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionNodeLabels
	 *     ExpressionAnd returns ExpressionNodeLabels
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionNodeLabels
	 *     ExpressionNot returns ExpressionNodeLabels
	 *     ExpressionComparison returns ExpressionNodeLabels
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionNodeLabels
	 *     ExpressionPlusMinus returns ExpressionNodeLabels
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionNodeLabels
	 *     ExpressionMulDiv returns ExpressionNodeLabels
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionNodeLabels
	 *     ExpressionPower returns ExpressionNodeLabels
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionNodeLabels
	 *     ExpressionUnaryPlusMinus returns ExpressionNodeLabels
	 *     Expression3 returns ExpressionNodeLabels
	 *     Expression3.IndexExpression_1_0_0 returns ExpressionNodeLabels
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns ExpressionNodeLabels
	 *     Expression3.InCollectionExpression_1_2_0 returns ExpressionNodeLabels
	 *     Expression3.StartsWithExpression_1_3_0 returns ExpressionNodeLabels
	 *     Expression3.EndsWithExpression_1_4_0 returns ExpressionNodeLabels
	 *     Expression3.ContainsExpression_1_5_0 returns ExpressionNodeLabels
	 *     Expression3.IsNullExpression_1_6_0 returns ExpressionNodeLabels
	 *     Expression3.IsNotNullExpression_1_7_0 returns ExpressionNodeLabels
	 *     ExpressionNodeLabelsAndPropertyLookup returns ExpressionNodeLabels
	 *
	 * Constraint:
	 *     (left=ExpressionNodeLabelsAndPropertyLookup_ExpressionNodeLabels_2_0 nodeLabels+=NodeLabel+)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, ExpressionNodeLabels semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionPropertyLookup
	 *     ExpressionOr returns ExpressionPropertyLookup
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionPropertyLookup
	 *     ExpressionXor returns ExpressionPropertyLookup
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionPropertyLookup
	 *     ExpressionAnd returns ExpressionPropertyLookup
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionPropertyLookup
	 *     ExpressionNot returns ExpressionPropertyLookup
	 *     ExpressionComparison returns ExpressionPropertyLookup
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionPropertyLookup
	 *     ExpressionPlusMinus returns ExpressionPropertyLookup
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionPropertyLookup
	 *     ExpressionMulDiv returns ExpressionPropertyLookup
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionPropertyLookup
	 *     ExpressionPower returns ExpressionPropertyLookup
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionPropertyLookup
	 *     ExpressionUnaryPlusMinus returns ExpressionPropertyLookup
	 *     Expression3 returns ExpressionPropertyLookup
	 *     Expression3.IndexExpression_1_0_0 returns ExpressionPropertyLookup
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns ExpressionPropertyLookup
	 *     Expression3.InCollectionExpression_1_2_0 returns ExpressionPropertyLookup
	 *     Expression3.StartsWithExpression_1_3_0 returns ExpressionPropertyLookup
	 *     Expression3.EndsWithExpression_1_4_0 returns ExpressionPropertyLookup
	 *     Expression3.ContainsExpression_1_5_0 returns ExpressionPropertyLookup
	 *     Expression3.IsNullExpression_1_6_0 returns ExpressionPropertyLookup
	 *     Expression3.IsNotNullExpression_1_7_0 returns ExpressionPropertyLookup
	 *     ExpressionNodeLabelsAndPropertyLookup returns ExpressionPropertyLookup
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns ExpressionPropertyLookup
	 *
	 * Constraint:
	 *     (left=ExpressionNodeLabelsAndPropertyLookup_ExpressionPropertyLookup_1_0 propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, ExpressionPropertyLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionNot
	 *     ExpressionOr returns ExpressionNot
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionNot
	 *     ExpressionXor returns ExpressionNot
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionNot
	 *     ExpressionAnd returns ExpressionNot
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionNot
	 *     ExpressionNot returns ExpressionNot
	 *
	 * Constraint:
	 *     (operator='NOT' left=ExpressionNot)
	 */
	protected void sequence_ExpressionNot(ISerializationContext context, ExpressionNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_NOT__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_NOT__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_NOT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_NOT__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionNotAccess().getOperatorNOTKeyword_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionNotAccess().getLeftExpressionNotParserRuleCall_0_2_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionOr
	 *     ExpressionOr returns ExpressionOr
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionOr
	 *
	 * Constraint:
	 *     (left=ExpressionOr_ExpressionOr_1_0 operator='OR' right=ExpressionXor)
	 */
	protected void sequence_ExpressionOr(ISerializationContext context, ExpressionOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionOrAccess().getOperatorORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionOrAccess().getRightExpressionXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionPlusMinus
	 *     ExpressionOr returns ExpressionPlusMinus
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionPlusMinus
	 *     ExpressionXor returns ExpressionPlusMinus
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionPlusMinus
	 *     ExpressionAnd returns ExpressionPlusMinus
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionPlusMinus
	 *     ExpressionNot returns ExpressionPlusMinus
	 *     ExpressionComparison returns ExpressionPlusMinus
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionPlusMinus
	 *     ExpressionPlusMinus returns ExpressionPlusMinus
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionPlusMinus
	 *
	 * Constraint:
	 *     (left=ExpressionPlusMinus_ExpressionPlusMinus_1_0 (operator='+' | operator='-') right=ExpressionMulDiv)
	 */
	protected void sequence_ExpressionPlusMinus(ISerializationContext context, ExpressionPlusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionPower
	 *     ExpressionOr returns ExpressionPower
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionPower
	 *     ExpressionXor returns ExpressionPower
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionPower
	 *     ExpressionAnd returns ExpressionPower
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionPower
	 *     ExpressionNot returns ExpressionPower
	 *     ExpressionComparison returns ExpressionPower
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionPower
	 *     ExpressionPlusMinus returns ExpressionPower
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionPower
	 *     ExpressionMulDiv returns ExpressionPower
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionPower
	 *     ExpressionPower returns ExpressionPower
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionPower
	 *
	 * Constraint:
	 *     (left=ExpressionPower_ExpressionPower_1_0 operator='^' right=ExpressionUnaryPlusMinus)
	 */
	protected void sequence_ExpressionPower(ISerializationContext context, ExpressionPower semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionPowerAccess().getOperatorCircumflexAccentKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionPowerAccess().getRightExpressionUnaryPlusMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionUnaryPlusMinus
	 *     ExpressionOr returns ExpressionUnaryPlusMinus
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionUnaryPlusMinus
	 *     ExpressionXor returns ExpressionUnaryPlusMinus
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionUnaryPlusMinus
	 *     ExpressionAnd returns ExpressionUnaryPlusMinus
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionUnaryPlusMinus
	 *     ExpressionNot returns ExpressionUnaryPlusMinus
	 *     ExpressionComparison returns ExpressionUnaryPlusMinus
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionUnaryPlusMinus
	 *     ExpressionPlusMinus returns ExpressionUnaryPlusMinus
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionUnaryPlusMinus
	 *     ExpressionMulDiv returns ExpressionUnaryPlusMinus
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionUnaryPlusMinus
	 *     ExpressionPower returns ExpressionUnaryPlusMinus
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionUnaryPlusMinus
	 *     ExpressionUnaryPlusMinus returns ExpressionUnaryPlusMinus
	 *
	 * Constraint:
	 *     ((operator='+' | operator='-') left=ExpressionUnaryPlusMinus)
	 */
	protected void sequence_ExpressionUnaryPlusMinus(ISerializationContext context, ExpressionUnaryPlusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionXor
	 *     ExpressionOr returns ExpressionXor
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionXor
	 *     ExpressionXor returns ExpressionXor
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionXor
	 *
	 * Constraint:
	 *     (left=ExpressionXor_ExpressionXor_1_0 operator='XOR' right=ExpressionAnd)
	 */
	protected void sequence_ExpressionXor(ISerializationContext context, ExpressionXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionXorAccess().getOperatorXORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionXorAccess().getRightExpressionAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FilterExpression returns FilterExpression
	 *
	 * Constraint:
	 *     (idInColl=IdInColl where=Where?)
	 */
	protected void sequence_FilterExpression(ISerializationContext context, FilterExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Foreach
	 *     Foreach returns Foreach
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration expression=Expression clauses+=Clause+)
	 */
	protected void sequence_Foreach(ISerializationContext context, Foreach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionInvocation
	 *     ExpressionOr returns FunctionInvocation
	 *     ExpressionOr.ExpressionOr_1_0 returns FunctionInvocation
	 *     ExpressionXor returns FunctionInvocation
	 *     ExpressionXor.ExpressionXor_1_0 returns FunctionInvocation
	 *     ExpressionAnd returns FunctionInvocation
	 *     ExpressionAnd.ExpressionAnd_1_0 returns FunctionInvocation
	 *     ExpressionNot returns FunctionInvocation
	 *     ExpressionComparison returns FunctionInvocation
	 *     ExpressionComparison.ExpressionComparison_1_0 returns FunctionInvocation
	 *     ExpressionPlusMinus returns FunctionInvocation
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns FunctionInvocation
	 *     ExpressionMulDiv returns FunctionInvocation
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns FunctionInvocation
	 *     ExpressionPower returns FunctionInvocation
	 *     ExpressionPower.ExpressionPower_1_0 returns FunctionInvocation
	 *     ExpressionUnaryPlusMinus returns FunctionInvocation
	 *     Expression3 returns FunctionInvocation
	 *     Expression3.IndexExpression_1_0_0 returns FunctionInvocation
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns FunctionInvocation
	 *     Expression3.InCollectionExpression_1_2_0 returns FunctionInvocation
	 *     Expression3.StartsWithExpression_1_3_0 returns FunctionInvocation
	 *     Expression3.EndsWithExpression_1_4_0 returns FunctionInvocation
	 *     Expression3.ContainsExpression_1_5_0 returns FunctionInvocation
	 *     Expression3.IsNullExpression_1_6_0 returns FunctionInvocation
	 *     Expression3.IsNotNullExpression_1_7_0 returns FunctionInvocation
	 *     ExpressionNodeLabelsAndPropertyLookup returns FunctionInvocation
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns FunctionInvocation
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns FunctionInvocation
	 *     Atom returns FunctionInvocation
	 *     FunctionInvocation returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName distinct?='DISTINCT'? (parameter+=Expression parameter+=Expression*)?)
	 */
	protected void sequence_FunctionInvocation(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns IndexHint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_Hint(ISerializationContext context, IndexHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__PROPERTY_KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__PROPERTY_KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHintAccess().getVariableVariableDeclarationParserRuleCall_0_5_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getHintAccess().getNodeLabelNodeLabelParserRuleCall_0_6_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getHintAccess().getPropertyKeyNamePropertyKeyNameParserRuleCall_0_9_0(), semanticObject.getPropertyKeyName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns JoinHint
	 *
	 * Constraint:
	 *     (variables+=VariableDeclaration variables+=VariableDeclaration*)
	 */
	protected void sequence_Hint(ISerializationContext context, JoinHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns ScanHint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel)
	 */
	protected void sequence_Hint(ISerializationContext context, ScanHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__NODE_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHintAccess().getVariableVariableDeclarationParserRuleCall_2_1_4_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getHintAccess().getNodeLabelNodeLabelParserRuleCall_2_1_5_0(), semanticObject.getNodeLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdInColl returns IdInColl
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration expression=Expression)
	 */
	protected void sequence_IdInColl(ISerializationContext context, IdInColl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdInCollAccess().getVariableVariableDeclarationParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getIdInCollAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IdLookup
	 *     NodeLookup returns IdLookup
	 *     RelationshipLookup returns IdLookup
	 *     IdLookup returns IdLookup
	 *
	 * Constraint:
	 *     (ids=LiteralIds | legacyParameter=Parameter | wildcard='*')
	 */
	protected void sequence_IdLookup(ISerializationContext context, IdLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IdentifiedIndexLookup
	 *     NodeLookup returns IdentifiedIndexLookup
	 *     RelationshipLookup returns IdentifiedIndexLookup
	 *     IdentifiedIndexLookup returns IdentifiedIndexLookup
	 *
	 * Constraint:
	 *     (indexName=SYMBOLIC_NAME_X key=SYMBOLIC_NAME_X (value=STRING_LITERAL | legacyParameter=LegacyParameter))
	 */
	protected void sequence_IdentifiedIndexLookup(ISerializationContext context, IdentifiedIndexLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns InQueryCall
	 *     InQueryCall returns InQueryCall
	 *
	 * Constraint:
	 *     (invocation=ExplicitProcedureInvocation yieldItems=YieldItems?)
	 */
	protected void sequence_InQueryCall(ISerializationContext context, InQueryCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IndexQuery
	 *     NodeLookup returns IndexQuery
	 *     RelationshipLookup returns IndexQuery
	 *     IndexQuery returns IndexQuery
	 *
	 * Constraint:
	 *     (indexName=SYMBOLIC_NAME_X (query=STRING_LITERAL | parameter=Parameter))
	 */
	protected void sequence_IndexQuery(ISerializationContext context, IndexQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Index returns Index
	 *
	 * Constraint:
	 *     (nodeLabel=NodeLabel propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX__PROPERTY_KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX__PROPERTY_KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexAccess().getNodeLabelNodeLabelParserRuleCall_2_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getIndexAccess().getPropertyKeyNamePropertyKeyNameParserRuleCall_4_0(), semanticObject.getPropertyKeyName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns LegacyParameter
	 *     Expression returns LegacyParameter
	 *     ExpressionOr returns LegacyParameter
	 *     ExpressionOr.ExpressionOr_1_0 returns LegacyParameter
	 *     ExpressionXor returns LegacyParameter
	 *     ExpressionXor.ExpressionXor_1_0 returns LegacyParameter
	 *     ExpressionAnd returns LegacyParameter
	 *     ExpressionAnd.ExpressionAnd_1_0 returns LegacyParameter
	 *     ExpressionNot returns LegacyParameter
	 *     ExpressionComparison returns LegacyParameter
	 *     ExpressionComparison.ExpressionComparison_1_0 returns LegacyParameter
	 *     ExpressionPlusMinus returns LegacyParameter
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns LegacyParameter
	 *     ExpressionMulDiv returns LegacyParameter
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns LegacyParameter
	 *     ExpressionPower returns LegacyParameter
	 *     ExpressionPower.ExpressionPower_1_0 returns LegacyParameter
	 *     ExpressionUnaryPlusMinus returns LegacyParameter
	 *     Expression3 returns LegacyParameter
	 *     Expression3.IndexExpression_1_0_0 returns LegacyParameter
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns LegacyParameter
	 *     Expression3.InCollectionExpression_1_2_0 returns LegacyParameter
	 *     Expression3.StartsWithExpression_1_3_0 returns LegacyParameter
	 *     Expression3.EndsWithExpression_1_4_0 returns LegacyParameter
	 *     Expression3.ContainsExpression_1_5_0 returns LegacyParameter
	 *     Expression3.IsNullExpression_1_6_0 returns LegacyParameter
	 *     Expression3.IsNotNullExpression_1_7_0 returns LegacyParameter
	 *     ExpressionNodeLabelsAndPropertyLookup returns LegacyParameter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns LegacyParameter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns LegacyParameter
	 *     Atom returns LegacyParameter
	 *     LegacyParameter returns LegacyParameter
	 *
	 * Constraint:
	 *     (parameter=SYMBOLIC_NAME_X | parameter=Number)
	 */
	protected void sequence_LegacyParameter(ISerializationContext context, LegacyParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns Limit
	 *
	 * Constraint:
	 *     limit=Expression
	 */
	protected void sequence_Limit(ISerializationContext context, Limit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.LIMIT__LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.LIMIT__LIMIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLimitAccess().getLimitExpressionParserRuleCall_1_0(), semanticObject.getLimit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListComprehension
	 *     ExpressionOr returns ListComprehension
	 *     ExpressionOr.ExpressionOr_1_0 returns ListComprehension
	 *     ExpressionXor returns ListComprehension
	 *     ExpressionXor.ExpressionXor_1_0 returns ListComprehension
	 *     ExpressionAnd returns ListComprehension
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ListComprehension
	 *     ExpressionNot returns ListComprehension
	 *     ExpressionComparison returns ListComprehension
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ListComprehension
	 *     ExpressionPlusMinus returns ListComprehension
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ListComprehension
	 *     ExpressionMulDiv returns ListComprehension
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ListComprehension
	 *     ExpressionPower returns ListComprehension
	 *     ExpressionPower.ExpressionPower_1_0 returns ListComprehension
	 *     ExpressionUnaryPlusMinus returns ListComprehension
	 *     Expression3 returns ListComprehension
	 *     Expression3.IndexExpression_1_0_0 returns ListComprehension
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns ListComprehension
	 *     Expression3.InCollectionExpression_1_2_0 returns ListComprehension
	 *     Expression3.StartsWithExpression_1_3_0 returns ListComprehension
	 *     Expression3.EndsWithExpression_1_4_0 returns ListComprehension
	 *     Expression3.ContainsExpression_1_5_0 returns ListComprehension
	 *     Expression3.IsNullExpression_1_6_0 returns ListComprehension
	 *     Expression3.IsNotNullExpression_1_7_0 returns ListComprehension
	 *     ExpressionNodeLabelsAndPropertyLookup returns ListComprehension
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns ListComprehension
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns ListComprehension
	 *     Atom returns ListComprehension
	 *     ListComprehension returns ListComprehension
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression?)
	 */
	protected void sequence_ListComprehension(ISerializationContext context, ListComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralIds returns LiteralIds
	 *
	 * Constraint:
	 *     (ids+=DecimalInteger ids+=DecimalInteger*)
	 */
	protected void sequence_LiteralIds(ISerializationContext context, LiteralIds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LoadCSVQuery returns LoadCSVQuery
	 *
	 * Constraint:
	 *     (loadCSV=LoadCSV clauses+=Clause*)
	 */
	protected void sequence_LoadCSVQuery(ISerializationContext context, LoadCSVQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns LoadCSV
	 *     LoadCSV returns LoadCSV
	 *
	 * Constraint:
	 *     (withHeaders?=LoadCSVWithHeaders? expression=Expression variable=VariableDeclaration fieldterminator=STRING_LITERAL?)
	 */
	protected void sequence_LoadCSV(ISerializationContext context, LoadCSV semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapLiteralEntry returns MapLiteralEntry
	 *
	 * Constraint:
	 *     (key=PropertyKeyName value=Expression)
	 */
	protected void sequence_MapLiteralEntry(ISerializationContext context, MapLiteralEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__KEY));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapLiteralEntryAccess().getKeyPropertyKeyNameParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapLiteralEntryAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns MapLiteral
	 *     Expression returns MapLiteral
	 *     ExpressionOr returns MapLiteral
	 *     ExpressionOr.ExpressionOr_1_0 returns MapLiteral
	 *     ExpressionXor returns MapLiteral
	 *     ExpressionXor.ExpressionXor_1_0 returns MapLiteral
	 *     ExpressionAnd returns MapLiteral
	 *     ExpressionAnd.ExpressionAnd_1_0 returns MapLiteral
	 *     ExpressionNot returns MapLiteral
	 *     ExpressionComparison returns MapLiteral
	 *     ExpressionComparison.ExpressionComparison_1_0 returns MapLiteral
	 *     ExpressionPlusMinus returns MapLiteral
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns MapLiteral
	 *     ExpressionMulDiv returns MapLiteral
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns MapLiteral
	 *     ExpressionPower returns MapLiteral
	 *     ExpressionPower.ExpressionPower_1_0 returns MapLiteral
	 *     ExpressionUnaryPlusMinus returns MapLiteral
	 *     Expression3 returns MapLiteral
	 *     Expression3.IndexExpression_1_0_0 returns MapLiteral
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns MapLiteral
	 *     Expression3.InCollectionExpression_1_2_0 returns MapLiteral
	 *     Expression3.StartsWithExpression_1_3_0 returns MapLiteral
	 *     Expression3.EndsWithExpression_1_4_0 returns MapLiteral
	 *     Expression3.ContainsExpression_1_5_0 returns MapLiteral
	 *     Expression3.IsNullExpression_1_6_0 returns MapLiteral
	 *     Expression3.IsNotNullExpression_1_7_0 returns MapLiteral
	 *     ExpressionNodeLabelsAndPropertyLookup returns MapLiteral
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns MapLiteral
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns MapLiteral
	 *     Atom returns MapLiteral
	 *     MapLiteral returns MapLiteral
	 *
	 * Constraint:
	 *     (entries+=MapLiteralEntry entries+=MapLiteralEntry*)?
	 */
	protected void sequence_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Match
	 *     Match returns Match
	 *
	 * Constraint:
	 *     (optional?='OPTIONAL'? pattern=Pattern hints+=Hint* where=Where?)
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MergeAction returns MergeAction
	 *
	 * Constraint:
	 *     ((action='MATCH' | action='CREATE') set=Set)
	 */
	protected void sequence_MergeAction(ISerializationContext context, MergeAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Merge
	 *     Merge returns Merge
	 *
	 * Constraint:
	 *     (patternPart=PatternPart mergeActions+=MergeAction*)
	 */
	protected void sequence_Merge(ISerializationContext context, Merge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeLabel returns NodeLabel
	 *
	 * Constraint:
	 *     labelName=LabelName
	 */
	protected void sequence_NodeLabel(ISerializationContext context, NodeLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_LABEL__LABEL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_LABEL__LABEL_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeLabelAccess().getLabelNameLabelNameParserRuleCall_1_0(), semanticObject.getLabelName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeLabels returns NodeLabels
	 *
	 * Constraint:
	 *     (nodeLabels+=NodeLabel nodeLabels+=NodeLabel*)
	 */
	protected void sequence_NodeLabels(ISerializationContext context, NodeLabels semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodePattern returns NodePattern
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration? nodeLabels=NodeLabels? properties=Properties?)
	 */
	protected void sequence_NodePattern(ISerializationContext context, NodePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NodePropertyExistenceConstraint
	 *     Command returns NodePropertyExistenceConstraint
	 *     CreateNodePropertyExistenceConstraint returns NodePropertyExistenceConstraint
	 *     NodePropertyExistenceConstraint returns NodePropertyExistenceConstraint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel propertyExpression=PropertyExpression)
	 */
	protected void sequence_NodePropertyExistenceConstraint(ISerializationContext context, NodePropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getVariableVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getNodeLabelNodeLabelParserRuleCall_4_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_9_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Order returns Order
	 *
	 * Constraint:
	 *     (orderBy+=SortItem orderBy+=SortItem*)
	 */
	protected void sequence_Order(ISerializationContext context, Order semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns Parameter
	 *     Expression returns Parameter
	 *     ExpressionOr returns Parameter
	 *     ExpressionOr.ExpressionOr_1_0 returns Parameter
	 *     ExpressionXor returns Parameter
	 *     ExpressionXor.ExpressionXor_1_0 returns Parameter
	 *     ExpressionAnd returns Parameter
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Parameter
	 *     ExpressionNot returns Parameter
	 *     ExpressionComparison returns Parameter
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Parameter
	 *     ExpressionPlusMinus returns Parameter
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Parameter
	 *     ExpressionMulDiv returns Parameter
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Parameter
	 *     ExpressionPower returns Parameter
	 *     ExpressionPower.ExpressionPower_1_0 returns Parameter
	 *     ExpressionUnaryPlusMinus returns Parameter
	 *     Expression3 returns Parameter
	 *     Expression3.IndexExpression_1_0_0 returns Parameter
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns Parameter
	 *     Expression3.InCollectionExpression_1_2_0 returns Parameter
	 *     Expression3.StartsWithExpression_1_3_0 returns Parameter
	 *     Expression3.EndsWithExpression_1_4_0 returns Parameter
	 *     Expression3.ContainsExpression_1_5_0 returns Parameter
	 *     Expression3.IsNullExpression_1_6_0 returns Parameter
	 *     Expression3.IsNotNullExpression_1_7_0 returns Parameter
	 *     ExpressionNodeLabelsAndPropertyLookup returns Parameter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns Parameter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns Parameter
	 *     Atom returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (parameter=SYMBOLIC_NAME_X | parameter=Number)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.slizaa.neo4j.opencypher.openCypher.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ParenthesizedExpression
	 *     ExpressionOr returns ParenthesizedExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns ParenthesizedExpression
	 *     ExpressionXor returns ParenthesizedExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns ParenthesizedExpression
	 *     ExpressionAnd returns ParenthesizedExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ParenthesizedExpression
	 *     ExpressionNot returns ParenthesizedExpression
	 *     ExpressionComparison returns ParenthesizedExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ParenthesizedExpression
	 *     ExpressionPlusMinus returns ParenthesizedExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ParenthesizedExpression
	 *     ExpressionMulDiv returns ParenthesizedExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ParenthesizedExpression
	 *     ExpressionPower returns ParenthesizedExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns ParenthesizedExpression
	 *     ExpressionUnaryPlusMinus returns ParenthesizedExpression
	 *     Expression3 returns ParenthesizedExpression
	 *     Expression3.IndexExpression_1_0_0 returns ParenthesizedExpression
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns ParenthesizedExpression
	 *     Expression3.InCollectionExpression_1_2_0 returns ParenthesizedExpression
	 *     Expression3.StartsWithExpression_1_3_0 returns ParenthesizedExpression
	 *     Expression3.EndsWithExpression_1_4_0 returns ParenthesizedExpression
	 *     Expression3.ContainsExpression_1_5_0 returns ParenthesizedExpression
	 *     Expression3.IsNullExpression_1_6_0 returns ParenthesizedExpression
	 *     Expression3.IsNotNullExpression_1_7_0 returns ParenthesizedExpression
	 *     ExpressionNodeLabelsAndPropertyLookup returns ParenthesizedExpression
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns ParenthesizedExpression
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns ParenthesizedExpression
	 *     Atom returns ParenthesizedExpression
	 *     ParenthesizedExpression returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ParenthesizedExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesizedExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PatternComprehension
	 *     ExpressionOr returns PatternComprehension
	 *     ExpressionOr.ExpressionOr_1_0 returns PatternComprehension
	 *     ExpressionXor returns PatternComprehension
	 *     ExpressionXor.ExpressionXor_1_0 returns PatternComprehension
	 *     ExpressionAnd returns PatternComprehension
	 *     ExpressionAnd.ExpressionAnd_1_0 returns PatternComprehension
	 *     ExpressionNot returns PatternComprehension
	 *     ExpressionComparison returns PatternComprehension
	 *     ExpressionComparison.ExpressionComparison_1_0 returns PatternComprehension
	 *     ExpressionPlusMinus returns PatternComprehension
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns PatternComprehension
	 *     ExpressionMulDiv returns PatternComprehension
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns PatternComprehension
	 *     ExpressionPower returns PatternComprehension
	 *     ExpressionPower.ExpressionPower_1_0 returns PatternComprehension
	 *     ExpressionUnaryPlusMinus returns PatternComprehension
	 *     Expression3 returns PatternComprehension
	 *     Expression3.IndexExpression_1_0_0 returns PatternComprehension
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns PatternComprehension
	 *     Expression3.InCollectionExpression_1_2_0 returns PatternComprehension
	 *     Expression3.StartsWithExpression_1_3_0 returns PatternComprehension
	 *     Expression3.EndsWithExpression_1_4_0 returns PatternComprehension
	 *     Expression3.ContainsExpression_1_5_0 returns PatternComprehension
	 *     Expression3.IsNullExpression_1_6_0 returns PatternComprehension
	 *     Expression3.IsNotNullExpression_1_7_0 returns PatternComprehension
	 *     ExpressionNodeLabelsAndPropertyLookup returns PatternComprehension
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns PatternComprehension
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns PatternComprehension
	 *     Atom returns PatternComprehension
	 *     PatternComprehension returns PatternComprehension
	 *
	 * Constraint:
	 *     (pathVariable=VariableDeclaration? pattern=RelationshipsPattern where=Where? expression=Expression)
	 */
	protected void sequence_PatternComprehension(ISerializationContext context, PatternComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternElementChain returns PatternElementChain
	 *
	 * Constraint:
	 *     (relationshipPattern=RelationshipPattern nodePattern=NodePattern)
	 */
	protected void sequence_PatternElementChain(ISerializationContext context, PatternElementChain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__RELATIONSHIP_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__RELATIONSHIP_PATTERN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__NODE_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__NODE_PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternElementChainAccess().getRelationshipPatternRelationshipPatternParserRuleCall_0_0(), semanticObject.getRelationshipPattern());
		feeder.accept(grammarAccess.getPatternElementChainAccess().getNodePatternNodePatternParserRuleCall_1_0(), semanticObject.getNodePattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns PatternElement
	 *     AnonymousPatternPart returns PatternElement
	 *     PatternElement returns PatternElement
	 *
	 * Constraint:
	 *     (nodepattern=NodePattern chain+=PatternElementChain*)
	 */
	protected void sequence_PatternElement(ISerializationContext context, PatternElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns PatternPart
	 *
	 * Constraint:
	 *     (var=VariableDeclaration part=AnonymousPatternPart)
	 */
	protected void sequence_PatternPart(ISerializationContext context, PatternPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__VAR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternPartAccess().getVarVariableDeclarationParserRuleCall_0_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getPatternPartAccess().getPartAnonymousPatternPartParserRuleCall_0_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (patterns+=PatternPart patterns+=PatternPart*)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PeriodicCommitHint returns PeriodicCommitHint
	 *
	 * Constraint:
	 *     numberOfRowsPerCommit=DecimalInteger?
	 */
	protected void sequence_PeriodicCommitHint(ISerializationContext context, PeriodicCommitHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplicitProcedureInvocation returns ProcedureName
	 *     ProcedureName returns ProcedureName
	 *
	 * Constraint:
	 *     (namespace=Namespace name=SYMBOLIC_NAME_X)
	 */
	protected void sequence_ProcedureName(ISerializationContext context, ProcedureName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAMESPACE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PROCEDURE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureNameAccess().getNamespaceNamespaceParserRuleCall_0_0(), semanticObject.getNamespace());
		feeder.accept(grammarAccess.getProcedureNameAccess().getNameSYMBOLIC_NAME_XParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyExpression returns PropertyExpression
	 *
	 * Constraint:
	 *     (left=Atom propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression(ISerializationContext context, PropertyExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyLookup returns PropertyLookup
	 *
	 * Constraint:
	 *     ((propertyKeyName=PropertyKeyName (propertyOperator='?' | propertyOperator='!')) | propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_PropertyLookup(ISerializationContext context, PropertyLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QueryOptions returns AllOptions
	 *
	 * Constraint:
	 *     (explain?='EXPLAIN' | profile?='PROFILE' | cypherOption+=CypherOption)*
	 */
	protected void sequence_QueryOptions(ISerializationContext context, AllOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RangeLiteral returns RangeLiteral
	 *
	 * Constraint:
	 *     (lower=Number? upper=Number?)
	 */
	protected void sequence_RangeLiteral(ISerializationContext context, RangeLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Reduce
	 *     ExpressionOr returns Reduce
	 *     ExpressionOr.ExpressionOr_1_0 returns Reduce
	 *     ExpressionXor returns Reduce
	 *     ExpressionXor.ExpressionXor_1_0 returns Reduce
	 *     ExpressionAnd returns Reduce
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Reduce
	 *     ExpressionNot returns Reduce
	 *     ExpressionComparison returns Reduce
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Reduce
	 *     ExpressionPlusMinus returns Reduce
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Reduce
	 *     ExpressionMulDiv returns Reduce
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Reduce
	 *     ExpressionPower returns Reduce
	 *     ExpressionPower.ExpressionPower_1_0 returns Reduce
	 *     ExpressionUnaryPlusMinus returns Reduce
	 *     Expression3 returns Reduce
	 *     Expression3.IndexExpression_1_0_0 returns Reduce
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns Reduce
	 *     Expression3.InCollectionExpression_1_2_0 returns Reduce
	 *     Expression3.StartsWithExpression_1_3_0 returns Reduce
	 *     Expression3.EndsWithExpression_1_4_0 returns Reduce
	 *     Expression3.ContainsExpression_1_5_0 returns Reduce
	 *     Expression3.IsNullExpression_1_6_0 returns Reduce
	 *     Expression3.IsNotNullExpression_1_7_0 returns Reduce
	 *     ExpressionNodeLabelsAndPropertyLookup returns Reduce
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns Reduce
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns Reduce
	 *     Atom returns Reduce
	 *     Reduce returns Reduce
	 *
	 * Constraint:
	 *     (accumulator=VariableDeclaration accumulatorExpression=Expression idInColl=IdInColl expression=Expression)
	 */
	protected void sequence_Reduce(ISerializationContext context, Reduce semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ID_IN_COLL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ID_IN_COLL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReduceAccess().getAccumulatorVariableDeclarationParserRuleCall_2_0(), semanticObject.getAccumulator());
		feeder.accept(grammarAccess.getReduceAccess().getAccumulatorExpressionExpressionParserRuleCall_4_0(), semanticObject.getAccumulatorExpression());
		feeder.accept(grammarAccess.getReduceAccess().getIdInCollIdInCollParserRuleCall_6_0(), semanticObject.getIdInColl());
		feeder.accept(grammarAccess.getReduceAccess().getExpressionExpressionParserRuleCall_8_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CombinedQuery
	 *     Query returns CombinedQuery
	 *     RegularQuery returns CombinedQuery
	 *
	 * Constraint:
	 *     (singleQuery=RegularQuery_CombinedQuery_1_0 union+=Union+)
	 */
	protected void sequence_RegularQuery(ISerializationContext context, CombinedQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipDetail returns RelationshipDetail
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration? optional?='?'? types=RelationshipTypes? range=RangeLiteral? properties=Properties?)
	 */
	protected void sequence_RelationshipDetail(ISerializationContext context, RelationshipDetail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipPatternSyntax returns RelationshipPatternSyntax
	 *
	 * Constraint:
	 *     (incoming?=LeftArrowHead? variable=VariableDeclaration relType=RelType outgoing?=RightArrowHead?)
	 */
	protected void sequence_RelationshipPatternSyntax(ISerializationContext context, RelationshipPatternSyntax semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipPattern returns RelationshipPattern
	 *
	 * Constraint:
	 *     (incoming?=LeftArrowHead? detail=RelationshipDetail? outgoing?=RightArrowHead?)
	 */
	protected void sequence_RelationshipPattern(ISerializationContext context, RelationshipPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RelationshipPropertyExistenceConstraint
	 *     Command returns RelationshipPropertyExistenceConstraint
	 *     CreateRelationshipPropertyExistenceConstraint returns RelationshipPropertyExistenceConstraint
	 *     RelationshipPropertyExistenceConstraint returns RelationshipPropertyExistenceConstraint
	 *
	 * Constraint:
	 *     (relationshipPattern=RelationshipPatternSyntax propertyExpression=PropertyExpression)
	 */
	protected void sequence_RelationshipPropertyExistenceConstraint(ISerializationContext context, RelationshipPropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PATTERN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationshipPropertyExistenceConstraintAccess().getRelationshipPatternRelationshipPatternSyntaxParserRuleCall_2_0(), semanticObject.getRelationshipPattern());
		feeder.accept(grammarAccess.getRelationshipPropertyExistenceConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_6_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipTypes returns RelationshipTypes
	 *
	 * Constraint:
	 *     (relTypeName+=RelTypeName relTypeName+=RelTypeName*)
	 */
	protected void sequence_RelationshipTypes(ISerializationContext context, RelationshipTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RelationshipsPattern
	 *     ExpressionOr returns RelationshipsPattern
	 *     ExpressionOr.ExpressionOr_1_0 returns RelationshipsPattern
	 *     ExpressionXor returns RelationshipsPattern
	 *     ExpressionXor.ExpressionXor_1_0 returns RelationshipsPattern
	 *     ExpressionAnd returns RelationshipsPattern
	 *     ExpressionAnd.ExpressionAnd_1_0 returns RelationshipsPattern
	 *     ExpressionNot returns RelationshipsPattern
	 *     ExpressionComparison returns RelationshipsPattern
	 *     ExpressionComparison.ExpressionComparison_1_0 returns RelationshipsPattern
	 *     ExpressionPlusMinus returns RelationshipsPattern
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns RelationshipsPattern
	 *     ExpressionMulDiv returns RelationshipsPattern
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns RelationshipsPattern
	 *     ExpressionPower returns RelationshipsPattern
	 *     ExpressionPower.ExpressionPower_1_0 returns RelationshipsPattern
	 *     ExpressionUnaryPlusMinus returns RelationshipsPattern
	 *     Expression3 returns RelationshipsPattern
	 *     Expression3.IndexExpression_1_0_0 returns RelationshipsPattern
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns RelationshipsPattern
	 *     Expression3.InCollectionExpression_1_2_0 returns RelationshipsPattern
	 *     Expression3.StartsWithExpression_1_3_0 returns RelationshipsPattern
	 *     Expression3.EndsWithExpression_1_4_0 returns RelationshipsPattern
	 *     Expression3.ContainsExpression_1_5_0 returns RelationshipsPattern
	 *     Expression3.IsNullExpression_1_6_0 returns RelationshipsPattern
	 *     Expression3.IsNotNullExpression_1_7_0 returns RelationshipsPattern
	 *     ExpressionNodeLabelsAndPropertyLookup returns RelationshipsPattern
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns RelationshipsPattern
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns RelationshipsPattern
	 *     Atom returns RelationshipsPattern
	 *     RelationshipsPattern returns RelationshipsPattern
	 *
	 * Constraint:
	 *     (nodePattern=NodePattern chain+=PatternElementChain+)
	 */
	protected void sequence_RelationshipsPattern(ISerializationContext context, RelationshipsPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns RemoveItemLabel
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabels=NodeLabels)
	 */
	protected void sequence_RemoveItem(ISerializationContext context, RemoveItemLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_LABEL__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_LABEL__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_LABEL__NODE_LABELS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_LABEL__NODE_LABELS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveItemAccess().getVariableVariableDeclarationParserRuleCall_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getRemoveItemAccess().getNodeLabelsNodeLabelsParserRuleCall_0_2_0(), semanticObject.getNodeLabels());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns RemoveItemProperty
	 *
	 * Constraint:
	 *     propertyExpression=PropertyExpression
	 */
	protected void sequence_RemoveItem(ISerializationContext context, RemoveItemProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_PROPERTY__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM_PROPERTY__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveItemAccess().getPropertyExpressionPropertyExpressionParserRuleCall_1_1_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     (removeItems+=RemoveItem removeItems+=RemoveItem*)
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnBody returns ReturnBody
	 *
	 * Constraint:
	 *     (returnItems=ReturnItems order=Order? skip=Skip? limit=Limit?)
	 */
	protected void sequence_ReturnBody(ISerializationContext context, ReturnBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnItem returns ReturnItem
	 *
	 * Constraint:
	 *     (expression=Expression alias=VariableDeclaration?)
	 */
	protected void sequence_ReturnItem(ISerializationContext context, ReturnItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnItems returns ReturnItems
	 *
	 * Constraint:
	 *     ((all='*' items+=ReturnItem*) | (items+=ReturnItem items+=ReturnItem*))
	 */
	protected void sequence_ReturnItems(ISerializationContext context, ReturnItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     (return='RETURN' distinct?='DISTINCT'? body=ReturnBody)
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetItem returns SetItem
	 *
	 * Constraint:
	 *     (
	 *         (propertyExpression=PropertyExpression expression=Expression) | 
	 *         (variable=VariableDeclaration expression=Expression) | 
	 *         (variable=VariableDeclaration expression=Expression) | 
	 *         (variable=VariableDeclaration nodeLabels=NodeLabels)
	 *     )
	 */
	protected void sequence_SetItem(ISerializationContext context, SetItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Set
	 *     Set returns Set
	 *
	 * Constraint:
	 *     (setItems+=SetItem setItems+=SetItem*)
	 */
	protected void sequence_Set(ISerializationContext context, org.slizaa.neo4j.opencypher.openCypher.Set semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns AllShortestPaths
	 *     AnonymousPatternPart returns AllShortestPaths
	 *     ShortestPathPattern returns AllShortestPaths
	 *     Expression returns AllShortestPaths
	 *     ExpressionOr returns AllShortestPaths
	 *     ExpressionOr.ExpressionOr_1_0 returns AllShortestPaths
	 *     ExpressionXor returns AllShortestPaths
	 *     ExpressionXor.ExpressionXor_1_0 returns AllShortestPaths
	 *     ExpressionAnd returns AllShortestPaths
	 *     ExpressionAnd.ExpressionAnd_1_0 returns AllShortestPaths
	 *     ExpressionNot returns AllShortestPaths
	 *     ExpressionComparison returns AllShortestPaths
	 *     ExpressionComparison.ExpressionComparison_1_0 returns AllShortestPaths
	 *     ExpressionPlusMinus returns AllShortestPaths
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns AllShortestPaths
	 *     ExpressionMulDiv returns AllShortestPaths
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns AllShortestPaths
	 *     ExpressionPower returns AllShortestPaths
	 *     ExpressionPower.ExpressionPower_1_0 returns AllShortestPaths
	 *     ExpressionUnaryPlusMinus returns AllShortestPaths
	 *     Expression3 returns AllShortestPaths
	 *     Expression3.IndexExpression_1_0_0 returns AllShortestPaths
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns AllShortestPaths
	 *     Expression3.InCollectionExpression_1_2_0 returns AllShortestPaths
	 *     Expression3.StartsWithExpression_1_3_0 returns AllShortestPaths
	 *     Expression3.EndsWithExpression_1_4_0 returns AllShortestPaths
	 *     Expression3.ContainsExpression_1_5_0 returns AllShortestPaths
	 *     Expression3.IsNullExpression_1_6_0 returns AllShortestPaths
	 *     Expression3.IsNotNullExpression_1_7_0 returns AllShortestPaths
	 *     ExpressionNodeLabelsAndPropertyLookup returns AllShortestPaths
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns AllShortestPaths
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns AllShortestPaths
	 *     Atom returns AllShortestPaths
	 *
	 * Constraint:
	 *     patternElement=PatternElement
	 */
	protected void sequence_ShortestPathPattern(ISerializationContext context, AllShortestPaths semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortestPathPatternAccess().getPatternElementPatternElementParserRuleCall_1_3_0(), semanticObject.getPatternElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns ShortestPath
	 *     AnonymousPatternPart returns ShortestPath
	 *     ShortestPathPattern returns ShortestPath
	 *     Expression returns ShortestPath
	 *     ExpressionOr returns ShortestPath
	 *     ExpressionOr.ExpressionOr_1_0 returns ShortestPath
	 *     ExpressionXor returns ShortestPath
	 *     ExpressionXor.ExpressionXor_1_0 returns ShortestPath
	 *     ExpressionAnd returns ShortestPath
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ShortestPath
	 *     ExpressionNot returns ShortestPath
	 *     ExpressionComparison returns ShortestPath
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ShortestPath
	 *     ExpressionPlusMinus returns ShortestPath
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ShortestPath
	 *     ExpressionMulDiv returns ShortestPath
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ShortestPath
	 *     ExpressionPower returns ShortestPath
	 *     ExpressionPower.ExpressionPower_1_0 returns ShortestPath
	 *     ExpressionUnaryPlusMinus returns ShortestPath
	 *     Expression3 returns ShortestPath
	 *     Expression3.IndexExpression_1_0_0 returns ShortestPath
	 *     Expression3.RegExpMatchingExpression_1_1_0 returns ShortestPath
	 *     Expression3.InCollectionExpression_1_2_0 returns ShortestPath
	 *     Expression3.StartsWithExpression_1_3_0 returns ShortestPath
	 *     Expression3.EndsWithExpression_1_4_0 returns ShortestPath
	 *     Expression3.ContainsExpression_1_5_0 returns ShortestPath
	 *     Expression3.IsNullExpression_1_6_0 returns ShortestPath
	 *     Expression3.IsNotNullExpression_1_7_0 returns ShortestPath
	 *     ExpressionNodeLabelsAndPropertyLookup returns ShortestPath
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionPropertyLookup_1_0 returns ShortestPath
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabels_2_0 returns ShortestPath
	 *     Atom returns ShortestPath
	 *
	 * Constraint:
	 *     patternElement=PatternElement
	 */
	protected void sequence_ShortestPathPattern(ISerializationContext context, ShortestPath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortestPathPatternAccess().getPatternElementPatternElementParserRuleCall_0_3_0(), semanticObject.getPatternElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SingleQuery
	 *     Query returns SingleQuery
	 *     RegularQuery returns SingleQuery
	 *     RegularQuery.CombinedQuery_1_0 returns SingleQuery
	 *     SingleQuery returns SingleQuery
	 *
	 * Constraint:
	 *     (clauses+=Clause clauses+=Clause*)
	 */
	protected void sequence_SingleQuery(ISerializationContext context, SingleQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Skip returns Skip
	 *
	 * Constraint:
	 *     skip=Expression
	 */
	protected void sequence_Skip(ISerializationContext context, Skip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SKIP__SKIP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SKIP__SKIP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSkipAccess().getSkipExpressionParserRuleCall_1_0(), semanticObject.getSkip());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortItem returns SortItem
	 *
	 * Constraint:
	 *     (expression=Expression (sort='DESCENDING' | sort='DESC' | sort='ASCENDING' | sort='ASC')?)
	 */
	protected void sequence_SortItem(ISerializationContext context, SortItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StandaloneCall
	 *     Query returns StandaloneCall
	 *     StandaloneCall returns StandaloneCall
	 *
	 * Constraint:
	 *     ((invocation=ExplicitProcedureInvocation | invocation=ImplicitProcedureInvocation) yieldItems=YieldItems?)
	 */
	protected void sequence_StandaloneCall(ISerializationContext context, StandaloneCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StartPoint returns StartPoint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration lookup=Lookup)
	 */
	protected void sequence_StartPoint(ISerializationContext context, StartPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.START_POINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.START_POINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.START_POINT__LOOKUP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.START_POINT__LOOKUP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartPointAccess().getVariableVariableDeclarationParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getStartPointAccess().getLookupLookupParserRuleCall_2_0(), semanticObject.getLookup());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Start
	 *     Start returns Start
	 *
	 * Constraint:
	 *     (startPoint+=StartPoint startPoint+=StartPoint* where=Where?)
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Union returns Union
	 *
	 * Constraint:
	 *     (all?='ALL'? singleQuery=SingleQuery)
	 */
	protected void sequence_Union(ISerializationContext context, Union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UniqueConstraint
	 *     Command returns UniqueConstraint
	 *     CreateUniqueConstraint returns UniqueConstraint
	 *     UniqueConstraint returns UniqueConstraint
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration nodeLabel=NodeLabel propertyExpression=PropertyExpression)
	 */
	protected void sequence_UniqueConstraint(ISerializationContext context, UniqueConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getVariableVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getNodeLabelNodeLabelParserRuleCall_4_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_7_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Unwind
	 *     Unwind returns Unwind
	 *
	 * Constraint:
	 *     (expression=Expression variable=VariableDeclaration)
	 */
	protected void sequence_Unwind(ISerializationContext context, Unwind semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNWIND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNWIND__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNWIND__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNWIND__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnwindAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getUnwindAccess().getVariableVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     name=SYMBOLIC_NAME_X
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VARIABLE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameSYMBOLIC_NAME_XParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VersionNumber returns VersionNumber
	 *
	 * Constraint:
	 *     versionNumber=Number
	 */
	protected void sequence_VersionNumber(ISerializationContext context, VersionNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VERSION_NUMBER__VERSION_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VERSION_NUMBER__VERSION_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVersionNumberAccess().getVersionNumberNumberParserRuleCall_0(), semanticObject.getVersionNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.WHERE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.WHERE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhereAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns With
	 *     With returns With
	 *
	 * Constraint:
	 *     (distint?='DISTINCT'? returnBody=ReturnBody where=Where?)
	 */
	protected void sequence_With(ISerializationContext context, With semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YieldItem returns YieldItem
	 *
	 * Constraint:
	 *     (field=ProcedureResultField? variable=VariableDeclaration)
	 */
	protected void sequence_YieldItem(ISerializationContext context, YieldItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     YieldItems returns YieldItems
	 *
	 * Constraint:
	 *     (items+=YieldItem items+=YieldItem*)?
	 */
	protected void sequence_YieldItems(ISerializationContext context, YieldItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
